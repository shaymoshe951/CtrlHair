#!/bin/sh
# This is a shell archive (produced by GNU sharutils 4.2.1).
# To extract the files from this archive, save it to some FILE, remove
# everything before the `!/bin/sh' line above, then type `sh FILE'.
#
# Made on 2005-07-28 15:33 PDT by <jrs@pyramid.CS.Berkeley.EDU>.
# Source directory was `/.automount/project/vol/vol2/shewchuk/a/home/prof/jrs/mesh/previous/triangle1.6'.
#
# Existing files will *not* be overwritten unless `-c' is specified.
#
# This shar contains:
# length mode       name
# ------ ---------- ------------------------------------------
#   1045 -rw-r--r-- A.poly
#   8727 -rw-r--r-- README
#   4805 -rw-r--r-- makefile
# 108795 -rw-r--r-- showme.c
# 650942 -rw-r--r-- triangle.c
#  21905 -rw-r--r-- triangle.h
#  10300 -rw-r--r-- tricall.c
#
save_IFS="${IFS}"
IFS="${IFS}:"
gettext_dir=FAILED
locale_dir=FAILED
first_param="$1"
for dir in $PATH
do
  if test "$gettext_dir" = FAILED && test -f $dir/gettext \
     && ($dir/gettext --version >/dev/null 2>&1)
  then
    set `$dir/gettext --version 2>&1`
    if test "$3" = GNU
    then
      gettext_dir=$dir
    fi
  fi
  if test "$locale_dir" = FAILED && test -f $dir/shar \
     && ($dir/shar --print-text-domain-dir >/dev/null 2>&1)
  then
    locale_dir=`$dir/shar --print-text-domain-dir`
  fi
done
IFS="$save_IFS"
if test "$locale_dir" = FAILED || test "$gettext_dir" = FAILED
then
  echo=echo
else
  TEXTDOMAINDIR=$locale_dir
  export TEXTDOMAINDIR
  TEXTDOMAIN=sharutils
  export TEXTDOMAIN
  echo="$gettext_dir/gettext -s"
fi
if touch -am -t 200112312359.59 $$.touch >/dev/null 2>&1 && test ! -f 200112312359.59 -a -f $$.touch; then
  shar_touch='touch -am -t $1$2$3$4$5$6.$7 "$8"'
elif touch -am 123123592001.59 $$.touch >/dev/null 2>&1 && test ! -f 123123592001.59 -a ! -f 123123592001.5 -a -f $$.touch; then
  shar_touch='touch -am $3$4$5$6$1$2.$7 "$8"'
elif touch -am 1231235901 $$.touch >/dev/null 2>&1 && test ! -f 1231235901 -a -f $$.touch; then
  shar_touch='touch -am $3$4$5$6$2 "$8"'
else
  shar_touch=:
  echo
  $echo 'WARNING: not restoring timestamps.  Consider getting and'
  $echo "installing GNU \`touch', distributed in GNU File Utilities..."
  echo
fi
rm -f 200112312359.59 123123592001.59 123123592001.5 1231235901 $$.touch
#
if mkdir _sh09797; then
  $echo 'x -' 'creating lock directory'
else
  $echo 'failed to create lock directory'
  exit 1
fi
# ============= A.poly ==============
if test -f 'A.poly' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'A.poly' '(file already exists)'
else
  $echo 'x -' extracting 'A.poly' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'A.poly' &&
29 2 1 0
1 0.200000 -0.776400 -0.57
2 0.220000 -0.773200 -0.55
3 0.245600 -0.756400 -0.51
4 0.277600 -0.702000 -0.53
5 0.488800 -0.207600 0.28
6 0.504800 -0.207600 0.30
7 0.740800 -0.739600 0
8 0.756000 -0.761200 -0.01
9 0.774400 -0.772400 0
10 0.800000 -0.776400 0.02
11 0.800000 -0.792400 0.01
12 0.579200 -0.792400 -0.21
13 0.579200 -0.776400 -0.2
14 0.621600 -0.771600 -0.15
15 0.633600 -0.762800 -0.13
16 0.639200 -0.744400 -0.1
17 0.620800 -0.684400 -0.06
18 0.587200 -0.604400 -0.01
19 0.360800 -0.604400 -0.24
20 0.319200 -0.706800 -0.39
21 0.312000 -0.739600 -0.43
22 0.318400 -0.761200 -0.44
23 0.334400 -0.771600 -0.44
24 0.371200 -0.776400 -0.41
25 0.371200 -0.792400 -0.42
26 0.374400 -0.570000 -0.2
27 0.574400 -0.570000 0
28 0.473600 -0.330800 0.14
29 0.200000 -0.792400 -0.59
29 0
1 29 1
2 1 2
3 2 3
4 3 4
5 4 5
6 5 6
7 6 7
8 7 8
9 8 9
10 9 10
11 10 11
12 11 12
13 12 13
14 13 14
15 14 15
16 15 16
17 16 17
18 17 18
19 18 19
20 19 20
21 20 21
22 21 22
23 22 23
24 23 24
25 24 25
26 25 29
27 26 27
28 27 28
29 28 26
1
1 0.47 -0.5
SHAR_EOF
  (set 20 05 07 27 16 08 57 'A.poly'; eval "$shar_touch") &&
  chmod 0644 'A.poly' ||
  $echo 'restore of' 'A.poly' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'A.poly:' 'MD5 check failed'
c4620d87e5a18733ce552ed79d2cc9d1  A.poly
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'A.poly'`"
    test 1045 -eq "$shar_count" ||
    $echo 'A.poly:' 'original size' '1045,' 'current size' "$shar_count!"
  fi
fi
# ============= README ==============
if test -f 'README' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'README' '(file already exists)'
else
  $echo 'x -' extracting 'README' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'README' &&
Triangle
A Two-Dimensional Quality Mesh Generator and Delaunay Triangulator.
Version 1.6
X
Show Me
A Display Program for Meshes and More.
Version 1.6
X
Copyright 1993, 1995, 1997, 1998, 2002, 2005 Jonathan Richard Shewchuk
2360 Woolsey #H
Berkeley, California  94705-1927
Please send bugs and comments to jrs@cs.berkeley.edu
X
Created as part of the Quake project (tools for earthquake simulation).
Supported in part by NSF Grant CMS-9318163 and an NSERC 1967 Scholarship.
There is no warranty whatsoever.  Use at your own risk.
X
X
Triangle generates exact Delaunay triangulations, constrained Delaunay
triangulations, conforming Delaunay triangulations, Voronoi diagrams, and
high-quality triangular meshes.  The latter can be generated with no small
or large angles, and are thus suitable for finite element analysis.
Show Me graphically displays the contents of the geometric files used by
Triangle.  Show Me can also write images in PostScript form.
X
Information on the algorithms used by Triangle, including complete
references, can be found in the comments at the beginning of the triangle.c
source file.  Another listing of these references, with PostScript copies
of some of the papers, is available from the Web page
X
X    http://www.cs.cmu.edu/~quake/triangle.research.html
X
------------------------------------------------------------------------------
X
These programs may be freely redistributed under the condition that the
copyright notices (including the copy of this notice in the code comments
and the copyright notice printed when the `-h' switch is selected) are
not removed, and no compensation is received.  Private, research, and
institutional use is free.  You may distribute modified versions of this
code UNDER THE CONDITION THAT THIS CODE AND ANY MODIFICATIONS MADE TO IT
IN THE SAME FILE REMAIN UNDER COPYRIGHT OF THE ORIGINAL AUTHOR, BOTH
SOURCE AND OBJECT CODE ARE MADE FREELY AVAILABLE WITHOUT CHARGE, AND
CLEAR NOTICE IS GIVEN OF THE MODIFICATIONS.  Distribution of this code as
part of a commercial system is permissible ONLY BY DIRECT ARRANGEMENT
WITH THE AUTHOR.  (If you are not directly supplying this code to a
customer, and you are instead telling them how they can obtain it for
free, then you are not required to make any arrangement with me.)
X
------------------------------------------------------------------------------
X
The files included in this distribution are:
X
X  README           The file you're reading now.
X  triangle.c       Complete C source code for Triangle.
X  showme.c         Complete C source code for Show Me.
X  triangle.h       Include file for calling Triangle from another program.
X  tricall.c        Sample program that calls Triangle.
X  makefile         Makefile for compiling Triangle and Show Me.
X  A.poly           A sample input file.
X
Each of Triangle and Show Me is a single portable C file.  The easiest way
to compile them is to edit and use the included makefile.  Before
compiling, read the makefile, which describes your options, and edit it
accordingly.  You should specify:
X
X  The source and binary directories.
X
X  The C compiler and level of optimization.
X
X  The "correct" directories for include files (especially X include files),
X  if necessary.
X
X  Do you want single precision or double?  (The default is double.)  Do you
X  want to leave out some of Triangle's features to reduce the size of the
X  executable file?  Investigate the SINGLE, REDUCED, and CDT_ONLY symbols.
X
X  If yours is not a Unix system, define the NO_TIMER symbol to remove the
X  Unix-specific timing code.  Also, don't try to compile Show Me; it only
X  works with X Windows.
X
X  If you are compiling on an Intel x86 CPU and using gcc w/Linux or
X  Microsoft C, be sure to define the LINUX or CPU86 (for Microsoft) symbol
X  during compilation so that the exact arithmetic works right.
X
Once you've done this, type "make" to compile the programs.  Alternatively,
the files are usually easy to compile without a makefile:
X
X  cc -O -o triangle triangle.c -lm
X  cc -O -o showme showme.c -lX11
X
On some systems, the C compiler won't be able to find the X include files
or libraries, and you'll need to specify an include path or library path:
X
X  cc -O -I/usr/local/include -o showme showme.c -L/usr/local/lib -lX11
X
Some processors, including Intel x86 family and possibly Motorola 68xxx
family chips, are IEEE conformant but have extended length internal
floating-point registers that may defeat Triangle's exact arithmetic
routines by failing to cause enough roundoff error!  Typically, there is a
way to set these internal registers so that they are rounded off to IEEE
single or double precision format.  I believe (but I'm not certain) that
Triangle has the right incantations for x86 chips, if you have gcc running
under Linux (define the LINUX compiler symbol) or Microsoft C (define the
CPU86 compiler symbol).
X
If you have a different processor or operating system, or if I got the
incantations wrong, you should check your C compiler or system manuals to
find out how to configure these internal registers to the precision you are
using.  Otherwise, the exact arithmetic routines won't be exact at all.
See http://www.cs.cmu.edu/~quake/robust.pc.html for details.  Triangle's
exact arithmetic hasn't a hope of working on machines like the Cray C90 or
Y-MP, which are not IEEE conformant and have inaccurate rounding.
X
Triangle and Show Me have both text and HTML documentation.  The latter is
illustrated.  Find it on the Web at
X
X  http://www.cs.cmu.edu/~quake/triangle.html
X  http://www.cs.cmu.edu/~quake/showme.html
X
Complete text instructions are printed by invoking each program with the
`-h' switch:
X
X  triangle -h
X  showme -h
X
The instructions are long; you'll probably want to pipe the output to
`more' or `lpr' or redirect it to a file.
X
Both programs give a short list of command line options if they are invoked
without arguments (that is, just type `triangle' or `showme').
X
Try out Triangle on the enclosed sample file, A.poly:
X
X  triangle -p A
X  showme A.poly &
X
Triangle will read the Planar Straight Line Graph defined by A.poly, and
write its constrained Delaunay triangulation to A.1.node and A.1.ele.
Show Me will display the figure defined by A.poly.  There are two buttons
marked "ele" in the Show Me window; click on the top one.  This will cause
Show Me to load and display the triangulation.
X
For contrast, try running
X
X  triangle -pq A
X
Now, click on the same "ele" button.  A new triangulation will be loaded;
this one having no angles smaller than 20 degrees.
X
To see a Voronoi diagram, try this:
X
X  cp A.poly A.node
X  triangle -v A
X
Click the "ele" button again.  You will see the Delaunay triangulation of
the points in A.poly, without the segments.  Now click the top "voro" button.
You will see the Voronoi diagram corresponding to that Delaunay triangulation.
Click the "Reset" button to see the full extent of the diagram.
X
------------------------------------------------------------------------------
X
If you wish to call Triangle from another program, instructions for doing
so are contained in the file `triangle.h' (but read Triangle's regular
instructions first!).  Also look at `tricall.c', which provides an example
of how to call Triangle.
X
Type "make trilibrary" to create triangle.o, a callable object file.
Alternatively, the object file is usually easy to compile without a
makefile:
X
X  cc -DTRILIBRARY -O -c triangle.c
X
Type "make distclean" to remove all the object and executable files created
by make.
X
------------------------------------------------------------------------------
X
If you use Triangle, and especially if you use it to accomplish real work,
I would like very much to hear from you.  A short letter or email (to
jrs@cs.berkeley.edu) describing how you use Triangle will mean a lot to me.
The more people I know are using this program, the more easily I can
justify spending time on improvements and on the three-dimensional
successor to Triangle, which in turn will benefit you.  Also, I can put you
on a list to receive email whenever a new version of Triangle is available.
X
If you use a mesh generated by Triangle or plotted by Show Me in a
publication, please include an acknowledgment as well.  And please spell
Triangle with a capital `T'!  If you want to include a citation, use
`Jonathan Richard Shewchuk, ``Triangle:  Engineering a 2D Quality Mesh
Generator and Delaunay Triangulator,'' in Applied Computational Geometry:
Towards Geometric Engineering (Ming C. Lin and Dinesh Manocha, editors),
volume 1148 of Lecture Notes in Computer Science, pages 203-222,
Springer-Verlag, Berlin, May 1996.  (From the First ACM Workshop on Applied
Computational Geometry.)'
X
X
Jonathan Richard Shewchuk
July 27, 2005
SHAR_EOF
  (set 20 05 07 28 15 32 46 'README'; eval "$shar_touch") &&
  chmod 0644 'README' ||
  $echo 'restore of' 'README' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'README:' 'MD5 check failed'
af8ecec8bfe01395f1c0bd9153ba1dc6  README
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'README'`"
    test 8727 -eq "$shar_count" ||
    $echo 'README:' 'original size' '8727,' 'current size' "$shar_count!"
  fi
fi
# ============= makefile ==============
if test -f 'makefile' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'makefile' '(file already exists)'
else
  $echo 'x -' extracting 'makefile' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'makefile' &&
# makefile for Triangle and Show Me
#
# Type "make" to compile Triangle and Show Me.
#
# After compiling, type "triangle -h" and "showme -h" to read instructions
#   for using each of these programs.
#
# Type "make trilibrary" to compile Triangle as an object file (triangle.o).
#
# Type "make distclean" to delete all object and executable files.
X
# SRC is the directory in which the C source files are, and BIN is the
#   directory where you want to put the executable programs.  By default,
#   both are the current directory.
X
SRC = ./
BIN = ./
X
# CC should be set to the name of your favorite C compiler.
X
CC = cc
X
# CSWITCHES is a list of all switches passed to the C compiler.  I strongly
#   recommend using the best level of optimization.  I also strongly
#   recommend timing each level of optimization to see which is the
#   best.  For instance, when I had a DEC Alpha using DEC's optimizing
#   compiler, the -O2 switch generated a notably faster version of Triangle
#   than the -O3 switch.  Go figure.
#
# By default, Triangle and Show Me use double precision floating point
#   numbers.  If you prefer single precision, use the -DSINGLE switch.
#   Double precision uses more memory, but improves the resolution of
#   the meshes you can generate with Triangle.  It also reduces the
#   likelihood of a floating exception due to overflow.  Also, it is
#   much faster than single precision on many architectures.  I recommend
#   double precision unless you want to generate a mesh for which you do
#   not have enough memory to use double precision.
#
# If yours is not a Unix system, use the -DNO_TIMER switch to eliminate the
#   Unix-specific timer code.  Also, don't try to compile Show Me; it only
#   works with X Windows.
#
# To get the exact arithmetic to work right on an Intel processor, use the
#   -DCPU86 switch with Microsoft C, or the -DLINUX switch with gcc running
#   on Linux.  The floating-point arithmetic might not be robust otherwise.
#   Please see http://www.cs.cmu.edu/~quake/robust.pc.html for details.
#
# If you are modifying Triangle, I recommend using the -DSELF_CHECK switch
#   while you are debugging.  Defining the SELF_CHECK symbol causes
#   Triangle to include self-checking code.  Triangle will execute more
#   slowly, however, so be sure to remove this switch before compiling a
#   production version.
#
# If the size of the Triangle binary is important to you, you may wish to
#   generate a reduced version of Triangle.  The -DREDUCED switch gets rid
#   of all features that are primarily of research interest.  Specifically,
#   defining the REDUCED symbol eliminates the -i, -F, -s, and -C switches.
#   The -DCDT_ONLY switch gets rid of all meshing algorithms above and beyond
#   constrained Delaunay triangulation.  Specifically, defining the CDT_ONLY
#   symbol eliminates the -r, -q, -a, -u, -D, -S, and -s switches.  The
#   REDUCED and CDT_ONLY symbols may be particularly attractive when Triangle
#   is called by another program that does not need all of Triangle's
#   features; in this case, these switches should appear as part of
#   "TRILIBDEFS" below.
#
# On some systems, you may need to include -I/usr/local/include and/or
#   -L/usr/local/lib in the compiler options to ensure that the X include
#   files and libraries that Show Me needs are found.  If you get errors
#   like "Can't find include file X11/Xlib.h", you need the former switch.
#   Try compiling without them first; add them if that fails.
#
# An example CSWITCHES line is:
#
#   CSWITCHES = -O -DNO_TIMER -DLINUX -I/usr/X11R6/include -L/usr/X11R6/lib
X
CSWITCHES = -O -DLINUX -I/usr/X11R6/include -L/usr/X11R6/lib
X
# TRILIBDEFS is a list of definitions used to compile an object code version
#   of Triangle (triangle.o) to be called by another program.  The file
#   "triangle.h" contains detailed information on how to call triangle.o.
#
# The -DTRILIBRARY should always be used when compiling Triangle into an
#   object file.
#
# An example TRILIBDEFS line is:
#
#   TRILIBDEFS = -DTRILIBRARY -DREDUCED -DCDT_ONLY
X
TRILIBDEFS = -DTRILIBRARY
X
# RM should be set to the name of your favorite rm (file deletion program).
X
RM = /bin/rm
X
# The action starts here.
X
all: $(BIN)triangle $(BIN)showme
X
trilibrary: $(BIN)triangle.o $(BIN)tricall
X
$(BIN)triangle: $(SRC)triangle.c
X	$(CC) $(CSWITCHES) -o $(BIN)triangle $(SRC)triangle.c -lm
X
$(BIN)tricall: $(BIN)tricall.c $(BIN)triangle.o
X	$(CC) $(CSWITCHES) -o $(BIN)tricall $(SRC)tricall.c \
X		$(BIN)triangle.o -lm
X
$(BIN)triangle.o: $(SRC)triangle.c $(SRC)triangle.h
X	$(CC) $(CSWITCHES) $(TRILIBDEFS) -c -o $(BIN)triangle.o \
X		$(SRC)triangle.c
X
$(BIN)showme: $(SRC)showme.c
X	$(CC) $(CSWITCHES) -o $(BIN)showme $(SRC)showme.c -lX11
X
distclean:
X	$(RM) $(BIN)triangle $(BIN)triangle.o $(BIN)tricall $(BIN)showme
SHAR_EOF
  (set 20 05 07 27 17 22 01 'makefile'; eval "$shar_touch") &&
  chmod 0644 'makefile' ||
  $echo 'restore of' 'makefile' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'makefile:' 'MD5 check failed'
5c5d3f2861ce8fded106e75439c6abf1  makefile
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'makefile'`"
    test 4805 -eq "$shar_count" ||
    $echo 'makefile:' 'original size' '4805,' 'current size' "$shar_count!"
  fi
fi
# ============= showme.c ==============
if test -f 'showme.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'showme.c' '(file already exists)'
else
  $echo 'x -' extracting 'showme.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'showme.c' &&
/*****************************************************************************/
/*                                                                           */
/*    ,d88^^o 888                                   o    o                   */
/*    8888    888o^88,  o88^^o Y88b    o    /      d8b  d8b      o88^^8o     */
/*    "Y88b   888  888 d888   b Y88b  d8b  /      d888bdY88b    d888  88b    */
/*     "Y88b, 888  888 8888   8  Y888/Y88b/      / Y88Y Y888b   8888oo888    */
/*    o  8888 888  888 q888   p   Y8/  Y8/      /   YY   Y888b  q888         */
/*    "oo88P" 888  888  "88oo"     Y    Y      /          Y888b  "88oooo"    */
/*                                                                           */
/*  A Display Program for Meshes and More.                                   */
/*  (showme.c)                                                               */
/*                                                                           */
/*  Version 1.6                                                              */
/*  July 28, 2005                                                            */
/*                                                                           */
/*  Copyright 1996, 1998, 2005                                               */
/*  Jonathan Richard Shewchuk                                                */
/*  2360 Woolsey #H                                                          */
/*  Berkeley, California  94705-1927                                         */
/*  jrs@cs.berkeley.edu                                                      */
/*                                                                           */
/*  This program may be freely redistributed under the condition that the    */
/*    copyright notices (including this entire header and the copyright      */
/*    notice printed when the `-h' switch is selected) are not removed, and  */
/*    no compensation is received.  Private, research, and institutional     */
/*    use is free.  You may distribute modified versions of this code UNDER  */
/*    THE CONDITION THAT THIS CODE AND ANY MODIFICATIONS MADE TO IT IN THE   */
/*    SAME FILE REMAIN UNDER COPYRIGHT OF THE ORIGINAL AUTHOR, BOTH SOURCE   */
/*    AND OBJECT CODE ARE MADE FREELY AVAILABLE WITHOUT CHARGE, AND CLEAR    */
/*    NOTICE IS GIVEN OF THE MODIFICATIONS.  Distribution of this code as    */
/*    part of a commercial system is permissible ONLY BY DIRECT ARRANGEMENT  */
/*    WITH THE AUTHOR.  (If you are not directly supplying this code to a    */
/*    customer, and you are instead telling them how they can obtain it for  */
/*    free, then you are not required to make any arrangement with me.)      */
/*                                                                           */
/*  Hypertext instructions for Triangle are available on the Web at          */
/*                                                                           */
/*      http://www.cs.cmu.edu/~quake/showme.html                             */
/*                                                                           */
/*  Show Me was created as part of the Archimedes project in the School of   */
/*    Computer Science at Carnegie Mellon University.  Archimedes is a       */
/*    system for compiling parallel finite element solvers.  For further     */
/*    information, see Anja Feldmann, Omar Ghattas, John R. Gilbert, Gary L. */
/*    Miller, David R. O'Hallaron, Eric J. Schwabe, Jonathan R. Shewchuk,    */
/*    and Shang-Hua Teng.  "Automated Parallel Solution of Unstructured PDE  */
/*    Problems."  To appear in Communications of the ACM, we hope.           */
/*                                                                           */
/*  If you make any improvements to this code, please please please let me   */
/*    know, so that I may obtain the improvements.  Even if you don't change */
/*    the code, I'd still love to hear what it's being used for.             */
/*                                                                           */
/*  Disclaimer:  Neither I nor Carnegie Mellon warrant this code in any way  */
/*    whatsoever.  Use at your own risk.                                     */
/*                                                                           */
/*****************************************************************************/
X
/* For single precision (which will save some memory and reduce paging),     */
/*   write "#define SINGLE" below.                                           */
/*                                                                           */
/* For double precision (which will allow you to display triangulations of   */
/*   a finer resolution), leave SINGLE undefined.                            */
X
/* #define SINGLE */
X
#ifdef SINGLE
#define REAL float
#else
#define REAL double
#endif
X
/* Maximum number of characters in a file name (including the null).         */
X
#define FILENAMESIZE 2048
X
/* Maximum number of characters in a line read from a file (including the    */
/*   null).                                                                  */
X
#define INPUTLINESIZE 1024
X
#define STARTWIDTH 414
#define STARTHEIGHT 414
#define MINWIDTH 50
#define MINHEIGHT 50
#define BUTTONHEIGHT 21
#define BUTTONROWS 3
#define PANELHEIGHT (BUTTONHEIGHT * BUTTONROWS)
#define MAXCOLORS 64
X
#define IMAGE_TYPES 7
#define NOTHING -1
#define NODE 0
#define POLY 1
#define ELE 2
#define EDGE 3
#define PART 4
#define ADJ 5
#define VORO 6
X
#define STARTEXPLOSION 0.5
X
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <X11/Xlib.h>
#include <X11/Xutil.h>
#include <X11/Xatom.h>
X
/* A necessary forward declaration.                                          */
X
int load_image();
X
Display *display;
int screen;
Window rootwindow;
Window mainwindow;
Window quitwin;
Window leftwin;
Window rightwin;
Window upwin;
Window downwin;
Window resetwin;
Window pswin;
Window epswin;
Window expwin;
Window exppluswin;
Window expminuswin;
Window widthpluswin;
Window widthminuswin;
Window versionpluswin;
Window versionminuswin;
Window fillwin;
Window nodewin[2];
Window polywin[2];
Window elewin[2];
Window edgewin[2];
Window partwin[2];
Window adjwin[2];
Window voronoiwin[2];
X
int windowdepth;
XXEvent event;
Colormap rootmap;
XXFontStruct *font;
int width, height;
int black, white;
int showme_foreground;
GC fontgc;
GC blackfontgc;
GC linegc;
GC trianglegc;
int colors[MAXCOLORS];
XXColor rgb[MAXCOLORS];
int color;
X
int start_image, current_image;
int start_inc, current_inc;
int loweriteration;
int line_width;
int loaded[2][IMAGE_TYPES];
REAL xlo[2][IMAGE_TYPES], ylo[2][IMAGE_TYPES];
REAL xhi[2][IMAGE_TYPES], yhi[2][IMAGE_TYPES];
REAL xscale, yscale;
REAL xoffset, yoffset;
int zoom;
X
int nodes[2], node_dim[2];
REAL *nodeptr[2];
int polynodes[2], poly_dim[2], polyedges[2], polyholes[2];
REAL *polynodeptr[2], *polyholeptr[2];
int *polyedgeptr[2];
int elems[2], ele_corners[2];
int *eleptr[2];
int edges[2];
int *edgeptr[2];
REAL *normptr[2];
int subdomains[2];
int *partpart[2];
REAL *partcenter[2], *partshift[2];
int adjsubdomains[2];
int *adjptr[2];
int vnodes[2], vnode_dim[2];
REAL *vnodeptr[2];
int vedges[2];
int *vedgeptr[2];
REAL *vnormptr[2];
int firstnumber[2];
X
int quiet, fillelem, bw_ps, explode;
REAL explosion;
X
char filename[FILENAMESIZE];
char nodefilename[2][FILENAMESIZE];
char polyfilename[2][FILENAMESIZE];
char elefilename[2][FILENAMESIZE];
char edgefilename[2][FILENAMESIZE];
char partfilename[2][FILENAMESIZE];
char adjfilename[2][FILENAMESIZE];
char vnodefilename[2][FILENAMESIZE];
char vedgefilename[2][FILENAMESIZE];
X
char *colorname[] = {"aquamarine", "red", "green yellow", "magenta",
X                     "yellow", "green", "orange", "blue",
X                     "white", "sandy brown", "cyan", "moccasin",
X                     "cadet blue", "coral", "cornflower blue", "sky blue",
X                     "firebrick", "forest green", "gold", "goldenrod",
X                     "gray", "hot pink", "chartreuse", "pale violet red",
X                     "indian red", "khaki", "lavender", "light blue",
X                     "light gray", "light steel blue", "lime green", "azure",
X                     "maroon", "medium aquamarine", "dodger blue", "honeydew",
X                     "medium orchid", "medium sea green", "moccasin",
X                     "medium slate blue", "medium spring green",
X                     "medium turquoise", "medium violet red",
X                     "orange red", "chocolate", "light goldenrod",
X                     "orchid", "pale green", "pink", "plum",
X                     "purple", "salmon", "sea green",
X                     "sienna", "slate blue", "spring green",
X                     "steel blue", "tan", "thistle", "turquoise",
X                     "violet", "violet red", "wheat",
X                     "yellow green"};
X
void syntax()
{
X  printf("showme [-bfw_Qh] input_file\n");
X  printf("    -b  Black and white PostScript (default is color).\n");
X  printf("    -f  Fill triangles of partitioned mesh with color.\n");
X  printf("    -w  Set line width to some specified number.\n");
X  printf("    -Q  Quiet:  No terminal output except errors.\n");
X  printf("    -h  Help:  Detailed instructions for Show Me.\n");
X  exit(0);
}
X
void info()
{
X  printf("Show Me\n");
X  printf("A Display Program for Meshes and More.\n");
X  printf("Version 1.6\n\n");
X  printf(
"Copyright 1996 Jonathan Richard Shewchuk  (bugs/comments to jrs@cs.cmu.edu)\n"
);
X  printf("School of Computer Science / Carnegie Mellon University\n");
X  printf("5000 Forbes Avenue / Pittsburgh, Pennsylvania  15213-3891\n");
X  printf(
"Created as part of the Archimedes project (tools for parallel FEM).\n");
X  printf(
"Supported in part by NSF Grant CMS-9318163 and an NSERC 1967 Scholarship.\n");
X  printf("There is no warranty whatsoever.  Use at your own risk.\n");
#ifdef SINGLE
X  printf("This executable is compiled for single precision arithmetic.\n\n\n");
#else
X  printf("This executable is compiled for double precision arithmetic.\n\n\n");
#endif
X  printf(
"Show Me graphically displays the contents of geometric files, especially\n");
X  printf(
"those generated by Triangle, my two-dimensional quality mesh generator and\n"
);
X  printf(
"Delaunay triangulator.  Show Me can also write images in PostScript form.\n");
X  printf(
"Show Me is also useful for checking the consistency of the files you create\n"
);
X  printf(
"as input to Triangle; Show Me does these checks more thoroughly than\n");
X  printf("Triangle does.  The command syntax is:\n\n");
X  printf("showme [-bfw_Qh] input_file\n\n");
X  printf(
"The underscore indicates that a number should follow the -w switch.\n");
X  printf(
"input_file may be one of several types of file.  It must have extension\n");
X  printf(
".node, .poly, .ele, .edge, .part, or .adj.  If no extension is provided,\n");
X  printf(
"Show Me will assume the extension .ele.  A .node file represents a set of\n");
X  printf(
"points; a .poly file represents a Planar Straight Line Graph; an .ele file\n"
);
X  printf(
"(coupled with a .node file) represents the elements of a mesh or the\n");
X  printf(
"triangles of a triangulation; an .edge file (coupled with a .node file)\n");
X  printf(
"represents a set of edges; a .part file specifies a partition of a mesh;\n");
X  printf(
"and a .adj file represents the adjacency graph defined by a partition.\n");
X  printf("\n");
X  printf("Command Line Switches:\n");
X  printf("\n");
X  printf(
"    -b  Makes all PostScript output black and white.  If this switch is not\n"
);
X  printf(
"        selected, color PostScript is used for partitioned meshes and\n");
X  printf("        adjacency graphs (.part and .adj files).\n");
X  printf(
"    -f  On color displays and in color PostScript, displays partitioned\n");
X  printf(
"        meshes by filling triangles with color, rather than by coloring the\n"
);
X  printf(
"        edges.  This switch will result in a clearer picture if all\n");
X  printf(
"        triangles are reasonably large, and a less clear picture if small\n");
X  printf(
"        triangles are present.  (There is also a button to toggle this\n");
X  printf("        behavior.)\n");
X  printf(
"    -w  Followed by an integer, specifies the line width used in all\n");
X  printf(
"        images.  (There are also buttons to change the line width.)\n");
X  printf(
"    -Q  Quiet:  Suppresses all explanation of what Show Me is doing, unless\n"
);
X  printf("        an error occurs.\n");
X  printf("    -h  Help:  Displays these instructions.\n");
X  printf("\n");
X  printf("Controls:\n");
X  printf("\n");
X  printf(
"  To zoom in on an image, point at the location where you want a closer\n");
X  printf(
"  look, and click the left mouse button.  To zoom out, click the right\n");
X  printf(
"  mouse button.  In either case, the point you click on will be centered in\n"
);
X  printf(
"  the window.  If you want to know the coordinates of a point, click the\n");
X  printf(
"  middle mouse button; the coordinates will be printed on the terminal you\n"
);
X  printf("  invoked Show Me from.\n\n");
X  printf(
"  If you resize the window, the image will grow or shrink to match.\n");
X  printf("\n");
X  printf(
"  There is a panel of control buttons at the bottom of the Show Me window:\n"
);
X  printf("\n");
X  printf("  Quit:  Shuts down Show Me.\n");
X  printf("  <, >, ^, v:  Moves the image in the indicated direction.\n");
X  printf(
"  Reset: Unzooms and centers the image in the window.  When you switch from\n"
);
X  printf(
"    one image to another, the viewing region does not change, so you may\n");
X  printf(
"    need to reset the new image to make it fully visible.  This often is\n");
X  printf(
"    the case when switching between Delaunay triangulations and their\n");
X  printf(
"    corresponding Voronoi diagrams, as Voronoi vertices can be far from the\n"
);
X  printf("    initial point set.\n");
X  printf(
"  Width+, -:  Increases or decreases the width of all lines and points.\n");
X  printf(
"  Exp, +, -:  These buttons appear only when you are viewing a partitioned\n"
);
X  printf(
"    mesh (.part file).  `Exp' toggles between an exploded and non-exploded\n"
);
X  printf(
"    image of the mesh.  The non-exploded image will not show the partition\n"
);
X  printf(
"    on a black and white monitor.  `+' and `-' allow you to adjust the\n");
X  printf(
"    spacing between pieces of the mesh to better distinguish them.\n");
X  printf(
"  Fill:  This button appears only when you are viewing a partitioned mesh\n");
X  printf(
"    (.part file).  It toggles between color-filled triangles and colored\n");
X  printf(
"    edges (as the -f switch does).  Filled triangles look better when all\n");
X  printf(
"    triangles are reasonably large; colored edges look better when there\n");
X  printf("    are very small triangles present.\n");
X  printf(
"  PS:  Creates a PostScript file containing the image you are viewing.  If\n"
);
X  printf(
"    the -b switch is selected, all PostScript output will be black and\n");
X  printf(
"    white; otherwise, .part.ps and .adj.ps files will be color, independent\n"
);
X  printf(
"    of whether you are using a color monitor.  Normally the output will\n");
X  printf(
"    preserve the properties of the image you see on the screen, including\n");
X  printf(
"    zoom and line width; however, if black and white output is selected (-b\n"
);
X  printf(
"    switch), partitioned meshes will always be drawn exploded.  The output\n"
);
X  printf(
"    file name depends on the image being viewed.  If you want several\n");
X  printf(
"    different snapshots (zooming in on different parts) of the same object,\n"
);
X  printf(
"    you'll have to rename each file after Show Me creates it so that it\n");
X  printf("    isn't overwritten by the next snapshot.\n");
X  printf(
"  EPS:  Creates an encapsulated PostScript file, suitable for inclusion in\n"
);
X  printf(
"    documents.  Otherwise, this button is just like the PS button.  (The\n");
X  printf(
"    only difference is that .eps files lack a `showpage' command at the\n");
X  printf("    end.)\n\n");
X  printf(
"  There are two nearly-identical rows of buttons that load different images\n"
);
X  printf("  from disk.  Each row contains the following buttons:\n\n");
X  printf("  node:  Loads a .node file.\n");
X  printf(
"  poly:  Loads a .poly file (and possibly an associated .node file).\n");
X  printf("  ele:  Loads an .ele file (and associated .node file).\n");
X  printf("  edge:  Loads an .edge file (and associated .node file).\n");
X  printf(
"  part:  Loads a .part file (and associated .node and .ele files).\n");
X  printf(
"  adj:  Loads an .adj file (and associated .node, .ele, and .part files).\n");
X  printf("  voro:  Loads a .v.node and .v.edge file for a Voronoi diagram.\n");
X  printf("\n");
X  printf(
"  Each row represents a different iteration number of the geometry files.\n");
X  printf(
"  For a full explanation of iteration numbers, read the instructions for\n");
X  printf(
"  Triangle.  Briefly, iteration numbers are used to allow a user to easily\n"
);
X  printf(
"  represent a sequence of related triangulations.  Iteration numbers are\n");
X  printf(
"  used in the names of geometry files; for instance, mymesh.3.ele is a\n");
X  printf(
"  triangle file with iteration number three, and mymesh.ele has an implicit\n"
);
X  printf("  iteration number of zero.\n\n");
X  printf(
"  The control buttons at the right end of each row display the two\n");
X  printf(
"  iterations currently under view.  These buttons can be clicked to\n");
X  printf(
"  increase or decrease the iteration numbers, and thus conveniently view\n");
X  printf("  a sequence of meshes.\n\n");
X  printf(
"  Show Me keeps each file in memory after loading it, but you can force\n");
X  printf(
"  Show Me to reread a set of files (for one iteration number) by reclicking\n"
);
X  printf(
"  the button that corresponds to the current image.  This is convenient if\n"
);
X  printf("  you have changed a geometry file.\n\n");
X  printf("File Formats:\n\n");
X  printf(
"  All files may contain comments prefixed by the character '#'.  Points,\n");
X  printf(
"  segments, holes, triangles, edges, and subdomains must be numbered\n");
X  printf(
"  consecutively, starting from either 1 or 0.  Whichever you choose, all\n");
X  printf(
"  input files must be consistent (for any single iteration number); if the\n"
);
X  printf(
"  nodes are numbered from 1, so must be all other objects.  Show Me\n");
X  printf(
"  automatically detects your choice while reading a .node (or .poly) file.\n"
);
X  printf("  Examples of these file formats are given below.\n\n");
X  printf("  .node files:\n");
X  printf(
"    First line:  <# of points> <dimension (must be 2)> <# of attributes>\n");
X  printf(
"                                           <# of boundary markers (0 or 1)>\n"
);
X  printf(
"    Remaining lines:  <point #> <x> <y> [attributes] [boundary marker]\n");
X  printf("\n");
X  printf(
"    The attributes, which are typically floating-point values of physical\n");
X  printf(
"    quantities (such as mass or conductivity) associated with the nodes of\n"
);
X  printf(
"    a finite element mesh, are ignored by Show Me.  Show Me also ignores\n");
X  printf(
"    boundary markers.  See the instructions for Triangle to find out what\n");
X  printf("    attributes and boundary markers are.\n\n");
X  printf("  .poly files:\n");
X  printf(
"    First line:  <# of points> <dimension (must be 2)> <# of attributes>\n");
X  printf(
"                                           <# of boundary markers (0 or 1)>\n"
);
X  printf(
"    Following lines:  <point #> <x> <y> [attributes] [boundary marker]\n");
X  printf("    One line:  <# of segments> <# of boundary markers (0 or 1)>\n");
X  printf(
"    Following lines:  <segment #> <endpoint> <endpoint> [boundary marker]\n");
X  printf("    One line:  <# of holes>\n");
X  printf("    Following lines:  <hole #> <x> <y>\n");
X  printf("    [Optional additional lines that are ignored]\n\n");
X  printf(
"    A .poly file represents a Planar Straight Line Graph (PSLG), an idea\n");
X  printf(
"    familiar to computational geometers.  By definition, a PSLG is just a\n");
X  printf(
"    list of points and edges.  A .poly file also contains some additional\n");
X  printf("    information.\n\n");
X  printf(
"    The first section lists all the points, and is identical to the format\n"
);
X  printf(
"    of .node files.  <# of points> may be set to zero to indicate that the\n"
);
X  printf(
"    points are listed in a separate .node file; .poly files produced by\n");
X  printf(
"    Triangle always have this format.  When Show Me reads such a file, it\n");
X  printf("    also reads the corresponding .node file.\n\n");
X  printf(
"    The second section lists the segments.  Segments are edges whose\n");
X  printf(
"    presence in a triangulation produced from the PSLG is enforced.  Each\n");
X  printf(
"    segment is specified by listing the indices of its two endpoints.  This\n"
);
X  printf(
"    means that its endpoints must be included in the point list.  Each\n");
X  printf(
"    segment, like each point, may have a boundary marker, which is ignored\n"
);
X  printf("    by Show Me.\n\n");
X  printf(
"    The third section lists holes and concavities that are desired in any\n");
X  printf(
"    triangulation generated from the PSLG.  Holes are specified by\n");
X  printf("    identifying a point inside each hole.\n\n");
X  printf("  .ele files:\n");
X  printf(
"    First line:  <# of triangles> <points per triangle> <# of attributes>\n");
X  printf(
"    Remaining lines:  <triangle #> <point> <point> <point> ... [attributes]\n"
);
X  printf("\n");
X  printf(
"    Points are indices into the corresponding .node file.  Show Me ignores\n"
);
X  printf(
"    all but the first three points of each triangle; these should be the\n");
X  printf(
"    corners listed in counterclockwise order around the triangle.  The\n");
X  printf("    attributes are ignored by Show Me.\n\n");
X  printf("  .edge files:\n");
X  printf("    First line:  <# of edges> <# of boundary markers (0 or 1)>\n");
X  printf(
"    Following lines:  <edge #> <endpoint> <endpoint> [boundary marker]\n");
X  printf("\n");
X  printf(
"    Endpoints are indices into the corresponding .node file.  The boundary\n"
);
X  printf("    markers are ignored by Show Me.\n\n");
X  printf(
"    In Voronoi diagrams, one also finds a special kind of edge that is an\n");
X  printf(
"    infinite ray with only one endpoint.  For these edges, a different\n");
X  printf("    format is used:\n\n");
X  printf("        <edge #> <endpoint> -1 <direction x> <direction y>\n\n");
X  printf(
"    The `direction' is a floating-point vector that indicates the direction\n"
);
X  printf("    of the infinite ray.\n\n");
X  printf("  .part files:\n");
X  printf("    First line:  <# of triangles> <# of subdomains>\n");
X  printf("    Remaining lines:  <triangle #> <subdomain #>\n\n");
X  printf(
"    The set of triangles is partitioned by a .part file; each triangle is\n");
X  printf("    mapped to a subdomain.\n\n");
X  printf("  .adj files:\n");
X  printf("    First line:  <# of subdomains>\n");
X  printf("    Remaining lines:  <adjacency matrix entry>\n\n");
X  printf(
"    An .adj file represents adjacencies between subdomains (presumably\n");
X  printf("    computed by a partitioner).  The first line is followed by\n");
X  printf(
"    (subdomains X subdomains) lines, each containing one entry of the\n");
X  printf(
"    adjacency matrix.  A nonzero entry indicates that two subdomains are\n");
X  printf("    adjacent (share a point).\n\n");
X  printf("Example:\n\n");
X  printf(
"  Here is a sample file `box.poly' describing a square with a square hole:\n"
);
X  printf("\n");
X  printf(
"    # A box with eight points in 2D, no attributes, no boundary marker.\n");
X  printf("    8 2 0 0\n");
X  printf("    # Outer box has these vertices:\n");
X  printf("     1   0 0\n");
X  printf("     2   0 3\n");
X  printf("     3   3 0\n");
X  printf("     4   3 3\n");
X  printf("    # Inner square has these vertices:\n");
X  printf("     5   1 1\n");
X  printf("     6   1 2\n");
X  printf("     7   2 1\n");
X  printf("     8   2 2\n");
X  printf("    # Five segments without boundary markers.\n");
X  printf("    5 0\n");
X  printf("     1   1 2          # Left side of outer box.\n");
X  printf("     2   5 7          # Segments 2 through 5 enclose the hole.\n");
X  printf("     3   7 8\n");
X  printf("     4   8 6\n");
X  printf("     5   6 5\n");
X  printf("    # One hole in the middle of the inner square.\n");
X  printf("    1\n");
X  printf("     1   1.5 1.5\n\n");
X  printf(
"  After this PSLG is triangulated by Triangle, the resulting triangulation\n"
);
X  printf(
"  consists of a .node and .ele file.  Here is the former, `box.1.node',\n");
X  printf("  which duplicates the points of the PSLG:\n\n");
X  printf("    8  2  0  0\n");
X  printf("       1    0  0\n");
X  printf("       2    0  3\n");
X  printf("       3    3  0\n");
X  printf("       4    3  3\n");
X  printf("       5    1  1\n");
X  printf("       6    1  2\n");
X  printf("       7    2  1\n");
X  printf("       8    2  2\n");
X  printf("    # Generated by triangle -pcBev box\n");
X  printf("\n");
X  printf("  Here is the triangulation file, `box.1.ele'.\n");
X  printf("\n");
X  printf("    8  3  0\n");
X  printf("       1       1     5     6\n");
X  printf("       2       5     1     3\n");
X  printf("       3       2     6     8\n");
X  printf("       4       6     2     1\n");
X  printf("       5       7     3     4\n");
X  printf("       6       3     7     5\n");
X  printf("       7       8     4     2\n");
X  printf("       8       4     8     7\n");
X  printf("    # Generated by triangle -pcBev box\n\n");
X  printf("  Here is the edge file for the triangulation, `box.1.edge'.\n\n");
X  printf("    16  0\n");
X  printf("       1   1  5\n");
X  printf("       2   5  6\n");
X  printf("       3   6  1\n");
X  printf("       4   1  3\n");
X  printf("       5   3  5\n");
X  printf("       6   2  6\n");
X  printf("       7   6  8\n");
X  printf("       8   8  2\n");
X  printf("       9   2  1\n");
X  printf("      10   7  3\n");
X  printf("      11   3  4\n");
X  printf("      12   4  7\n");
X  printf("      13   7  5\n");
X  printf("      14   8  4\n");
X  printf("      15   4  2\n");
X  printf("      16   8  7\n");
X  printf("    # Generated by triangle -pcBev box\n");
X  printf("\n");
X  printf(
"  Here's a file `box.1.part' that partitions the mesh into four subdomains.\n"
);
X  printf("\n");
X  printf("    8  4\n");
X  printf("       1    3\n");
X  printf("       2    3\n");
X  printf("       3    4\n");
X  printf("       4    4\n");
X  printf("       5    1\n");
X  printf("       6    1\n");
X  printf("       7    2\n");
X  printf("       8    2\n");
X  printf("    # Generated by slice -s4 box.1\n\n");
X  printf(
"  Here's a file `box.1.adj' that represents the resulting adjacencies.\n");
X  printf("\n");
X  printf("    4\n");
X  printf("      9\n");
X  printf("      2\n");
X  printf("      2\n");
X  printf("      0\n");
X  printf("      2\n");
X  printf("      9\n");
X  printf("      0\n");
X  printf("      2\n");
X  printf("      2\n");
X  printf("      0\n");
X  printf("      9\n");
X  printf("      2\n");
X  printf("      0\n");
X  printf("      2\n");
X  printf("      2\n");
X  printf("      9\n");
X  printf("\n");
X  printf("Display Speed:\n");
X  printf("\n");
X  printf(
"  It is worthwhile to note that .edge files typically plot and print twice\n"
);
X  printf(
"  as quickly as .ele files, because .ele files cause each internal edge to\n"
);
X  printf(
"  be drawn twice.  For the same reason, PostScript files created from edge\n"
);
X  printf("  sets are smaller than those created from triangulations.\n\n");
X  printf("Show Me on the Web:\n\n");
X  printf(
"  To see an illustrated, updated version of these instructions, check out\n");
X  printf("\n");
X  printf("    http://www.cs.cmu.edu/~quake/showme.html\n");
X  printf("\n");
X  printf("A Brief Plea:\n");
X  printf("\n");
X  printf(
"  If you use Show Me (or Triangle), and especially if you use it to\n");
X  printf(
"  accomplish real work, I would like very much to hear from you.  A short\n");
X  printf(
"  letter or email (to jrs@cs.cmu.edu) describing how you use Show Me (and\n");
X  printf(
"  its sister programs) will mean a lot to me.  The more people I know\n");
X  printf(
"  are using my programs, the more easily I can justify spending time on\n");
X  printf(
"  improvements, which in turn will benefit you.  Also, I can put you\n");
X  printf(
"  on a list to receive email whenever new versions are available.\n");
X  printf("\n");
X  printf(
"  If you use a PostScript file generated by Show Me in a publication,\n");
X  printf("  please include an acknowledgment as well.\n\n");
X  exit(0);
}
X
void set_filenames(filename, lowermeshnumber)
char *filename;
int lowermeshnumber;
{
X  char numberstring[100];
X  int i;
X
X  for (i = 0; i < 2; i++) {
X    strcpy(nodefilename[i], filename);
X    strcpy(polyfilename[i], filename);
X    strcpy(elefilename[i], filename);
X    strcpy(edgefilename[i], filename);
X    strcpy(partfilename[i], filename);
X    strcpy(adjfilename[i], filename);
X    strcpy(vnodefilename[i], filename);
X    strcpy(vedgefilename[i], filename);
X
X    if (lowermeshnumber + i > 0) {
X      sprintf(numberstring, ".%d", lowermeshnumber + i);
X      strcat(nodefilename[i], numberstring);
X      strcat(polyfilename[i], numberstring);
X      strcat(elefilename[i], numberstring);
X      strcat(edgefilename[i], numberstring);
X      strcat(partfilename[i], numberstring);
X      strcat(adjfilename[i], numberstring);
X      strcat(vnodefilename[i], numberstring);
X      strcat(vedgefilename[i], numberstring);
X    }
X
X    strcat(nodefilename[i], ".node");
X    strcat(polyfilename[i], ".poly");
X    strcat(elefilename[i], ".ele");
X    strcat(edgefilename[i], ".edge");
X    strcat(partfilename[i], ".part");
X    strcat(adjfilename[i], ".adj");
X    strcat(vnodefilename[i], ".v.node");
X    strcat(vedgefilename[i], ".v.edge");
X  }
}
X
void parsecommandline(argc, argv)
int argc;
char **argv;
{
X  int increment;
X  int meshnumber;
X  int i, j;
X
X  quiet = 0;
X  fillelem = 0;
X  line_width = 1;
X  bw_ps = 0;
X  start_image = ELE;
X  filename[0] = '\0';
X  for (i = 1; i < argc; i++) {
X    if (argv[i][0] == '-') {
X      for (j = 1; argv[i][j] != '\0'; j++) {
X        if (argv[i][j] == 'f') {
X          fillelem = 1;
X	}
X        if (argv[i][j] == 'w') {
X          if ((argv[i][j + 1] >= '1') && (argv[i][j + 1] <= '9')) {
X            line_width = 0;
X            while ((argv[i][j + 1] >= '0') && (argv[i][j + 1] <= '9')) {
X              j++;
X              line_width = line_width * 10 + (int) (argv[i][j] - '0');
X            }
X            if (line_width > 100) {
X              printf("Error:  Line width cannot exceed 100.\n");
X              line_width = 1;
X	    }
X	  }
X	}
X        if (argv[i][j] == 'b') {
X          bw_ps = 1;
X	}
X        if (argv[i][j] == 'Q') {
X          quiet = 1;
X	}
X        if ((argv[i][j] == 'h') || (argv[i][j] == 'H') ||
X            (argv[i][j] == '?')) {
X          info();
X	}
X      }
X    } else {
X      strcpy(filename, argv[i]);
X    }
X  }
X  if (filename[0] == '\0') {
X    syntax();
X  }
X  if (!strcmp(&filename[strlen(filename) - 5], ".node")) {
X    filename[strlen(filename) - 5] = '\0';
X    start_image = NODE;
X  }
X  if (!strcmp(&filename[strlen(filename) - 5], ".poly")) {
X    filename[strlen(filename) - 5] = '\0';
X    start_image = POLY;
X  }
X  if (!strcmp(&filename[strlen(filename) - 4], ".ele")) {
X    filename[strlen(filename) - 4] = '\0';
X    start_image = ELE;
X  }
X  if (!strcmp(&filename[strlen(filename) - 5], ".edge")) {
X    filename[strlen(filename) - 5] = '\0';
X    start_image = EDGE;
X  }
X  if (!strcmp(&filename[strlen(filename) - 5], ".part")) {
X    filename[strlen(filename) - 5] = '\0';
X    start_image = PART;
X  }
X  if (!strcmp(&filename[strlen(filename) - 4], ".adj")) {
X    filename[strlen(filename) - 4] = '\0';
X    start_image = ADJ;
X  }
X
X  increment = 0;
X  j = 1;
X  while (filename[j] != '\0') {
X    if ((filename[j] == '.') && (filename[j + 1] != '\0')) {
X      increment = j + 1;
X    }
X    j++;
X  }
X  meshnumber = 0;
X  if (increment > 0) {
X    j = increment;
X    do {
X      if ((filename[j] >= '0') && (filename[j] <= '9')) {
X        meshnumber = meshnumber * 10 + (int) (filename[j] - '0');
X      } else {
X        increment = 0;
X      }
X      j++;
X    } while (filename[j] != '\0');
X  }
X  if (increment > 0) {
X    filename[increment - 1] = '\0';
X  }
X
X  if (meshnumber == 0) {
X    start_inc = 0;
X    loweriteration = 0;
X  } else {
X    start_inc = 1;
X    loweriteration = meshnumber - 1;
X  }
X  set_filenames(filename, loweriteration);
}
X
void free_inc(inc)
int inc;
{
X  if (loaded[inc][NODE]) {
X    free(nodeptr[inc]);
X  }
X  if (loaded[inc][POLY]) {
X    if (polynodes[inc] > 0) {
X      free(polynodeptr[inc]);
X    }
X    free(polyedgeptr[inc]);
X    free(polyholeptr[inc]);
X  }
X  if (loaded[inc][ELE]) {
X    free(eleptr[inc]);
X  }
X  if (loaded[inc][PART]) {
X    free(partpart[inc]);
X    free(partcenter[inc]);
X    free(partshift[inc]);
X  }
X  if (loaded[inc][EDGE]) {
X    free(edgeptr[inc]);
X    free(normptr[inc]);
X  }
X  if (loaded[inc][ADJ]) {
X    free(adjptr[inc]);
X  }
X  if (loaded[inc][VORO]) {
X    free(vnodeptr[inc]);
X    free(vedgeptr[inc]);
X    free(vnormptr[inc]);
X  }
}
X
void move_inc(inc)
int inc;
{
X  int i;
X
X  free_inc(1 - inc);
X  for (i = 0; i < IMAGE_TYPES; i++) {
X    loaded[1 - inc][i] = loaded[inc][i];
X    loaded[inc][i] = 0;
X    xlo[1 - inc][i] = xlo[inc][i];
X    ylo[1 - inc][i] = ylo[inc][i];
X    xhi[1 - inc][i] = xhi[inc][i];
X    yhi[1 - inc][i] = yhi[inc][i];
X  }
X  nodes[1 - inc] = nodes[inc];
X  node_dim[1 - inc] = node_dim[inc];
X  nodeptr[1 - inc] = nodeptr[inc];
X  polynodes[1 - inc] = polynodes[inc];
X  poly_dim[1 - inc] = poly_dim[inc];
X  polyedges[1 - inc] = polyedges[inc];
X  polyholes[1 - inc] = polyholes[inc];
X  polynodeptr[1 - inc] = polynodeptr[inc];
X  polyedgeptr[1 - inc] = polyedgeptr[inc];
X  polyholeptr[1 - inc] = polyholeptr[inc];
X  elems[1 - inc] = elems[inc];
X  ele_corners[1 - inc] = ele_corners[inc];
X  eleptr[1 - inc] = eleptr[inc];
X  edges[1 - inc] = edges[inc];
X  edgeptr[1 - inc] = edgeptr[inc];
X  normptr[1 - inc] = normptr[inc];
X  subdomains[1 - inc] = subdomains[inc];
X  partpart[1 - inc] = partpart[inc];
X  partcenter[1 - inc] = partcenter[inc];
X  partshift[1 - inc] = partshift[inc];
X  adjsubdomains[1 - inc] = adjsubdomains[inc];
X  adjptr[1 - inc] = adjptr[inc];
X  vnodes[1 - inc] = vnodes[inc];
X  vnode_dim[1 - inc] = vnode_dim[inc];
X  vnodeptr[1 - inc] = vnodeptr[inc];
X  vedges[1 - inc] = vedges[inc];
X  vedgeptr[1 - inc] = vedgeptr[inc];
X  vnormptr[1 - inc] = vnormptr[inc];
X  firstnumber[1 - inc] = firstnumber[inc];
X  firstnumber[inc] = -1;
}
X
void unload_inc(inc)
int inc;
{
X  int i;
X
X  current_image = NOTHING;
X  for (i = 0; i < IMAGE_TYPES; i++) {
X    loaded[inc][i] = 0;
X    firstnumber[inc] = -1;
X  }
}
X
void showme_init()
{
X  current_image = NOTHING;
X  current_inc = 0;
X  explosion = STARTEXPLOSION;
X  unload_inc(0);
X  unload_inc(1);
}
X
char *readline(string, infile, infilename)
char *string;
FILE *infile;
char *infilename;
{
X  char *result;
X
X  do {
X    result = fgets(string, INPUTLINESIZE, infile);
X    if (result == (char *) NULL) {
X      printf("  Error:  Unexpected end of file in %s.\n",
X             infilename);
X      exit(1);
X    }
X    while ((*result != '\0') && (*result != '#')
X           && (*result != '.') && (*result != '+') && (*result != '-')
X           && ((*result < '0') || (*result > '9'))) {
X      result++;
X    }
X  } while ((*result == '#') || (*result == '\0'));
X  return result;
}
X
char *findfield(string)
char *string;
{
X  char *result;
X
X  result = string;
X  while ((*result != '\0') && (*result != '#')
X         && (*result != ' ') && (*result != '\t')) {
X    result++;
X  }
X  while ((*result != '\0') && (*result != '#')
X         && (*result != '.') && (*result != '+') && (*result != '-')
X         && ((*result < '0') || (*result > '9'))) {
X    result++;
X  }
X  if (*result == '#') {
X    *result = '\0';
X  }
X  return result;
}
X
int load_node(fname, firstnumber, nodes, dim, ptr, xmin, ymin, xmax, ymax)
char *fname;
int *firstnumber;
int *nodes;
int *dim;
REAL **ptr;
REAL *xmin;
REAL *ymin;
REAL *xmax;
REAL *ymax;
{
X  FILE *infile;
X  char inputline[INPUTLINESIZE];
X  char *stringptr;
X  int extras;
X  int nodemarks;
X  int index;
X  int nodenumber;
X  int i, j;
X  int smallerr;
X  REAL x, y;
X
X  *xmin = *ymin = 0.0;
X  *xmax = *ymax = 1.0;
X  if (!quiet) {
X    printf("Opening %s.\n", fname);
X  }
X  infile = fopen(fname, "r");
X  if (infile == (FILE *) NULL) {
X    printf("  Error:  Cannot access file %s.\n", fname);
X    return 1;
X  }
X  stringptr = readline(inputline, infile, fname);
X  *nodes = (int) strtol (stringptr, &stringptr, 0);
X  if (*nodes < 3) {
X    printf("  Error:  %s contains %d points.\n", fname, *nodes);
X    return 1;
X  }
X  stringptr = findfield(stringptr);
X  if (*stringptr == '\0') {
X    *dim = 2;
X  } else {
X    *dim = (int) strtol (stringptr, &stringptr, 0);
X  }
X  if (*dim < 1) {
X    printf("  Error:  %s has dimensionality %d.\n", fname, *dim);
X    return 1;
X  }
X  if (*dim != 2) {
X    printf("  I only understand two-dimensional meshes.\n");
X    return 1;
X  }
X  stringptr = findfield(stringptr);
X  if (*stringptr == '\0') {
X    extras = 0;
X  } else {
X    extras = (int) strtol (stringptr, &stringptr, 0);
X  }
X  if (extras < 0) {
X    printf("  Error:  %s has negative value for number of attributes.\n",
X           fname);
X    return 1;
X  }
X  stringptr = findfield(stringptr);
X  if (*stringptr == '\0') {
X    nodemarks = 0;
X  } else {
X    nodemarks = (int) strtol (stringptr, &stringptr, 0);
X  }
X  if (nodemarks < 0) {
X    printf("  Warning:  %s has negative value for number of point markers.\n",
X           fname);
X  }
X  if (nodemarks > 1) {
X    printf(
X   "  Warning:  %s has value greater than one for number of point markers.\n",
X           fname);
X  }
X  *ptr = (REAL *) malloc((*nodes + 1) * *dim * sizeof(REAL));
X  if (*ptr == (REAL *) NULL) {
X    printf("  Out of memory.\n");
X    return 1;
X  }
X  index = *dim;
X  smallerr = 1;
X  for (i = 0; i < *nodes; i++) {
X    stringptr = readline(inputline, infile, fname);
X    nodenumber = (int) strtol (stringptr, &stringptr, 0);
X    if ((i == 0) && (*firstnumber == -1)) {
X      if (nodenumber == 0) {
X        *firstnumber = 0;
X      } else {
X        *firstnumber = 1;
X      }
X    }
X    if ((nodenumber != *firstnumber + i) && (smallerr)) {
X      printf("  Warning:  Points in %s are not numbered correctly\n", fname);
X      printf("            (starting with point %d).\n", *firstnumber + i);
X      smallerr = 0;
X    }
X    for (j = 0; j < *dim; j++) {
X      stringptr = findfield(stringptr);
X      if (*stringptr == '\0') {
X        printf("Error:  Point %d is missing a coordinate in %s.\n",
X               *firstnumber + i, fname);
X        free(*ptr);
X        return 1;
X      }
X      (*ptr)[index++] = (REAL) strtod(stringptr, &stringptr);
X    }
X  }
X  fclose(infile);
X  index = *dim;
X  *xmin = *xmax = (*ptr)[index];
X  *ymin = *ymax = (*ptr)[index + 1];
X  for (i = 2; i <= *nodes; i++) {
X    index += *dim;
X    x = (*ptr)[index];
X    y = (*ptr)[index + 1];
X    if (x < *xmin) {
X      *xmin = x;
X    }
X    if (y < *ymin) {
X      *ymin = y;
X    }
X    if (x > *xmax) {
X      *xmax = x;
X    }
X    if (y > *ymax) {
X      *ymax = y;
X    }
X  }
X  if (*xmin == *xmax) {
X    *xmin -= 0.5;
X    *xmax += 0.5;
X  }
X  if (*ymin == *ymax) {
X    *ymin -= 0.5;
X    *ymax += 0.5;
X  }
X  return 0;
}
X
int load_poly(inc, fname, firstnumber, pnodes, dim, edges, holes, nodeptr,
X              edgeptr, holeptr, xmin, ymin, xmax, ymax)
int inc;
char *fname;
int *firstnumber;
int *pnodes;
int *dim;
int *edges;
int *holes;
REAL **nodeptr;
int **edgeptr;
REAL **holeptr;
REAL *xmin;
REAL *ymin;
REAL *xmax;
REAL *ymax;
{
X  FILE *infile;
X  char inputline[INPUTLINESIZE];
X  char *stringptr;
X  int extras;
X  int nodemarks;
X  int segmentmarks;
X  int index;
X  int nodenumber, edgenumber, holenumber;
X  int maxnode;
X  int i, j;
X  int smallerr;
X  REAL x, y;
X
X  if (!quiet) {
X    printf("Opening %s.\n", fname);
X  }
X  infile = fopen(fname, "r");
X  if (infile == (FILE *) NULL) {
X    printf("  Error:  Cannot access file %s.\n", fname);
X    return 1;
X  }
X  stringptr = readline(inputline, infile, fname);
X  *pnodes = (int) strtol (stringptr, &stringptr, 0);
X  if (*pnodes == 0) {
X    if (!loaded[inc][NODE]) {
X      if (load_image(inc, NODE)) {
X        return 1;
X      }
X    }
X    maxnode = nodes[inc];
X    *xmin = xlo[inc][NODE];
X    *ymin = ylo[inc][NODE];
X    *xmax = xhi[inc][NODE];
X    *ymax = yhi[inc][NODE];
X  } else {
X    if (*pnodes < 1) {
X      printf("  Error:  %s contains %d points.\n", fname, *pnodes);
X      return 1;
X    }
X    maxnode = *pnodes;
X  }
X  stringptr = findfield(stringptr);
X  if (*stringptr == '\0') {
X    *dim = 2;
X  } else {
X    *dim = (int) strtol (stringptr, &stringptr, 0);
X  }
X  if (*dim < 1) {
X    printf("  Error:  %s has dimensionality %d.\n", fname, *dim);
X    return 1;
X  }
X  if (*dim != 2) {
X    printf("  I only understand two-dimensional .poly files.\n");
X    return 1;
X  }
X  stringptr = findfield(stringptr);
X  if (*stringptr == '\0') {
X    extras = 0;
X  } else {
X    extras = (int) strtol (stringptr, &stringptr, 0);
X  }
X  if (extras < 0) {
X    printf("  Error:  %s has negative value for number of attributes.\n",
X           fname);
X    return 1;
X  }
X  stringptr = findfield(stringptr);
X  if (*stringptr == '\0') {
X    nodemarks = 0;
X  } else {
X    nodemarks = (int) strtol (stringptr, &stringptr, 0);
X  }
X  if (nodemarks < 0) {
X    printf("  Warning:  %s has negative value for number of point markers.\n",
X           fname);
X  }
X  if (nodemarks > 1) {
X    printf(
X   "  Warning:  %s has value greater than one for number of point markers.\n",
X           fname);
X  }
X  if (*pnodes > 0) {
X    *nodeptr = (REAL *) malloc((*pnodes + 1) * *dim * sizeof(REAL));
X    if (*nodeptr == (REAL *) NULL) {
X      printf("  Out of memory.\n");
X      return 1;
X    }
X    index = *dim;
X    smallerr = 1;
X    for (i = 0; i < *pnodes; i++) {
X      stringptr = readline(inputline, infile, fname);
X      nodenumber = (int) strtol (stringptr, &stringptr, 0);
X      if ((i == 0) && (*firstnumber == -1)) {
X        if (nodenumber == 0) {
X          *firstnumber = 0;
X        } else {
X          *firstnumber = 1;
X        }
X      }
X      if ((nodenumber != *firstnumber + i) && (smallerr)) {
X        printf("  Warning:  Points in %s are not numbered correctly.\n",
X               fname);
X        printf("            (starting with point %d).\n", *firstnumber + i);
X        smallerr = 0;
X      }
X      for (j = 0; j < *dim; j++) {
X        stringptr = findfield(stringptr);
X        if (*stringptr == '\0') {
X          printf("Error:  Point %d is missing a coordinate in %s.\n",
X                 *firstnumber + i, fname);
X          free(*nodeptr);
X          return 1;
X        }
X        (*nodeptr)[index++] = (REAL) strtod(stringptr, &stringptr);
X      }
X    }
X  }
X  stringptr = readline(inputline, infile, fname);
X  *edges = (int) strtol (stringptr, &stringptr, 0);
X  if (*edges < 0) {
X    printf("  Error:  %s contains %d segments.\n", fname, *edges);
X    free(*nodeptr);
X    return 1;
X  }
X  stringptr = findfield(stringptr);
X  if (*stringptr == '\0') {
X    segmentmarks = 0;
X  } else {
X    segmentmarks = (int) strtol (stringptr, &stringptr, 0);
X  }
X  if (segmentmarks < 0) {
X    printf("  Error:  %s has negative value for number of segment markers.\n",
X           fname);
X    free(*nodeptr);
X    return 1;
X  }
X  if (segmentmarks > 1) {
X    printf(
X   "  Error:  %s has value greater than one for number of segment markers.\n",
X           fname);
X    free(*nodeptr);
X    return 1;
X  }
X  *edgeptr = (int *) malloc(((*edges + 1) << 1) * sizeof(int));
X  if (*edgeptr == (int *) NULL) {
X    printf("  Out of memory.\n");
X    free(*nodeptr);
X    return 1;
X  }
X  index = 2;
X  smallerr = 1;
X  for (i = *firstnumber; i < *firstnumber + *edges; i++) {
X    stringptr = readline(inputline, infile, fname);
X    edgenumber = (int) strtol (stringptr, &stringptr, 0);
X    if ((edgenumber != i) && (smallerr)) {
X      printf("  Warning:  Segments in %s are not numbered correctly.\n",
X             fname);
X      printf("            (starting with segment %d).\n", i);
X      smallerr = 0;
X    }
X    stringptr = findfield(stringptr);
X    if (*stringptr == '\0') {
X      printf("Error:  Segment %d is missing its endpoints in %s.\n", i, fname);
X      free(*nodeptr);
X      free(*edgeptr);
X      return 1;
X    }
X    (*edgeptr)[index] = (int) strtol (stringptr, &stringptr, 0) + 1 -
X                        *firstnumber;
X    if (((*edgeptr)[index] < 1) || ((*edgeptr)[index] > maxnode)) {
X      printf("Error:  Segment %d has invalid endpoint in %s.\n", i, fname);
X      return 1;
X    }
X    stringptr = findfield(stringptr);
X    if (*stringptr == '\0') {
X      printf("Error:  Segment %d is missing an endpoint in %s.\n", i, fname);
X      free(*nodeptr);
X      free(*edgeptr);
X      return 1;
X    }
X    (*edgeptr)[index + 1] = (int) strtol (stringptr, &stringptr, 0) + 1 -
X                            *firstnumber;
X    if (((*edgeptr)[index + 1] < 1) || ((*edgeptr)[index + 1] > maxnode)) {
X      printf("Error:  Segment %d has invalid endpoint in %s.\n", i, fname);
X      return 1;
X    }
X    index += 2;
X  }
X  stringptr = readline(inputline, infile, fname);
X  *holes = (int) strtol (stringptr, &stringptr, 0);
X  if (*holes < 0) {
X    printf("  Error:  %s contains %d holes.\n", fname, *holes);
X    free(*nodeptr);
X    free(*edgeptr);
X    return 1;
X  }
X  *holeptr = (REAL *) malloc((*holes + 1) * *dim * sizeof(REAL));
X  if (*holeptr == (REAL *) NULL) {
X    printf("  Out of memory.\n");
X    free(*nodeptr);
X    free(*edgeptr);
X    return 1;
X  }
X  index = *dim;
X  smallerr = 1;
X  for (i = *firstnumber; i < *firstnumber + *holes; i++) {
X    stringptr = readline(inputline, infile, fname);
X    holenumber = (int) strtol (stringptr, &stringptr, 0);
X    if ((holenumber != i) && (smallerr)) {
X      printf("  Warning:  Holes in %s are not numbered correctly.\n", fname);
X      printf("            (starting with hole %d).\n", i);
X      smallerr = 0;
X    }
X    for (j = 0; j < *dim; j++) {
X      stringptr = findfield(stringptr);
X      if (*stringptr == '\0') {
X        printf("Error:  Hole %d is missing a coordinate in %s.\n", i,
X               fname);
X        free(*nodeptr);
X        free(*edgeptr);
X        free(*holeptr);
X        return 1;
X      }
X      (*holeptr)[index++] = (REAL) strtod(stringptr, &stringptr);
X    }
X  }
X  fclose(infile);
X  if (*pnodes > 0) {
X    index = *dim;
X    *xmin = *xmax = (*nodeptr)[index];
X    *ymin = *ymax = (*nodeptr)[index + 1];
X    for (i = 2; i <= *pnodes; i++) {
X      index += *dim;
X      x = (*nodeptr)[index];
X      y = (*nodeptr)[index + 1];
X      if (x < *xmin) {
X        *xmin = x;
X      }
X      if (y < *ymin) {
X        *ymin = y;
X      }
X      if (x > *xmax) {
X        *xmax = x;
X      }
X      if (y > *ymax) {
X        *ymax = y;
X      }
X    }
X  }
X  index = *dim;
X  for (i = 1; i <= *holes; i++) {
X    x = (*holeptr)[index];
X    y = (*holeptr)[index + 1];
X    if (x < *xmin) {
X      *xmin = x;
X    }
X    if (y < *ymin) {
X      *ymin = y;
X    }
X    if (x > *xmax) {
X      *xmax = x;
X    }
X    if (y > *ymax) {
X      *ymax = y;
X    }
X    index += *dim;
X  }
X  return 0;
}
X
int load_ele(fname, firstnumber, nodes, elems, corners, ptr)
char *fname;
int firstnumber;
int nodes;
int *elems;
int *corners;
int **ptr;
{
X  FILE *infile;
X  char inputline[INPUTLINESIZE];
X  char *stringptr;
X  int extras;
X  int index;
X  int elemnumber;
X  int i, j;
X  int smallerr;
X
X  if (!quiet) {
X    printf("Opening %s.\n", fname);
X  }
X  infile = fopen(fname, "r");
X  if (infile == (FILE *) NULL) {
X    printf("  Error:  Cannot access file %s.\n", fname);
X    return 1;
X  }
X  stringptr = readline(inputline, infile, fname);
X  *elems = (int) strtol (stringptr, &stringptr, 0);
X  if (*elems < 1) {
X    printf("  Error:  %s contains %d triangles.\n", fname, *elems);
X    return 1;
X  }
X  stringptr = findfield(stringptr);
X  if (*stringptr == '\0') {
X    *corners = 3;
X  } else {
X    *corners = (int) strtol (stringptr, &stringptr, 0);
X  }
X  if (*corners < 3) {
X    printf("  Error:  Triangles in %s have only %d corners.\n", fname,
X           *corners);
X    return 1;
X  }
X  stringptr = findfield(stringptr);
X  if (*stringptr == '\0') {
X    extras = 0;
X  } else {
X    extras = (int) strtol (stringptr, &stringptr, 0);
X  }
X  if (extras < 0) {
X    printf("  Error:  %s has negative value for extra fields.\n", fname);
X    return 1;
X  }
X  *ptr = (int *) malloc((*elems + 1) * 3 * sizeof(int));
X  if (*ptr == (int *) NULL) {
X    printf("  Out of memory.\n");
X    return 1;
X  }
X  index = 3;
X  smallerr = 1;
X  for (i = firstnumber; i < firstnumber + *elems; i++) {
X    stringptr = readline(inputline, infile, fname);
X    elemnumber = (int) strtol (stringptr, &stringptr, 0);
X    if ((elemnumber != i) && (smallerr)) {
X      printf("  Warning:  Triangles in %s are not numbered correctly.\n",
X             fname);
X      printf("            (starting with triangle %d).\n", i);
X      smallerr = 0;
X    }
X    for (j = 0; j < 3; j++) {
X      stringptr = findfield(stringptr);
X      if (*stringptr == '\0') {
X        printf("Error:  Triangle %d is missing a corner in %s.\n", i, fname);
X        free(*ptr);
X        return 1;
X      }
X      (*ptr)[index] = (int) strtol (stringptr, &stringptr, 0) + 1 -
X                      firstnumber;
X      if (((*ptr)[index] < 1) || ((*ptr)[index] > nodes)) {
X        printf("Error:  Triangle %d has invalid corner in %s.\n", i, fname);
X        return 1;
X      }
X      index++;
X    }
X  }
X  fclose(infile);
X  return 0;
}
X
int load_edge(fname, firstnumber, nodes, edges, edgeptr, normptr)
char *fname;
int firstnumber;
int nodes;
int *edges;
int **edgeptr;
REAL **normptr;
{
X  FILE *infile;
X  char inputline[INPUTLINESIZE];
X  char *stringptr;
X  int index;
X  int edgenumber;
X  int edgemarks;
X  int i;
X  int smallerr;
X
X  if (!quiet) {
X    printf("Opening %s.\n", fname);
X  }
X  infile = fopen(fname, "r");
X    if (infile == (FILE *) NULL) {
X      printf("  Error:  Cannot access file %s.\n", fname);
X      return 1;
X    }
X  stringptr = readline(inputline, infile, fname);
X  *edges = (int) strtol (stringptr, &stringptr, 0);
X  if (*edges < 1) {
X    printf("  Error:  %s contains %d edges.\n", fname, *edges);
X    return 1;
X  }
X  stringptr = findfield(stringptr);
X  if (*stringptr == '\0') {
X    edgemarks = 0;
X  } else {
X    edgemarks = (int) strtol (stringptr, &stringptr, 0);
X  }
X  if (edgemarks < 0) {
X    printf("  Error:  %s has negative value for number of edge markers.\n",
X           fname);
X    return 1;
X  }
X  if (edgemarks > 1) {
X    printf(
X   "  Error:  %s has value greater than one for number of edge markers.\n",
X           fname);
X    return 1;
X  }
X  *edgeptr = (int *) malloc(((*edges + 1) << 1) * sizeof(int));
X  if (*edgeptr == (int *) NULL) {
X    printf("  Out of memory.\n");
X    return 1;
X  }
X  *normptr = (REAL *) malloc(((*edges + 1) << 1) * sizeof(REAL));
X  if (*normptr == (REAL *) NULL) {
X    printf("  Out of memory.\n");
X    free(*edgeptr);
X    return 1;
X  }
X  index = 2;
X  smallerr = 1;
X  for (i = firstnumber; i < firstnumber + *edges; i++) {
X    stringptr = readline(inputline, infile, fname);
X    edgenumber = (int) strtol (stringptr, &stringptr, 0);
X    if ((edgenumber != i) && (smallerr)) {
X      printf("  Warning:  Edges in %s are not numbered correctly.\n", fname);
X      printf("            (starting with edge %d).\n", i);
X      smallerr = 0;
X    }
X    stringptr = findfield(stringptr);
X    if (*stringptr == '\0') {
X      printf("Error:  Edge %d is missing its endpoints in %s.\n", i, fname);
X      free(*edgeptr);
X      free(*normptr);
X      return 1;
X    }
X    (*edgeptr)[index] = (int) strtol (stringptr, &stringptr, 0) + 1 -
X                        firstnumber;
X    if (((*edgeptr)[index] < 1) || ((*edgeptr)[index] > nodes)) {
X      printf("Error:  Edge %d has invalid endpoint in %s.\n", i, fname);
X      return 1;
X    }
X    stringptr = findfield(stringptr);
X    if (*stringptr == '\0') {
X      printf("Error:  Edge %d is missing an endpoint in %s.\n", i, fname);
X      free(*edgeptr);
X      free(*normptr);
X      return 1;
X    }
X    (*edgeptr)[index + 1] = (int) strtol (stringptr, &stringptr, 0);
X    if ((*edgeptr)[index + 1] == -1) {
X      stringptr = findfield(stringptr);
X      if (*stringptr == '\0') {
X        printf("Error:  Edge %d is missing its direction in %s.\n", i, fname);
X        free(*edgeptr);
X        free(*normptr);
X        return 1;
X      }
X      (*normptr)[index] = (REAL) strtod(stringptr, &stringptr);
X      stringptr = findfield(stringptr);
X      if (*stringptr == '\0') {
X        printf("Error:  Edge %d is missing a direction coordinate in %s.\n",
X               i, fname);
X        free(*edgeptr);
X        free(*normptr);
X        return 1;
X      }
X      (*normptr)[index + 1] = (REAL) strtod(stringptr, &stringptr);
X    } else {
X      (*edgeptr)[index + 1] += 1 - firstnumber;
X      if (((*edgeptr)[index + 1] < 1) || ((*edgeptr)[index + 1] > nodes)) {
X        printf("Error:  Edge %d has invalid endpoint in %s.\n", i, fname);
X        return 1;
X      }
X    }
X    index += 2;
X  }
X  fclose(infile);
X  return 0;
}
X
int load_part(fname, dim, firstnumber, elems, nodeptr, eleptr, parts,
X              partition, partcenter, partshift)
char *fname;
int dim;
int firstnumber;
int elems;
REAL *nodeptr;
int *eleptr;
int *parts;
int **partition;
REAL **partcenter;
REAL **partshift;
{
X  FILE *infile;
X  char inputline[INPUTLINESIZE];
X  char *stringptr;
X  int partelems;
X  int index;
X  int elemnumber;
X  int i, j;
X  int smallerr;
X  int *partsize;
X
X  if (!quiet) {
X    printf("Opening %s.\n", fname);
X  }
X  infile = fopen(fname, "r");
X  if (infile == (FILE *) NULL) {
X    printf("  Error:  Cannot access file %s.\n", fname);
X    return 1;
X  }
X  stringptr = readline(inputline, infile, fname);
X  partelems = (int) strtol (stringptr, &stringptr, 0);
X  if (partelems != elems) {
X    printf(
X      "  Error:  .ele and .part files do not agree on number of triangles.\n");
X    return 1;
X  }
X  stringptr = findfield(stringptr);
X  if (*stringptr == '\0') {
X    *parts = 1;
X  } else {
X    *parts = (int) strtol (stringptr, &stringptr, 0);
X  }
X  if (*parts < 1) {
X    printf("  Error:  %s specifies %d subdomains.\n", fname, *parts);
X    return 1;
X  }
X  *partition = (int *) malloc((elems + 1) * sizeof(int));
X  if (*partition == (int *) NULL) {
X    printf("  Out of memory.\n");
X    return 1;
X  }
X  smallerr = 1;
X  for (i = firstnumber; i < firstnumber + partelems; i++) {
X    stringptr = readline(inputline, infile, fname);
X    elemnumber = (int) strtol (stringptr, &stringptr, 0);
X    if ((elemnumber != i) && (smallerr)) {
X      printf("  Warning:  Triangles in %s are not numbered correctly.\n",
X             fname);
X      printf("            (starting with triangle %d).\n", i);
X      smallerr = 0;
X    }
X    stringptr = findfield(stringptr);
X    if (*stringptr == '\0') {
X      printf("Error:  Triangle %d has no subdomain in %s.\n", i, fname);
X      free(*partition);
X      return 1;
X    }
X    j = i + 1 - firstnumber;
X    (*partition)[j] = (int) strtol (stringptr, &stringptr, 0) - firstnumber;
X    if (((*partition)[j] >= *parts) || ((*partition)[j] < 0)) {
X      printf("  Error:  Triangle %d of %s has an invalid subdomain.\n",
X             i, fname);
X      free(*partition);
X      return 1;
X    }
X  }
X  fclose(infile);
X  *partcenter = (REAL *) malloc(((*parts + 1) << 1) * sizeof(REAL));
X  if (*partcenter == (REAL *) NULL) {
X    printf("Error:  Out of memory.\n");
X    free(*partition);
X    return 1;
X  }
X  *partshift = (REAL *) malloc((*parts << 1) * sizeof(REAL));
X  if (*partshift == (REAL *) NULL) {
X    printf("Error:  Out of memory.\n");
X    free(*partition);
X    free(*partcenter);
X    return 1;
X  }
X  partsize = (int *) malloc((*parts + 1) * sizeof(int));
X  if (partsize == (int *) NULL) {
X    printf("Error:  Out of memory.\n");
X    free(*partition);
X    free(*partcenter);
X    free(*partshift);
X    return 1;
X  }
X  for (i = 0; i <= *parts; i++) {
X    partsize[i] = 0;
X    (*partcenter)[i << 1] = 0.0;
X    (*partcenter)[(i << 1) + 1] = 0.0;
X  }
X  index = 3;
X  for (i = 1; i <= elems; i++) {
X    partsize[(*partition)[i]] += 3;
X    for (j = 0; j < 3; j++) {
X      (*partcenter)[(*partition)[i] << 1] +=
X                nodeptr[eleptr[index] * dim];
X      (*partcenter)[((*partition)[i] << 1) + 1] +=
X                nodeptr[eleptr[index++] * dim + 1];
X    }
X  }
X  for (i = 0; i < *parts; i++) {
X    (*partcenter)[i << 1] /= (REAL) partsize[i];
X    (*partcenter)[(i << 1) + 1] /= (REAL) partsize[i];
X    (*partcenter)[*parts << 1] += (*partcenter)[i << 1];
X    (*partcenter)[(*parts << 1) + 1] += (*partcenter)[(i << 1) + 1];
X  }
X  (*partcenter)[*parts << 1] /= (REAL) *parts;
X  (*partcenter)[(*parts << 1) + 1] /= (REAL) *parts;
X  free(partsize);
X  return 0;
}
X
int load_adj(fname, subdomains, ptr)
char *fname;
int *subdomains;
int **ptr;
{
X  FILE *infile;
X  char inputline[INPUTLINESIZE];
X  char *stringptr;
X  int i, j;
X
X  if (!quiet) {
X    printf("Opening %s.\n", fname);
X  }
X  infile = fopen(fname, "r");
X  if (infile == (FILE *) NULL) {
X    printf("  Error:  Cannot access file %s.\n", fname);
X    return 1;
X  }
X  stringptr = readline(inputline, infile, fname);
X  *subdomains = (int) strtol (stringptr, &stringptr, 0);
X  if (*subdomains < 1) {
X    printf("  Error:  %s contains %d subdomains.\n", fname, *subdomains);
X    return 1;
X  }
X  *ptr = (int *) malloc(*subdomains * *subdomains * sizeof(int));
X  if (*ptr == (int *) NULL) {
X    printf("  Out of memory.\n");
X    return 1;
X  }
X  for (i = 0; i < *subdomains; i++) {
X    for (j = 0; j < *subdomains; j++) {
X      stringptr = readline(inputline, infile, fname);
X      (*ptr)[i * *subdomains + j] = (int) strtol (stringptr, &stringptr, 0);
X    }
X  }
X  return 0;
}
X
void findpartshift(parts, explosion, partcenter, partshift)
int parts;
REAL explosion;
REAL *partcenter;
REAL *partshift;
{
X  int i;
X
X  for (i = 0; i < parts; i++) {
X    partshift[i << 1] = explosion *
X          (partcenter[i << 1] - partcenter[parts << 1]);
X    partshift[(i << 1) + 1] = explosion *
X          (partcenter[(i << 1) + 1] - partcenter[(parts << 1) + 1]);
X  }
}
X
int load_image(inc, image)
int inc;
int image;
{
X  int error;
X
X  switch (image) {
X    case NODE:
X      error = load_node(nodefilename[inc], &firstnumber[inc], &nodes[inc],
X                        &node_dim[inc], &nodeptr[inc], &xlo[inc][NODE],
X                        &ylo[inc][NODE], &xhi[inc][NODE], &yhi[inc][NODE]);
X      break;
X    case POLY:
X      error = load_poly(inc, polyfilename[inc], &firstnumber[inc],
X                        &polynodes[inc], &poly_dim[inc], &polyedges[inc],
X                        &polyholes[inc], &polynodeptr[inc], &polyedgeptr[inc],
X                        &polyholeptr[inc],
X                        &xlo[inc][POLY], &ylo[inc][POLY],
X                        &xhi[inc][POLY], &yhi[inc][POLY]);
X      break;
X    case ELE:
X      error = load_ele(elefilename[inc], firstnumber[inc], nodes[inc],
X                       &elems[inc], &ele_corners[inc], &eleptr[inc]);
X      xlo[inc][ELE] = xlo[inc][NODE];
X      ylo[inc][ELE] = ylo[inc][NODE];
X      xhi[inc][ELE] = xhi[inc][NODE];
X      yhi[inc][ELE] = yhi[inc][NODE];
X      break;
X    case EDGE:
X      error = load_edge(edgefilename[inc], firstnumber[inc], nodes[inc],
X                        &edges[inc], &edgeptr[inc], &normptr[inc]);
X      xlo[inc][EDGE] = xlo[inc][NODE];
X      ylo[inc][EDGE] = ylo[inc][NODE];
X      xhi[inc][EDGE] = xhi[inc][NODE];
X      yhi[inc][EDGE] = yhi[inc][NODE];
X      break;
X    case PART:
X      error = load_part(partfilename[inc], node_dim[inc], firstnumber[inc],
X                        elems[inc], nodeptr[inc], eleptr[inc],
X                        &subdomains[inc], &partpart[inc], &partcenter[inc],
X                        &partshift[inc]);
X      if (!error) {
X        findpartshift(subdomains[inc], explosion, partcenter[inc],
X                      partshift[inc]);
X      }
X      xlo[inc][PART] = xlo[inc][NODE];
X      ylo[inc][PART] = ylo[inc][NODE];
X      xhi[inc][PART] = xhi[inc][NODE];
X      yhi[inc][PART] = yhi[inc][NODE];
X      break;
X    case ADJ:
X      error = load_adj(adjfilename[inc], &adjsubdomains[inc], &adjptr[inc]);
X      xlo[inc][ADJ] = xlo[inc][NODE];
X      ylo[inc][ADJ] = ylo[inc][NODE];
X      xhi[inc][ADJ] = xhi[inc][NODE];
X      yhi[inc][ADJ] = yhi[inc][NODE];
X      break;
X    case VORO:
X      error = load_node(vnodefilename[inc], &firstnumber[inc], &vnodes[inc],
X                        &vnode_dim[inc], &vnodeptr[inc], &xlo[inc][VORO],
X                        &ylo[inc][VORO], &xhi[inc][VORO], &yhi[inc][VORO]);
X      if (!error) {
X        error = load_edge(vedgefilename[inc], firstnumber[inc], vnodes[inc],
X                          &vedges[inc], &vedgeptr[inc], &vnormptr[inc]);
X      }
X      break;
X    default:
X      error = 1;
X  }
X  if (!error) {
X    loaded[inc][image] = 1;
X  }
X  return error;
}
X
void choose_image(inc, image)
int inc;
int image;
{
X  if (!loaded[inc][image]) {
X    if ((image == ELE) || (image == EDGE) || (image == PART)
X        || (image == ADJ)) {
X      if (!loaded[inc][NODE]) {
X        if (load_image(inc, NODE)) {
X          return;
X        }
X      }
X    }
X    if ((image == PART) || (image == ADJ)) {
X      if (!loaded[inc][ELE]) {
X        if (load_image(inc, ELE)) {
X          return;
X        }
X      }
X    }
X    if (image == ADJ) {
X      if (!loaded[inc][PART]) {
X        if (load_image(inc, PART)) {
X          return;
X        }
X      }
X    }
X    if (load_image(inc, image)) {
X      return;
X    }
X  }
X  current_inc = inc;
X  current_image = image;
}
X
Window make_button(name, x, y, width)
char *name;
int x;
int y;
int width;
{
X  XSetWindowAttributes attr;
X  XSizeHints hints;
X  Window button;
X
X  attr.background_pixel = black;
X  attr.border_pixel = white;
X  attr.backing_store = NotUseful;
X  attr.event_mask = ExposureMask | ButtonReleaseMask | ButtonPressMask;
X  attr.bit_gravity = SouthWestGravity;
X  attr.win_gravity = SouthWestGravity;
X  attr.save_under = False;
X  button = XCreateWindow(display, mainwindow, x, y, width, BUTTONHEIGHT - 4,
X                         2, 0, InputOutput, CopyFromParent,
X                         CWBackPixel | CWBorderPixel | CWEventMask |
X                         CWBitGravity | CWWinGravity | CWBackingStore |
X                         CWSaveUnder, &attr);
X  hints.width = width;
X  hints.height = BUTTONHEIGHT - 4;
X  hints.min_width = 0;
X  hints.min_height = BUTTONHEIGHT - 4;
X  hints.max_width = width;
X  hints.max_height = BUTTONHEIGHT - 4;
X  hints.width_inc = 1;
X  hints.height_inc = 1;
X  hints.flags = PMinSize | PMaxSize | PSize | PResizeInc;
X  XSetStandardProperties(display, button, name, "showme", None, (char **) NULL,
X                         0, &hints);
X  return button;
}
X
void make_buttons(y)
int y;
{
X  int i;
X
X  for (i = 1; i >= 0; i--) {
X    nodewin[i] = make_button("node", 0, y + (1 - i) * BUTTONHEIGHT, 42);
X    XMapWindow(display, nodewin[i]);
X    polywin[i] = make_button("poly", 44, y + (1 - i) * BUTTONHEIGHT, 42);
X    XMapWindow(display, polywin[i]);
X    elewin[i] = make_button("ele", 88, y + (1 - i) * BUTTONHEIGHT, 33);
X    XMapWindow(display, elewin[i]);
X    edgewin[i] = make_button("edge", 123, y + (1 - i) * BUTTONHEIGHT, 42);
X    XMapWindow(display, edgewin[i]);
X    partwin[i] = make_button("part", 167, y + (1 - i) * BUTTONHEIGHT, 42);
X    XMapWindow(display, partwin[i]);
X    adjwin[i] = make_button("adj", 211, y + (1 - i) * BUTTONHEIGHT, 33);
X    XMapWindow(display, adjwin[i]);
X    voronoiwin[i] = make_button("voro", 246, y + (1 - i) * BUTTONHEIGHT, 42);
X    XMapWindow(display, voronoiwin[i]);
X  }
X  versionpluswin = make_button("    +", 290, y, 52);
X  XMapWindow(display, versionpluswin);
X  versionminuswin = make_button("    -", 290, y + BUTTONHEIGHT, 52);
X  XMapWindow(display, versionminuswin);
X
X  quitwin = make_button("Quit", 0, y + 2 * BUTTONHEIGHT, 42);
X  XMapWindow(display, quitwin);
X  leftwin = make_button("<", 44, y + 2 * BUTTONHEIGHT, 14);
X  XMapWindow(display, leftwin);
X  rightwin = make_button(">", 60, y + 2 * BUTTONHEIGHT, 14);
X  XMapWindow(display, rightwin);
X  upwin = make_button("^", 76, y + 2 * BUTTONHEIGHT, 14);
X  XMapWindow(display, upwin);
X  downwin = make_button("v", 92, y + 2 * BUTTONHEIGHT, 14);
X  XMapWindow(display, downwin);
X  resetwin = make_button("Reset", 108, y + 2 * BUTTONHEIGHT, 52);
X  XMapWindow(display, resetwin);
X  widthpluswin = make_button("Width+", 162, y + 2 * BUTTONHEIGHT, 61);
X  XMapWindow(display, widthpluswin);
X  widthminuswin = make_button("-", 225, y + 2 * BUTTONHEIGHT, 14);
X  XMapWindow(display, widthminuswin);
X  expwin = make_button("Exp", 241, y + 2 * BUTTONHEIGHT, 33);
X  XMapWindow(display, expwin);
X  exppluswin = make_button("+", 276, y + 2 * BUTTONHEIGHT, 14);
X  XMapWindow(display, exppluswin);
X  expminuswin = make_button("-", 292, y + 2 * BUTTONHEIGHT, 14);
X  XMapWindow(display, expminuswin);
X  fillwin = make_button("Fill", 308, y + 2 * BUTTONHEIGHT, 41);
X  XMapWindow(display, fillwin);
X  pswin = make_button("PS", 351, y + 2 * BUTTONHEIGHT, 24);
X  XMapWindow(display, pswin);
X  epswin = make_button("EPS", 377, y + 2 * BUTTONHEIGHT, 33);
X  XMapWindow(display, epswin);
}
X
void fill_button(button)
Window button;
{
X  int x, y;
X  unsigned int w, h, d, b;
X  Window rootw;
X
X  XGetGeometry(display, button, &rootw, &x, &y, &w, &h, &d, &b);
X  XFillRectangle(display, button, fontgc, 0, 0, w, h);
}
X
void draw_buttons()
{
X  char numberstring[32];
X  char buttonstring[6];
X  int i;
X
X  for (i = 1; i >= 0; i--) {
X    if ((current_image == NODE) && (current_inc == i)) {
X      fill_button(nodewin[i]);
X      XDrawString(display, nodewin[i], blackfontgc, 2, 13, "node", 4);
X    } else {
X      XClearWindow(display, nodewin[i]);
X      XDrawString(display, nodewin[i], fontgc, 2, 13, "node", 4);
X    }
X    if ((current_image == POLY) && (current_inc == i)) {
X      fill_button(polywin[i]);
X      XDrawString(display, polywin[i], blackfontgc, 2, 13, "poly", 4);
X    } else {
X      XClearWindow(display, polywin[i]);
X      XDrawString(display, polywin[i], fontgc, 2, 13, "poly", 4);
X    }
X    if ((current_image == ELE) && (current_inc == i)) {
X      fill_button(elewin[i]);
X      XDrawString(display, elewin[i], blackfontgc, 2, 13, "ele", 3);
X    } else {
X      XClearWindow(display, elewin[i]);
X      XDrawString(display, elewin[i], fontgc, 2, 13, "ele", 3);
X    }
X    if ((current_image == EDGE) && (current_inc == i)) {
X      fill_button(edgewin[i]);
X      XDrawString(display, edgewin[i], blackfontgc, 2, 13, "edge", 4);
X    } else {
X      XClearWindow(display, edgewin[i]);
X      XDrawString(display, edgewin[i], fontgc, 2, 13, "edge", 4);
X    }
X    if ((current_image == PART) && (current_inc == i)) {
X      fill_button(partwin[i]);
X      XDrawString(display, partwin[i], blackfontgc, 2, 13, "part", 4);
X    } else {
X      XClearWindow(display, partwin[i]);
X      XDrawString(display, partwin[i], fontgc, 2, 13, "part", 4);
X    }
X    if ((current_image == ADJ) && (current_inc == i)) {
X      fill_button(adjwin[i]);
X      XDrawString(display, adjwin[i], blackfontgc, 2, 13, "adj", 3);
X    } else {
X      XClearWindow(display, adjwin[i]);
X      XDrawString(display, adjwin[i], fontgc, 2, 13, "adj", 3);
X    }
X    if ((current_image == VORO) && (current_inc == i)) {
X      fill_button(voronoiwin[i]);
X      XDrawString(display, voronoiwin[i], blackfontgc, 2, 13, "voro", 4);
X    } else {
X      XClearWindow(display, voronoiwin[i]);
X      XDrawString(display, voronoiwin[i], fontgc, 2, 13, "voro", 4);
X    }
X  }
X
X  XClearWindow(display, versionpluswin);
X  sprintf(numberstring, "%d", loweriteration + 1);
X  sprintf(buttonstring, "%-4.4s+", numberstring);
X  XDrawString(display, versionpluswin, fontgc, 2, 13, buttonstring, 5);
X  XClearWindow(display, versionminuswin);
X  sprintf(numberstring, "%d", loweriteration);
X  if (loweriteration == 0) {
X    sprintf(buttonstring, "%-4.4s", numberstring);
X  } else {
X    sprintf(buttonstring, "%-4.4s-", numberstring);
X  }
X  XDrawString(display, versionminuswin, fontgc, 2, 13, buttonstring, 5);
X
X  XClearWindow(display, quitwin);
X  XDrawString(display, quitwin, fontgc, 2, 13, "Quit", 4);
X  XClearWindow(display, leftwin);
X  XDrawString(display, leftwin, fontgc, 2, 13, "<", 1);
X  XClearWindow(display, rightwin);
X  XDrawString(display, rightwin, fontgc, 2, 13, ">", 1);
X  XClearWindow(display, upwin);
X  XDrawString(display, upwin, fontgc, 2, 13, "^", 1);
X  XClearWindow(display, downwin);
X  XDrawString(display, downwin, fontgc, 2, 13, "v", 1);
X  XClearWindow(display, resetwin);
X  XDrawString(display, resetwin, fontgc, 2, 13, "Reset", 6);
X  XClearWindow(display, widthpluswin);
X  if (line_width < 100) {
X    XDrawString(display, widthpluswin, fontgc, 2, 13, "Width+", 6);
X  } else {
X    XDrawString(display, widthpluswin, fontgc, 2, 13, "Width ", 6);
X  }
X  XClearWindow(display, widthminuswin);
X  if (line_width > 1) {
X    XDrawString(display, widthminuswin, fontgc, 2, 13, "-", 1);
X  }
X  XClearWindow(display, expwin);
X  XClearWindow(display, exppluswin);
X  XClearWindow(display, expminuswin);
X  XClearWindow(display, fillwin);
X  if (current_image == PART) {
X    if (explode) {
X      fill_button(expwin);
X      XDrawString(display, expwin, blackfontgc, 2, 13, "Exp", 3);
X    } else {
X      XDrawString(display, expwin, fontgc, 2, 13, "Exp", 3);
X    }
X    XDrawString(display, exppluswin, fontgc, 2, 13, "+", 1);
X    XDrawString(display, expminuswin, fontgc, 2, 13, "-", 1);
X    if (fillelem) {
X      fill_button(fillwin);
X      XDrawString(display, fillwin, blackfontgc, 2, 13, "Fill", 4);
X    } else {
X      XDrawString(display, fillwin, fontgc, 2, 13, "Fill", 4);
X    }
X  }
X  XClearWindow(display, pswin);
X  XDrawString(display, pswin, fontgc, 2, 13, "PS", 2);
X  XClearWindow(display, epswin);
X  XDrawString(display, epswin, fontgc, 2, 13, "EPS", 3);
}
X
void showme_window(argc, argv)
int argc;
char **argv;
{
X  XSetWindowAttributes attr;
X  XSizeHints hints;
X  XGCValues fontvalues, linevalues;
X  XColor alloc_color, exact_color;
X  int i;
X
X  display = XOpenDisplay((char *) NULL);
X  if (!display) {
X    printf("Error:  Cannot open display.\n");
X    exit(1);
X  }
X  screen = DefaultScreen(display);
X  rootwindow = DefaultRootWindow(display);
X  black = BlackPixel(display, screen);
X  white = WhitePixel(display, screen);
X  windowdepth = DefaultDepth(display, screen);
X  rootmap = DefaultColormap(display, screen);
X  width = STARTWIDTH;
X  height = STARTHEIGHT;
X  attr.background_pixel = black;
X  attr.border_pixel = white;
X  attr.backing_store = NotUseful;
X  attr.event_mask = ExposureMask | ButtonReleaseMask | ButtonPressMask |
X                    StructureNotifyMask;
X  attr.bit_gravity = NorthWestGravity;
X  attr.win_gravity = NorthWestGravity;
X  attr.save_under = False;
X  mainwindow = XCreateWindow(display, rootwindow, 0, 0, width,
X                             height + PANELHEIGHT, 3, 0,
X                             InputOutput, CopyFromParent,
X                             CWBackPixel | CWBorderPixel | CWEventMask |
X                             CWBitGravity | CWWinGravity | CWBackingStore |
X                             CWSaveUnder, &attr);
X  hints.width = width;
X  hints.height = height + PANELHEIGHT;
X  hints.min_width = MINWIDTH;
X  hints.min_height = MINHEIGHT + PANELHEIGHT;
X  hints.width_inc = 1;
X  hints.height_inc = 1;
X  hints.flags = PMinSize | PSize | PResizeInc;
X  XSetStandardProperties(display, mainwindow, "Show Me", "showme", None,
X                         argv, argc, &hints);
X  XChangeProperty(display, mainwindow, XA_WM_CLASS, XA_STRING, 8,
X                  PropModeReplace, "showme\0Archimedes", 18);
X  XClearWindow(display, mainwindow);
X  XMapWindow(display, mainwindow);
X  if ((windowdepth > 1) &&
X      XAllocNamedColor(display, rootmap, "yellow", &alloc_color,
X                       &exact_color)) {
X    color = 1;
X    explode = bw_ps;
X    fontvalues.foreground = alloc_color.pixel;
X    linevalues.foreground = alloc_color.pixel;
X    showme_foreground = alloc_color.pixel;
X    for (i = 0; i < 64; i++) {
X      if (XAllocNamedColor(display, rootmap, colorname[i], &alloc_color,
X                           &rgb[i])) {
X        colors[i] = alloc_color.pixel;
X      } else {
X        colors[i] = white;
X        rgb[i].red = alloc_color.red;
X        rgb[i].green = alloc_color.green;
X        rgb[i].blue = alloc_color.blue;
X        if (!quiet) {
X          printf("Warning:  I could not allocate %s.\n", colorname[i]);
X        }
X      }
X    }
X  } else {
X    color = 0;
X    fillelem = 0;
X    explode = 1;
X    fontvalues.foreground = white;
X    linevalues.foreground = white;
X    showme_foreground = white;
X  }
X  font = XLoadQueryFont(display, "9x15");
X  fontvalues.background = black;
X  fontvalues.font = font->fid;
X  fontvalues.fill_style = FillSolid;
X  fontvalues.line_width = 2;
X  fontgc = XCreateGC(display, rootwindow, GCForeground | GCBackground |
X                      GCFont | GCLineWidth | GCFillStyle, &fontvalues);
X  fontvalues.foreground = black;
X  blackfontgc = XCreateGC(display, rootwindow, GCForeground | GCBackground |
X                         GCFont | GCLineWidth | GCFillStyle, &fontvalues);
X  linevalues.background = black;
X  linevalues.line_width = line_width;
X  linevalues.cap_style = CapRound;
X  linevalues.join_style = JoinRound;
X  linevalues.fill_style = FillSolid;
X  linegc = XCreateGC(display, rootwindow, GCForeground | GCBackground |
X                     GCLineWidth | GCCapStyle | GCJoinStyle | GCFillStyle,
X                     &linevalues);
X  trianglegc = XCreateGC(display, rootwindow, GCForeground | GCBackground |
X                         GCLineWidth | GCCapStyle | GCJoinStyle | GCFillStyle,
X                         &linevalues);
X  make_buttons(height);
X  XFlush(display);
}
X
void draw_node(nodes, dim, ptr, xscale, yscale, xoffset, yoffset)
int nodes;
int dim;
REAL *ptr;
REAL xscale;
REAL yscale;
REAL xoffset;
REAL yoffset;
{
X  int i;
X  int index;
X
X  index = dim;
X  for (i = 1; i <= nodes; i++) {
X    XFillRectangle(display, mainwindow, linegc,
X                   (int) (ptr[index] * xscale + xoffset) - (line_width >> 1),
X                   (int) (ptr[index + 1] * yscale + yoffset) -
X                         (line_width >> 1), line_width, line_width);
X    index += dim;
X  }
}
X
void draw_poly(nodes, dim, edges, holes, nodeptr, edgeptr, holeptr,
X               xscale, yscale, xoffset, yoffset)
int nodes;
int dim;
int edges;
int holes;
REAL *nodeptr;
int *edgeptr;
REAL *holeptr;
REAL xscale;
REAL yscale;
REAL xoffset;
REAL yoffset;
{
X  int i;
X  int index;
X  REAL *point1, *point2;
X  int x1, y1, x2, y2;
X
X  index = dim;
X  for (i = 1; i <= nodes; i++) {
X    XFillRectangle(display, mainwindow, linegc,
X                   (int) (nodeptr[index] * xscale + xoffset) -
X                         (line_width >> 1),
X                   (int) (nodeptr[index + 1] * yscale + yoffset) -
X                         (line_width >> 1), line_width, line_width);
X    index += dim;
X  }
X  index = 2;
X  for (i = 1; i <= edges; i++) {
X    point1 = &nodeptr[edgeptr[index++] * dim];
X    point2 = &nodeptr[edgeptr[index++] * dim];
X    XDrawLine(display, mainwindow, linegc,
X              (int) (point1[0] * xscale + xoffset),
X              (int) (point1[1] * yscale + yoffset),
X              (int) (point2[0] * xscale + xoffset),
X              (int) (point2[1] * yscale + yoffset));
X  }
X  index = dim;
X  if (color) {
X    XSetForeground(display, linegc, colors[0]);
X  }
X  for (i = 1; i <= holes; i++) {
X    x1 = (int) (holeptr[index] * xscale + xoffset) - 3;
X    y1 = (int) (holeptr[index + 1] * yscale + yoffset) - 3;
X    x2 = x1 + 6;
X    y2 = y1 + 6;
X    XDrawLine(display, mainwindow, linegc, x1, y1, x2, y2);
X    XDrawLine(display, mainwindow, linegc, x1, y2, x2, y1);
X    index += dim;
X  }
X  XSetForeground(display, linegc, showme_foreground);
}
X
void draw_ele(inc, elems, corners, ptr, partition, shift,
X              xscale, yscale, xoffset, yoffset)
int inc;
int elems;
int corners;
int *ptr;
int *partition;
REAL *shift;
REAL xscale;
REAL yscale;
REAL xoffset;
REAL yoffset;
{
X  int i, j;
X  int index;
X  REAL shiftx, shifty;
X  REAL *prevpoint, *nowpoint;
X  XPoint *vertices;
X
X  if (color && fillelem && (partition != (int *) NULL)) {
X    vertices = (XPoint *) malloc(3 * sizeof(XPoint));
X    if (vertices == (XPoint *) NULL) {
X      printf("Error:  Out of memory.\n");
X      exit(1);
X    }
X  }
X  index = 3;
X  for (i = 1; i <= elems; i++) {
X    if ((partition != (int *) NULL) && explode) {
X      shiftx = shift[partition[i] << 1];
X      shifty = shift[(partition[i] << 1) + 1];
X    }
X    if (color && (partition != (int *) NULL)) {
X      if (fillelem) {
X        XSetForeground(display, trianglegc, colors[partition[i] & 63]);
X      } else {
X        XSetForeground(display, linegc, colors[partition[i] & 63]);
X      }
X    }
X    if (color && fillelem && (partition != (int *) NULL)) {
X      if ((partition != (int *) NULL) && explode) {
X        for (j = 0; j < 3; j++) {
X          nowpoint = &nodeptr[inc][ptr[index + j] * node_dim[inc]];
X          vertices[j].x = (nowpoint[0] + shiftx) * xscale + xoffset;
X          vertices[j].y = (nowpoint[1] + shifty) * yscale + yoffset;
X        }
X      } else {
X        for (j = 0; j < 3; j++) {
X          nowpoint = &nodeptr[inc][ptr[index + j] * node_dim[inc]];
X          vertices[j].x = nowpoint[0] * xscale + xoffset;
X          vertices[j].y = nowpoint[1] * yscale + yoffset;
X        }
X      }
X      XFillPolygon(display, mainwindow, trianglegc, vertices, 3,
X                   Convex, CoordModeOrigin);
X    }
X    prevpoint = &nodeptr[inc][ptr[index + 2] * node_dim[inc]];
X    if ((partition != (int *) NULL) && explode) {
X      for (j = 0; j < 3; j++) {
X        nowpoint = &nodeptr[inc][ptr[index++] * node_dim[inc]];
X        XDrawLine(display, mainwindow, linegc,
X                  (int) ((prevpoint[0] + shiftx) * xscale + xoffset),
X                  (int) ((prevpoint[1] + shifty) * yscale + yoffset),
X                  (int) ((nowpoint[0] + shiftx) * xscale + xoffset),
X                  (int) ((nowpoint[1] + shifty) * yscale + yoffset));
X        prevpoint = nowpoint;
X      }
X    } else {
X      for (j = 0; j < 3; j++) {
X        nowpoint = &nodeptr[inc][ptr[index++] * node_dim[inc]];
X        XDrawLine(display, mainwindow, linegc,
X                  (int) (prevpoint[0] * xscale + xoffset),
X                  (int) (prevpoint[1] * yscale + yoffset),
X                  (int) (nowpoint[0] * xscale + xoffset),
X                  (int) (nowpoint[1] * yscale + yoffset));
X        prevpoint = nowpoint;
X      }
X    }
X  }
X  if (color && fillelem && (partition != (int *) NULL)) {
X    free(vertices);
X  }
X  XSetForeground(display, linegc, showme_foreground);
}
X
void draw_edge(nodes, dim, edges, nodeptr, edgeptr, normptr,
X               xscale, yscale, xoffset, yoffset)
int nodes;
int dim;
int edges;
REAL *nodeptr;
int *edgeptr;
REAL *normptr;
REAL xscale;
REAL yscale;
REAL xoffset;
REAL yoffset;
{
X  int i;
X  int index;
X  REAL *point1, *point2;
X  REAL normx, normy;
X  REAL normmult, normmultx, normmulty;
X  REAL windowxmin, windowymin, windowxmax, windowymax;
X
X  index = 2;
X  for (i = 1; i <= edges; i++) {
X    point1 = &nodeptr[edgeptr[index++] * dim];
X    if (edgeptr[index] == -1) {
X      normx = normptr[index - 1];
X      normy = normptr[index++];
X      normmultx = 0.0;
X      if (normx > 0) {
X        windowxmax = (width - 1 - xoffset) / xscale;
X        normmultx = (windowxmax - point1[0]) / normx;
X      } else if (normx < 0) {
X        windowxmin = -xoffset / xscale;
X        normmultx = (windowxmin - point1[0]) / normx;
X      }
X      normmulty = 0.0;
X      if (normy > 0) {
X        windowymax = -yoffset / yscale;
X        normmulty = (windowymax - point1[1]) / normy;
X      } else if (normy < 0) {
X        windowymin = (height - 1 - yoffset) / yscale;
X        normmulty = (windowymin - point1[1]) / normy;
X      }
X      if (normmultx == 0.0) {
X        normmult = normmulty;
X      } else if (normmulty == 0.0) {
X        normmult = normmultx;
X      } else if (normmultx < normmulty) {
X        normmult = normmultx;
X      } else {
X        normmult = normmulty;
X      }
X      if (normmult > 0.0) {
X        XDrawLine(display, mainwindow, linegc,
X                  (int) (point1[0] * xscale + xoffset),
X                  (int) (point1[1] * yscale + yoffset),
X                  (int) ((point1[0] + normmult * normx) * xscale + xoffset),
X                  (int) ((point1[1] + normmult * normy) * yscale + yoffset));
X      }
X    } else {
X      point2 = &nodeptr[edgeptr[index++] * dim];
X      XDrawLine(display, mainwindow, linegc,
X                (int) (point1[0] * xscale + xoffset),
X                (int) (point1[1] * yscale + yoffset),
X                (int) (point2[0] * xscale + xoffset),
X                (int) (point2[1] * yscale + yoffset));
X    }
X  }
}
X
void draw_adj(dim, subdomains, ptr, center, xscale, yscale,
X              xoffset, yoffset)
int dim;
int subdomains;
int *ptr;
REAL *center;
REAL xscale;
REAL yscale;
REAL xoffset;
REAL yoffset;
{
X  int i, j;
X  REAL *point1, *point2;
X
X  for (i = 0; i < subdomains; i++) {
X    for (j = i + 1; j < subdomains; j++) {
X      if (ptr[i * subdomains + j]) {
X        point1 = &center[i * dim];
X        point2 = &center[j * dim];
X        XDrawLine(display, mainwindow, linegc,
X                  (int) (point1[0] * xscale + xoffset),
X                  (int) (point1[1] * yscale + yoffset),
X                  (int) (point2[0] * xscale + xoffset),
X                  (int) (point2[1] * yscale + yoffset));
X      }
X    }
X  }
X  for (i = 0; i < subdomains; i++) {
X    point1 = &center[i * dim];
X    if (color) {
X      XSetForeground(display, linegc, colors[i & 63]);
X    }
X    XFillArc(display, mainwindow, linegc,
X             (int) (point1[0] * xscale + xoffset) - 5 - (line_width >> 1),
X             (int) (point1[1] * yscale + yoffset) - 5 - (line_width >> 1),
X             line_width + 10, line_width + 10, 0, 23040);
X  }
X  XSetForeground(display, linegc, showme_foreground);
}
X
void draw(inc, image, xmin, ymin, xmax, ymax)
int inc;
int image;
REAL xmin;
REAL ymin;
REAL xmax;
REAL ymax;
{
X  draw_buttons();
X  XClearWindow(display, mainwindow);
X  if (image == NOTHING) {
X    return;
X  }
X  if (!loaded[inc][image]) {
X    return;
X  }
X  if ((image == PART) && explode) {
X    xmin += (xmin - partcenter[inc][subdomains[inc] << 1]) * explosion;
X    xmax += (xmax - partcenter[inc][subdomains[inc] << 1]) * explosion;
X    ymin += (ymin - partcenter[inc][(subdomains[inc] << 1) + 1]) * explosion;
X    ymax += (ymax - partcenter[inc][(subdomains[inc] << 1) + 1]) * explosion;
X  }
X  xscale = (REAL) (width - line_width - 4) / (xmax - xmin);
X  yscale = (REAL) (height - line_width - 4) / (ymax - ymin);
X  if (xscale > yscale) {
X    xscale = yscale;
X  } else {
X    yscale = xscale;
X  }
X  xoffset = 0.5 * ((REAL) width - xscale * (xmax - xmin)) -
X            xscale * xmin;
X  yoffset = (REAL) height - 0.5 * ((REAL) height - yscale * (ymax - ymin)) +
X            yscale * ymin;
X  yscale = - yscale;
X  switch(image) {
X    case NODE:
X      draw_node(nodes[inc], node_dim[inc], nodeptr[inc],
X                xscale, yscale, xoffset, yoffset);
X      break;
X    case POLY:
X      if (polynodes[inc] > 0) {
X        draw_poly(polynodes[inc], poly_dim[inc], polyedges[inc],
X                  polyholes[inc], polynodeptr[inc], polyedgeptr[inc],
X                  polyholeptr[inc],
X                  xscale, yscale, xoffset, yoffset);
X      } else {
X        draw_poly(nodes[inc], node_dim[inc], polyedges[inc],
X                  polyholes[inc], nodeptr[inc], polyedgeptr[inc],
X                  polyholeptr[inc],
X                  xscale, yscale, xoffset, yoffset);
X      }
X      break;
X    case ELE:
X      draw_ele(inc, elems[inc], ele_corners[inc], eleptr[inc],
X               (int *) NULL, (REAL *) NULL,
X               xscale, yscale, xoffset, yoffset);
X      break;
X    case EDGE:
X      draw_edge(nodes[inc], node_dim[inc], edges[inc],
X                nodeptr[inc], edgeptr[inc], normptr[inc],
X                xscale, yscale, xoffset, yoffset);
X      break;
X    case PART:
X      draw_ele(inc, elems[inc], ele_corners[inc], eleptr[inc],
X               partpart[inc], partshift[inc],
X               xscale, yscale, xoffset, yoffset);
X      break;
X    case ADJ:
X      draw_adj(node_dim[inc], adjsubdomains[inc], adjptr[inc], partcenter[inc],
X               xscale, yscale, xoffset, yoffset);
X      break;
X    case VORO:
X      if (loaded[inc][NODE]) {
X        draw_node(nodes[inc], node_dim[inc], nodeptr[inc],
X                  xscale, yscale, xoffset, yoffset);
X      }
X      draw_edge(vnodes[inc], vnode_dim[inc], vedges[inc],
X                vnodeptr[inc], vedgeptr[inc], vnormptr[inc],
X                xscale, yscale, xoffset, yoffset);
X      break;
X    default:
X      break;
X  }
}
X
void addps(instring, outstring, eps)
char *instring;
char *outstring;
int eps;
{
X  strcpy(outstring, instring);
X  if (eps) {
X    strcat(outstring, ".eps");
X  } else {
X    strcat(outstring, ".ps");
X  }
}
X
int print_head(fname, file, llcornerx, llcornery, eps)
char *fname;
FILE **file;
int llcornerx;
int llcornery;
int eps;
{
X  if (!quiet) {
X    printf("Writing %s\n", fname);
X  }
X  *file = fopen(fname, "w");
X  if (*file == (FILE *) NULL) {
X    printf("  Error:  Could not open %s\n", fname);
X    return 1;
X  }
X  if (eps) {
X    fprintf(*file, "%%!PS-Adobe-2.0 EPSF-2.0\n");
X  } else {
X    fprintf(*file, "%%!PS-Adobe-2.0\n");
X  }
X  fprintf(*file, "%%%%BoundingBox: %d %d %d %d\n", llcornerx, llcornery,
X          612 - llcornerx, 792 - llcornery);
X  fprintf(*file, "%%%%Creator: Show Me\n");
X  fprintf(*file, "%%%%EndComments\n\n");
X  fprintf(*file, "/m {moveto} bind def\n");
X  fprintf(*file, "/l {lineto} bind def\n");
X  fprintf(*file, "/s {setrgbcolor} bind def\n");
X  fprintf(*file, "/g {gsave fill grestore} bind def\n");
X  fprintf(*file, "/k {stroke} bind def\n\n");
X  fprintf(*file, "1 setlinecap\n");
X  fprintf(*file, "1 setlinejoin\n");
X  fprintf(*file, "%d setlinewidth\n", line_width);
X  fprintf(*file, "%d %d m\n", llcornerx, llcornery);
X  fprintf(*file, "%d %d l\n", 612 - llcornerx, llcornery);
X  fprintf(*file, "%d %d l\n", 612 - llcornerx, 792 - llcornery);
X  fprintf(*file, "%d %d l\n", llcornerx, 792 - llcornery);
X  fprintf(*file, "closepath\nclip\nnewpath\n");
X  return 0;
}
X
void print_node(nodefile, nodes, dim, ptr, xscale, yscale,
X                xoffset, yoffset)
FILE *nodefile;
int nodes;
int dim;
REAL *ptr;
REAL xscale;
REAL yscale;
REAL xoffset;
REAL yoffset;
{
X  int i;
X  int index;
X
X  index = dim;
X  for (i = 1; i <= nodes; i++) {
X    fprintf(nodefile, "%d %d %d 0 360 arc\nfill\n",
X            (int) (ptr[index] * xscale + xoffset),
X            (int) (ptr[index + 1] * yscale + yoffset),
X            1 + (line_width >> 1));
X    index += dim;
X  }
}
X
void print_poly(polyfile, nodes, dim, edges, holes, nodeptr, edgeptr, holeptr,
X                xscale, yscale, xoffset, yoffset)
FILE *polyfile;
int nodes;
int dim;
int edges;
int holes;
REAL *nodeptr;
int *edgeptr;
REAL *holeptr;
REAL xscale;
REAL yscale;
REAL xoffset;
REAL yoffset;
{
X  int i;
X  int index;
X  REAL *point1, *point2;
X
X  index = dim;
X  for (i = 1; i <= nodes; i++) {
X    fprintf(polyfile, "%d %d %d 0 360 arc\nfill\n",
X            (int) (nodeptr[index] * xscale + xoffset),
X            (int) (nodeptr[index + 1] * yscale + yoffset),
X            1 + (line_width >> 1));
X    index += dim;
X  }
X  index = 2;
X  for (i = 1; i <= edges; i++) {
X    point1 = &nodeptr[edgeptr[index++] * dim];
X    point2 = &nodeptr[edgeptr[index++] * dim];
X    fprintf(polyfile, "%d %d m\n",
X            (int) (point1[0] * xscale + xoffset),
X            (int) (point1[1] * yscale + yoffset));
X    fprintf(polyfile, "%d %d l\nk\n",
X            (int) (point2[0] * xscale + xoffset),
X            (int) (point2[1] * yscale + yoffset));
X  }
}
X
void print_ele(elefile, nodes, dim, elems, corners, nodeptr, eleptr,
X               partition, shift,
X               xscale, yscale, xoffset, yoffset, llcornerx, llcornery)
FILE *elefile;
int nodes;
int dim;
int elems;
int corners;
REAL *nodeptr;
int *eleptr;
int *partition;
REAL *shift;
REAL xscale;
REAL yscale;
REAL xoffset;
REAL yoffset;
int llcornerx;
int llcornery;
{
X  int i, j;
X  int index, colorindex;
X  REAL shiftx, shifty;
X  REAL *nowpoint;
X
X  index = 3;
X  if ((partition != (int *) NULL) && !bw_ps) {
X    fprintf(elefile, "0 0 0 s\n");
X    fprintf(elefile, "%d %d m\n", llcornerx, llcornery);
X    fprintf(elefile, "%d %d l\n", 612 - llcornerx, llcornery);
X    fprintf(elefile, "%d %d l\n", 612 - llcornerx, 792 - llcornery);
X    fprintf(elefile, "%d %d l\n", llcornerx, 792 - llcornery);
X    fprintf(elefile, "fill\n");
X  }
X  for (i = 1; i <= elems; i++) {
X    if ((partition != (int *) NULL) && !bw_ps) {
X      colorindex = partition[i] & 63;
X      fprintf(elefile, "%6.3f %6.3f %6.3f s\n",
X              (REAL) rgb[colorindex].red / 65535.0,
X              (REAL) rgb[colorindex].green / 65535.0,
X              (REAL) rgb[colorindex].blue / 65535.0);
X    }
X    nowpoint = &nodeptr[eleptr[index + 2] * dim];
X    if ((partition != (int *) NULL) && (explode || bw_ps)) {
X      shiftx = shift[partition[i] << 1];
X      shifty = shift[(partition[i] << 1) + 1];
X      fprintf(elefile, "%d %d m\n",
X              (int) ((nowpoint[0] + shiftx) * xscale + xoffset),
X              (int) ((nowpoint[1] + shifty) * yscale + yoffset));
X      for (j = 0; j < 3; j++) {
X        nowpoint = &nodeptr[eleptr[index++] * dim];
X        fprintf(elefile, "%d %d l\n",
X                (int) ((nowpoint[0] + shiftx) * xscale + xoffset),
X                (int) ((nowpoint[1] + shifty) * yscale + yoffset));
X      }
X    } else {
X      fprintf(elefile, "%d %d m\n",
X              (int) (nowpoint[0] * xscale + xoffset),
X              (int) (nowpoint[1] * yscale + yoffset));
X      for (j = 0; j < 3; j++) {
X        nowpoint = &nodeptr[eleptr[index++] * dim];
X        fprintf(elefile, "%d %d l\n",
X                (int) (nowpoint[0] * xscale + xoffset),
X                (int) (nowpoint[1] * yscale + yoffset));
X      }
X    }
X    if (fillelem && (partition != (int *) NULL) && !bw_ps) {
X      fprintf(elefile, "g\n1 1 0 s\n");
X    }
X    fprintf(elefile, "k\n");
X  }
}
X
void print_edge(edgefile, nodes, dim, edges, nodeptr, edgeptr, normptr,
X                xscale, yscale, xoffset, yoffset, llcornerx, llcornery)
FILE *edgefile;
int nodes;
int dim;
int edges;
REAL *nodeptr;
int *edgeptr;
REAL *normptr;
REAL xscale;
REAL yscale;
REAL xoffset;
REAL yoffset;
int llcornerx;
int llcornery;
{
X  int i;
X  int index;
X  REAL *point1, *point2;
X  REAL normx, normy;
X  REAL normmult, normmultx, normmulty;
X  REAL windowxmin, windowymin, windowxmax, windowymax;
X
X  index = 2;
X  for (i = 1; i <= edges; i++) {
X    point1 = &nodeptr[edgeptr[index++] * dim];
X    if (edgeptr[index] == -1) {
X      normx = normptr[index - 1];
X      normy = normptr[index++];
X      normmultx = 0.0;
X      if (normx > 0) {
X        windowxmax = ((REAL) (612 - llcornerx) - xoffset) / xscale;
X        normmultx = (windowxmax - point1[0]) / normx;
X      } else if (normx < 0) {
X        windowxmin = ((REAL) llcornerx - xoffset) / xscale;
X        normmultx = (windowxmin - point1[0]) / normx;
X      }
X      normmulty = 0.0;
X      if (normy > 0) {
X        windowymax = ((REAL) (792 - llcornery) - yoffset) / yscale;
X        normmulty = (windowymax - point1[1]) / normy;
X      } else if (normy < 0) {
X        windowymin = ((REAL) llcornery - yoffset) / yscale;
X        normmulty = (windowymin - point1[1]) / normy;
X      }
X      if (normmultx == 0.0) {
X        normmult = normmulty;
X      } else if (normmulty == 0.0) {
X        normmult = normmultx;
X      } else if (normmultx < normmulty) {
X        normmult = normmultx;
X      } else {
X        normmult = normmulty;
X      }
X      if (normmult > 0.0) {
X        fprintf(edgefile, "%d %d m\n",
X                (int) (point1[0] * xscale + xoffset),
X                (int) (point1[1] * yscale + yoffset));
X        fprintf(edgefile, "%d %d l\nk\n",
X                (int) ((point1[0] + normmult * normx) * xscale + xoffset),
X                (int) ((point1[1] + normmult * normy) * yscale + yoffset));
X      }
X    } else {
X      point2 = &nodeptr[edgeptr[index++] * dim];
X      fprintf(edgefile, "%d %d m\n",
X              (int) (point1[0] * xscale + xoffset),
X              (int) (point1[1] * yscale + yoffset));
X      fprintf(edgefile, "%d %d l\nk\n",
X              (int) (point2[0] * xscale + xoffset),
X              (int) (point2[1] * yscale + yoffset));
X    }
X  }
}
X
void print_adj(adjfile, dim, subdomains, ptr, center, xscale, yscale,
X               xoffset, yoffset, llcornerx, llcornery)
FILE *adjfile;
int dim;
int subdomains;
int *ptr;
REAL *center;
REAL xscale;
REAL yscale;
REAL xoffset;
REAL yoffset;
int llcornerx;
int llcornery;
{
X  int i, j;
X  REAL *point1, *point2;
X  int colorindex;
X
X  if (!bw_ps) {
X    fprintf(adjfile, "0 0 0 s\n");
X    fprintf(adjfile, "%d %d m\n", llcornerx, llcornery);
X    fprintf(adjfile, "%d %d l\n", 612 - llcornerx, llcornery);
X    fprintf(adjfile, "%d %d l\n", 612 - llcornerx, 792 - llcornery);
X    fprintf(adjfile, "%d %d l\n", llcornerx, 792 - llcornery);
X    fprintf(adjfile, "fill\n");
X    fprintf(adjfile, "1 1 0 s\n");
X  }
X  for (i = 0; i < subdomains; i++) {
X    for (j = i + 1; j < subdomains; j++) {
X      if (ptr[i * subdomains + j]) {
X        point1 = &center[i * dim];
X        point2 = &center[j * dim];
X        fprintf(adjfile, "%d %d m\n",
X                (int) (point1[0] * xscale + xoffset),
X                (int) (point1[1] * yscale + yoffset));
X        fprintf(adjfile, "%d %d l\nk\n",
X                (int) (point2[0] * xscale + xoffset),
X                (int) (point2[1] * yscale + yoffset));
X      }
X    }
X  }
X  for (i = 0; i < subdomains; i++) {
X    point1 = &center[i * dim];
X    if (!bw_ps) {
X      colorindex = i & 63;
X      fprintf(adjfile, "%6.3f %6.3f %6.3f s\n",
X              (REAL) rgb[colorindex].red / 65535.0,
X              (REAL) rgb[colorindex].green / 65535.0,
X              (REAL) rgb[colorindex].blue / 65535.0);
X      fprintf(adjfile, "%d %d %d 0 360 arc\nfill\n",
X              (int) (point1[0] * xscale + xoffset),
X              (int) (point1[1] * yscale + yoffset),
X              5 + (line_width >> 1));
X    } else {
X      fprintf(adjfile, "%d %d %d 0 360 arc\nfill\n",
X              (int) (point1[0] * xscale + xoffset),
X              (int) (point1[1] * yscale + yoffset),
X              3 + (line_width >> 1));
X    }
X  }
}
X
void print(inc, image, xmin, ymin, xmax, ymax, eps)
int inc;
int image;
REAL xmin;
REAL ymin;
REAL xmax;
REAL ymax;
int eps;
{
X  REAL xxscale, yyscale, xxoffset, yyoffset;
X  char psfilename[FILENAMESIZE];
X  int llcornerx, llcornery;
X  FILE *psfile;
X
X  if (image == NOTHING) {
X    return;
X  }
X  if (!loaded[inc][image]) {
X    return;
X  }
X  if ((image == PART) && (explode || bw_ps)) {
X    xmin += (xmin - partcenter[inc][subdomains[inc] << 1]) * explosion;
X    xmax += (xmax - partcenter[inc][subdomains[inc] << 1]) * explosion;
X    ymin += (ymin - partcenter[inc][(subdomains[inc] << 1) + 1]) * explosion;
X    ymax += (ymax - partcenter[inc][(subdomains[inc] << 1) + 1]) * explosion;
X  }
X  xxscale = (460.0 - (REAL) line_width) / (xmax - xmin);
X  yyscale = (640.0 - (REAL) line_width) / (ymax - ymin);
X  if (xxscale > yyscale) {
X    xxscale = yyscale;
X    llcornerx = (604 - (int) (yyscale * (xmax - xmin)) - line_width) >> 1;
X    llcornery = 72;
X  } else {
X    yyscale = xxscale;
X    llcornerx = 72;
X    llcornery = (784 - (int) (xxscale * (ymax - ymin)) - line_width) >> 1;
X  }
X  xxoffset = 0.5 * (612.0 - xxscale * (xmax - xmin)) - xxscale * xmin +
X             (line_width >> 1);
X  yyoffset = 0.5 * (792.0 - yyscale * (ymax - ymin)) - yyscale * ymin +
X             (line_width >> 1);
X  switch(image) {
X    case NODE:
X      addps(nodefilename[inc], psfilename, eps);
X      break;
X    case POLY:
X      addps(polyfilename[inc], psfilename, eps);
X      break;
X    case ELE:
X      addps(elefilename[inc], psfilename, eps);
X      break;
X    case EDGE:
X      addps(edgefilename[inc], psfilename, eps);
X      break;
X    case PART:
X      addps(partfilename[inc], psfilename, eps);
X      break;
X    case ADJ:
X      addps(adjfilename[inc], psfilename, eps);
X      break;
X    case VORO:
X      addps(vedgefilename[inc], psfilename, eps);
X      break;
X    default:
X      break;
X  }
X  if (print_head(psfilename, &psfile, llcornerx, llcornery, eps)) {
X    return;
X  }
X  switch(image) {
X    case NODE:
X      print_node(psfile, nodes[inc], node_dim[inc], nodeptr[inc],
X                 xxscale, yyscale, xxoffset, yyoffset);
X      break;
X    case POLY:
X      if (polynodes[inc] > 0) {
X        print_poly(psfile, polynodes[inc], poly_dim[inc], polyedges[inc],
X                   polyholes[inc], polynodeptr[inc], polyedgeptr[inc],
X                   polyholeptr[inc], xxscale, yyscale, xxoffset, yyoffset);
X      } else {
X        print_poly(psfile, nodes[inc], node_dim[inc], polyedges[inc],
X                   polyholes[inc], nodeptr[inc], polyedgeptr[inc],
X                   polyholeptr[inc], xxscale, yyscale, xxoffset, yyoffset);
X      }
X      break;
X    case ELE:
X      print_ele(psfile, nodes[inc], node_dim[inc], elems[inc],
X                ele_corners[inc], nodeptr[inc], eleptr[inc],
X                (int *) NULL, (REAL *) NULL,
X                xxscale, yyscale, xxoffset, yyoffset, llcornerx, llcornery);
X      break;
X    case EDGE:
X      print_edge(psfile, nodes[inc], node_dim[inc], edges[inc],
X                 nodeptr[inc], edgeptr[inc], normptr[inc],
X                 xxscale, yyscale, xxoffset, yyoffset, llcornerx, llcornery);
X      break;
X    case PART:
X      print_ele(psfile, nodes[inc], node_dim[inc], elems[inc],
X                ele_corners[inc], nodeptr[inc], eleptr[inc],
X                partpart[inc], partshift[inc],
X                xxscale, yyscale, xxoffset, yyoffset, llcornerx, llcornery);
X      break;
X    case ADJ:
X      print_adj(psfile, node_dim[inc], adjsubdomains[inc], adjptr[inc],
X                partcenter[inc],
X                xxscale, yyscale, xxoffset, yyoffset, llcornerx, llcornery);
X      break;
X    case VORO:
X      print_edge(psfile, vnodes[inc], vnode_dim[inc], vedges[inc],
X                 vnodeptr[inc], vedgeptr[inc], vnormptr[inc],
X                 xxscale, yyscale, xxoffset, yyoffset, llcornerx, llcornery);
X      break;
X    default:
X      break;
X  }
X  if (!eps) {
X    fprintf(psfile, "showpage\n");
X  }
X  fclose(psfile);
}
X
int main(argc, argv)
int argc;
char **argv;
{
X  REAL xmin, ymin, xmax, ymax;
X  REAL xptr, yptr, xspan, yspan;
X  int past_image;
X  int new_image;
X  int new_inc;
X
X  parsecommandline(argc, argv);
X  showme_init();
X  choose_image(start_inc, start_image);
X  showme_window(argc, argv);
X
X  if (current_image != NOTHING) {
X    xmin = xlo[current_inc][current_image];
X    ymin = ylo[current_inc][current_image];
X    xmax = xhi[current_inc][current_image];
X    ymax = yhi[current_inc][current_image];
X    zoom = 0;
X  }
X
X  XMaskEvent(display, ExposureMask, &event);
X  while (1) {
X    switch (event.type) {
X      case ButtonRelease:
X        if (event.xany.window == quitwin) {
X          XDestroyWindow(display, mainwindow);
X          XCloseDisplay(display);
X          return 0;
X        } else if (event.xany.window == leftwin) {
X          xspan = 0.25 * (xmax - xmin);
X          xmin += xspan;
X          xmax += xspan;
X          draw(current_inc, current_image, xmin, ymin, xmax, ymax);
X        } else if (event.xany.window == rightwin) {
X          xspan = 0.25 * (xmax - xmin);
X          xmin -= xspan;
X          xmax -= xspan;
X          draw(current_inc, current_image, xmin, ymin, xmax, ymax);
X        } else if (event.xany.window == upwin) {
X          yspan = 0.25 * (ymax - ymin);
X          ymin -= yspan;
X          ymax -= yspan;
X          draw(current_inc, current_image, xmin, ymin, xmax, ymax);
X        } else if (event.xany.window == downwin) {
X          yspan = 0.25 * (ymax - ymin);
X          ymin += yspan;
X          ymax += yspan;
X          draw(current_inc, current_image, xmin, ymin, xmax, ymax);
X        } else if (event.xany.window == resetwin) {
X          xmin = xlo[current_inc][current_image];
X          ymin = ylo[current_inc][current_image];
X          xmax = xhi[current_inc][current_image];
X          ymax = yhi[current_inc][current_image];
X          zoom = 0;
X          draw(current_inc, current_image, xmin, ymin, xmax, ymax);
X        } else if (event.xany.window == widthpluswin) {
X          if (line_width < 100) {
X            line_width++;
X            XSetLineAttributes(display, linegc, line_width, LineSolid,
X                               CapRound, JoinRound);
X            XSetLineAttributes(display, trianglegc, line_width, LineSolid,
X                               CapRound, JoinRound);
X            draw(current_inc, current_image, xmin, ymin, xmax, ymax);
X          }
X        } else if (event.xany.window == widthminuswin) {
X          if (line_width > 1) {
X            line_width--;
X            XSetLineAttributes(display, linegc, line_width, LineSolid,
X                               CapRound, JoinRound);
X            XSetLineAttributes(display, trianglegc, line_width, LineSolid,
X                               CapRound, JoinRound);
X            draw(current_inc, current_image, xmin, ymin, xmax, ymax);
X          }
X        } else if (event.xany.window == expwin) {
X          if ((current_image == PART) && loaded[current_inc][PART]) {
X            explode = !explode;
X            draw(current_inc, current_image, xmin, ymin, xmax, ymax);
X          }
X        } else if (event.xany.window == exppluswin) {
X          if ((current_image == PART) && loaded[PART] && explode) {
X            explosion += 0.125;
X            findpartshift(subdomains[current_inc], explosion,
X                          partcenter[current_inc], partshift[current_inc]);
X            draw(current_inc, current_image, xmin, ymin, xmax, ymax);
X          }
X        } else if (event.xany.window == expminuswin) {
X          if ((current_image == PART) && loaded[PART] && explode &&
X              (explosion >= 0.125)) {
X            explosion -= 0.125;
X            findpartshift(subdomains[current_inc], explosion,
X                          partcenter[current_inc], partshift[current_inc]);
X            draw(current_inc, current_image, xmin, ymin, xmax, ymax);
X          }
X        } else if (event.xany.window == fillwin) {
X          if ((current_image == PART) && loaded[PART]) {
X            fillelem = !fillelem;
X            draw(current_inc, current_image, xmin, ymin, xmax, ymax);
X          }
X        } else if (event.xany.window == pswin) {
X          fill_button(pswin);
X          XFlush(display);
X          print(current_inc, current_image, xmin, ymin, xmax, ymax, 0);
X          XClearWindow(display, pswin);
X          XDrawString(display, pswin, fontgc, 2, 13, "PS", 2);
X        } else if (event.xany.window == epswin) {
X          fill_button(epswin);
X          XFlush(display);
X          print(current_inc, current_image, xmin, ymin, xmax, ymax, 1);
X          XClearWindow(display, epswin);
X          XDrawString(display, epswin, fontgc, 2, 13, "EPS", 3);
X        } else if (event.xany.window == versionpluswin) {
X          move_inc(1);
X          loweriteration++;
X          set_filenames(filename, loweriteration);
X          if (current_inc == 1) {
X            current_inc = 0;
X          } else {
X            current_image = NOTHING;
X            XClearWindow(display, mainwindow);
X          }
X          draw_buttons();
X        } else if (event.xany.window == versionminuswin) {
X          if (loweriteration > 0) {
X            move_inc(0);
X            loweriteration--;
X            set_filenames(filename, loweriteration);
X            if (current_inc == 0) {
X              current_inc = 1;
X            } else {
X              current_image = NOTHING;
X              XClearWindow(display, mainwindow);
X            }
X            draw_buttons();
X          }
X        } else if ((event.xany.window == nodewin[0]) ||
X                   (event.xany.window == polywin[0]) ||
X                   (event.xany.window == elewin[0]) ||
X                   (event.xany.window == edgewin[0]) ||
X                   (event.xany.window == partwin[0]) ||
X                   (event.xany.window == adjwin[0]) ||
X                   (event.xany.window == voronoiwin[0]) ||
X                   (event.xany.window == nodewin[1]) ||
X                   (event.xany.window == polywin[1]) ||
X                   (event.xany.window == elewin[1]) ||
X                   (event.xany.window == edgewin[1]) ||
X                   (event.xany.window == partwin[1]) ||
X                   (event.xany.window == adjwin[1]) ||
X                   (event.xany.window == voronoiwin[1])) {
X          if (event.xany.window == nodewin[0]) {
X            new_inc = 0;
X            new_image = NODE;
X          }
X          if (event.xany.window == polywin[0]) {
X            new_inc = 0;
X            new_image = POLY;
X          }
X          if (event.xany.window == elewin[0]) {
X            new_inc = 0;
X            new_image = ELE;
X          }
X          if (event.xany.window == edgewin[0]) {
X            new_inc = 0;
X            new_image = EDGE;
X          }
X          if (event.xany.window == partwin[0]) {
X            new_inc = 0;
X            new_image = PART;
X          }
X          if (event.xany.window == adjwin[0]) {
X            new_inc = 0;
X            new_image = ADJ;
X          }
X          if (event.xany.window == voronoiwin[0]) {
X            new_inc = 0;
X            new_image = VORO;
X          }
X          if (event.xany.window == nodewin[1]) {
X            new_inc = 1;
X            new_image = NODE;
X          }
X          if (event.xany.window == polywin[1]) {
X            new_inc = 1;
X            new_image = POLY;
X          }
X          if (event.xany.window == elewin[1]) {
X            new_inc = 1;
X            new_image = ELE;
X          }
X          if (event.xany.window == edgewin[1]) {
X            new_inc = 1;
X            new_image = EDGE;
X          }
X          if (event.xany.window == partwin[1]) {
X            new_inc = 1;
X            new_image = PART;
X          }
X          if (event.xany.window == adjwin[1]) {
X            new_inc = 1;
X            new_image = ADJ;
X          }
X          if (event.xany.window == voronoiwin[1]) {
X            new_inc = 1;
X            new_image = VORO;
X          }
X          past_image = current_image;
X          if ((current_inc == new_inc) && (current_image == new_image)) {
X            free_inc(new_inc);
X            unload_inc(new_inc);
X          }
X          choose_image(new_inc, new_image);
X          if ((past_image == NOTHING) && (current_image != NOTHING)) {
X            xmin = xlo[current_inc][current_image];
X            ymin = ylo[current_inc][current_image];
X            xmax = xhi[current_inc][current_image];
X            ymax = yhi[current_inc][current_image];
X            zoom = 0;
X          }
X          draw(current_inc, current_image, xmin, ymin, xmax, ymax);
X        } else {
X          xptr = ((REAL) event.xbutton.x - xoffset) / xscale;
X          yptr = ((REAL) event.xbutton.y - yoffset) / yscale;
X          if ((current_image == PART) && loaded[PART] && explode) {
X            xptr = (xptr + partcenter[current_inc]
X                                     [subdomains[current_inc] << 1]
X                    * explosion) / (1.0 + explosion);
X            yptr = (yptr + partcenter[current_inc]
X                                     [(subdomains[current_inc] << 1) + 1]
X                    * explosion) / (1.0 + explosion);
X          }
X          if ((event.xbutton.button == Button1)
X              || (event.xbutton.button == Button3)) {
X            if (event.xbutton.button == Button1) {
X              xspan = 0.25 * (xmax - xmin);
X              yspan = 0.25 * (ymax - ymin);
X              zoom++;
X            } else {
X              xspan = xmax - xmin;
X              yspan = ymax - ymin;
X              zoom--;
X            }
X            xmin = xptr - xspan;
X            ymin = yptr - yspan;
X            xmax = xptr + xspan;
X            ymax = yptr + yspan;
X            draw(current_inc, current_image, xmin, ymin, xmax, ymax);
X          } else if (event.xbutton.button == Button2) {
X            printf("x = %.4g, y = %.4g\n", xptr, yptr);
X          }
X        }
X        break;
X      case DestroyNotify:
X        XDestroyWindow(display, mainwindow);
X        XCloseDisplay(display);
X        return 0;
X      case ConfigureNotify:
X        if ((width != event.xconfigure.width) ||
X            (height != event.xconfigure.height - PANELHEIGHT)) {
X          width = event.xconfigure.width;
X          height = event.xconfigure.height - PANELHEIGHT;
X          draw(current_inc, current_image, xmin, ymin, xmax, ymax);
X          while (XCheckMaskEvent(display, ExposureMask, &event));
X        }
X        break;
X      case Expose:
X        draw(current_inc, current_image, xmin, ymin, xmax, ymax);
X        while (XCheckMaskEvent(display, ExposureMask, &event));
X        break;
X      default:
X        break;
X    }
X    XNextEvent(display, &event);
X  }
}
SHAR_EOF
  (set 20 05 07 28 08 44 26 'showme.c'; eval "$shar_touch") &&
  chmod 0644 'showme.c' ||
  $echo 'restore of' 'showme.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'showme.c:' 'MD5 check failed'
21bee5bada0d71dc88be9a96a1f5652b  showme.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'showme.c'`"
    test 108795 -eq "$shar_count" ||
    $echo 'showme.c:' 'original size' '108795,' 'current size' "$shar_count!"
  fi
fi
# ============= triangle.c ==============
if test -f 'triangle.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'triangle.c' '(file already exists)'
else
  $echo 'x -' extracting 'triangle.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'triangle.c' &&
/*****************************************************************************/
/*                                                                           */
/*      888888888        ,o,                          / 888                  */
/*         888    88o88o  "    o8888o  88o8888o o88888o 888  o88888o         */
/*         888    888    888       88b 888  888 888 888 888 d888  88b        */
/*         888    888    888  o88^o888 888  888 "88888" 888 8888oo888        */
/*         888    888    888 C888  888 888  888  /      888 q888             */
/*         888    888    888  "88o^888 888  888 Cb      888  "88oooo"        */
/*                                              "8oo8D                       */
/*                                                                           */
/*  A Two-Dimensional Quality Mesh Generator and Delaunay Triangulator.      */
/*  (triangle.c)                                                             */
/*                                                                           */
/*  Version 1.6                                                              */
/*  July 28, 2005                                                            */
/*                                                                           */
/*  Copyright 1993, 1995, 1997, 1998, 2002, 2005                             */
/*  Jonathan Richard Shewchuk                                                */
/*  2360 Woolsey #H                                                          */
/*  Berkeley, California  94705-1927                                         */
/*  jrs@cs.berkeley.edu                                                      */
/*                                                                           */
/*  This program may be freely redistributed under the condition that the    */
/*    copyright notices (including this entire header and the copyright      */
/*    notice printed when the `-h' switch is selected) are not removed, and  */
/*    no compensation is received.  Private, research, and institutional     */
/*    use is free.  You may distribute modified versions of this code UNDER  */
/*    THE CONDITION THAT THIS CODE AND ANY MODIFICATIONS MADE TO IT IN THE   */
/*    SAME FILE REMAIN UNDER COPYRIGHT OF THE ORIGINAL AUTHOR, BOTH SOURCE   */
/*    AND OBJECT CODE ARE MADE FREELY AVAILABLE WITHOUT CHARGE, AND CLEAR    */
/*    NOTICE IS GIVEN OF THE MODIFICATIONS.  Distribution of this code as    */
/*    part of a commercial system is permissible ONLY BY DIRECT ARRANGEMENT  */
/*    WITH THE AUTHOR.  (If you are not directly supplying this code to a    */
/*    customer, and you are instead telling them how they can obtain it for  */
/*    free, then you are not required to make any arrangement with me.)      */
/*                                                                           */
/*  Hypertext instructions for Triangle are available on the Web at          */
/*                                                                           */
/*      http://www.cs.cmu.edu/~quake/triangle.html                           */
/*                                                                           */
/*  Disclaimer:  Neither I nor Carnegie Mellon warrant this code in any way  */
/*    whatsoever.  This code is provided "as-is".  Use at your own risk.     */
/*                                                                           */
/*  Some of the references listed below are marked with an asterisk.  [*]    */
/*    These references are available for downloading from the Web page       */
/*                                                                           */
/*      http://www.cs.cmu.edu/~quake/triangle.research.html                  */
/*                                                                           */
/*  Three papers discussing aspects of Triangle are available.  A short      */
/*    overview appears in "Triangle:  Engineering a 2D Quality Mesh          */
/*    Generator and Delaunay Triangulator," in Applied Computational         */
/*    Geometry:  Towards Geometric Engineering, Ming C. Lin and Dinesh       */
/*    Manocha, editors, Lecture Notes in Computer Science volume 1148,       */
/*    pages 203-222, Springer-Verlag, Berlin, May 1996 (from the First ACM   */
/*    Workshop on Applied Computational Geometry).  [*]                      */
/*                                                                           */
/*    The algorithms are discussed in the greatest detail in "Delaunay       */
/*    Refinement Algorithms for Triangular Mesh Generation," Computational   */
/*    Geometry:  Theory and Applications 22(1-3):21-74, May 2002.  [*]       */
/*                                                                           */
/*    More detail about the data structures may be found in my dissertation: */
/*    "Delaunay Refinement Mesh Generation," Ph.D. thesis, Technical Report  */
/*    CMU-CS-97-137, School of Computer Science, Carnegie Mellon University, */
/*    Pittsburgh, Pennsylvania, 18 May 1997.  [*]                            */
/*                                                                           */
/*  Triangle was created as part of the Quake Project in the School of       */
/*    Computer Science at Carnegie Mellon University.  For further           */
/*    information, see Hesheng Bao, Jacobo Bielak, Omar Ghattas, Loukas F.   */
/*    Kallivokas, David R. O'Hallaron, Jonathan R. Shewchuk, and Jifeng Xu,  */
/*    "Large-scale Simulation of Elastic Wave Propagation in Heterogeneous   */
/*    Media on Parallel Computers," Computer Methods in Applied Mechanics    */
/*    and Engineering 152(1-2):85-102, 22 January 1998.                      */
/*                                                                           */
/*  Triangle's Delaunay refinement algorithm for quality mesh generation is  */
/*    a hybrid of one due to Jim Ruppert, "A Delaunay Refinement Algorithm   */
/*    for Quality 2-Dimensional Mesh Generation," Journal of Algorithms      */
/*    18(3):548-585, May 1995 [*], and one due to L. Paul Chew, "Guaranteed- */
/*    Quality Mesh Generation for Curved Surfaces," Proceedings of the Ninth */
/*    Annual Symposium on Computational Geometry (San Diego, California),    */
/*    pages 274-280, Association for Computing Machinery, May 1993,          */
/*    http://portal.acm.org/citation.cfm?id=161150 .                         */
/*                                                                           */
/*  The Delaunay refinement algorithm has been modified so that it meshes    */
/*    domains with small input angles well, as described in Gary L. Miller,  */
/*    Steven E. Pav, and Noel J. Walkington, "When and Why Ruppert's         */
/*    Algorithm Works," Twelfth International Meshing Roundtable, pages      */
/*    91-102, Sandia National Laboratories, September 2003.  [*]             */
/*                                                                           */
/*  My implementation of the divide-and-conquer and incremental Delaunay     */
/*    triangulation algorithms follows closely the presentation of Guibas    */
/*    and Stolfi, even though I use a triangle-based data structure instead  */
/*    of their quad-edge data structure.  (In fact, I originally implemented */
/*    Triangle using the quad-edge data structure, but the switch to a       */
/*    triangle-based data structure sped Triangle by a factor of two.)  The  */
/*    mesh manipulation primitives and the two aforementioned Delaunay       */
/*    triangulation algorithms are described by Leonidas J. Guibas and Jorge */
/*    Stolfi, "Primitives for the Manipulation of General Subdivisions and   */
/*    the Computation of Voronoi Diagrams," ACM Transactions on Graphics     */
/*    4(2):74-123, April 1985, http://portal.acm.org/citation.cfm?id=282923 .*/
/*                                                                           */
/*  Their O(n log n) divide-and-conquer algorithm is adapted from Der-Tsai   */
/*    Lee and Bruce J. Schachter, "Two Algorithms for Constructing the       */
/*    Delaunay Triangulation," International Journal of Computer and         */
/*    Information Science 9(3):219-242, 1980.  Triangle's improvement of the */
/*    divide-and-conquer algorithm by alternating between vertical and       */
/*    horizontal cuts was introduced by Rex A. Dwyer, "A Faster Divide-and-  */
/*    Conquer Algorithm for Constructing Delaunay Triangulations,"           */
/*    Algorithmica 2(2):137-151, 1987.                                       */
/*                                                                           */
/*  The incremental insertion algorithm was first proposed by C. L. Lawson,  */
/*    "Software for C1 Surface Interpolation," in Mathematical Software III, */
/*    John R. Rice, editor, Academic Press, New York, pp. 161-194, 1977.     */
/*    For point location, I use the algorithm of Ernst P. Mucke, Isaac       */
/*    Saias, and Binhai Zhu, "Fast Randomized Point Location Without         */
/*    Preprocessing in Two- and Three-Dimensional Delaunay Triangulations,"  */
/*    Proceedings of the Twelfth Annual Symposium on Computational Geometry, */
/*    ACM, May 1996.  [*]  If I were to randomize the order of vertex        */
/*    insertion (I currently don't bother), their result combined with the   */
/*    result of Kenneth L. Clarkson and Peter W. Shor, "Applications of      */
/*    Random Sampling in Computational Geometry II," Discrete &              */
/*    Computational Geometry 4(1):387-421, 1989, would yield an expected     */
/*    O(n^{4/3}) bound on running time.                                      */
/*                                                                           */
/*  The O(n log n) sweepline Delaunay triangulation algorithm is taken from  */
/*    Steven Fortune, "A Sweepline Algorithm for Voronoi Diagrams",          */
/*    Algorithmica 2(2):153-174, 1987.  A random sample of edges on the      */
/*    boundary of the triangulation are maintained in a splay tree for the   */
/*    purpose of point location.  Splay trees are described by Daniel        */
/*    Dominic Sleator and Robert Endre Tarjan, "Self-Adjusting Binary Search */
/*    Trees," Journal of the ACM 32(3):652-686, July 1985,                   */
/*    http://portal.acm.org/citation.cfm?id=3835 .                           */
/*                                                                           */
/*  The algorithms for exact computation of the signs of determinants are    */
/*    described in Jonathan Richard Shewchuk, "Adaptive Precision Floating-  */
/*    Point Arithmetic and Fast Robust Geometric Predicates," Discrete &     */
/*    Computational Geometry 18(3):305-363, October 1997.  (Also available   */
/*    as Technical Report CMU-CS-96-140, School of Computer Science,         */
/*    Carnegie Mellon University, Pittsburgh, Pennsylvania, May 1996.)  [*]  */
/*    An abbreviated version appears as Jonathan Richard Shewchuk, "Robust   */
/*    Adaptive Floating-Point Geometric Predicates," Proceedings of the      */
/*    Twelfth Annual Symposium on Computational Geometry, ACM, May 1996. [*] */
/*    Many of the ideas for my exact arithmetic routines originate with      */
/*    Douglas M. Priest, "Algorithms for Arbitrary Precision Floating Point  */
/*    Arithmetic," Tenth Symposium on Computer Arithmetic, pp. 132-143, IEEE */
/*    Computer Society Press, 1991.  [*]  Many of the ideas for the correct  */
/*    evaluation of the signs of determinants are taken from Steven Fortune  */
/*    and Christopher J. Van Wyk, "Efficient Exact Arithmetic for Computa-   */
/*    tional Geometry," Proceedings of the Ninth Annual Symposium on         */
/*    Computational Geometry, ACM, pp. 163-172, May 1993, and from Steven    */
/*    Fortune, "Numerical Stability of Algorithms for 2D Delaunay Triangu-   */
/*    lations," International Journal of Computational Geometry & Applica-   */
/*    tions 5(1-2):193-213, March-June 1995.                                 */
/*                                                                           */
/*  The method of inserting new vertices off-center (not precisely at the    */
/*    circumcenter of every poor-quality triangle) is from Alper Ungor,      */
/*    "Off-centers:  A New Type of Steiner Points for Computing Size-Optimal */
/*    Quality-Guaranteed Delaunay Triangulations," Proceedings of LATIN      */
/*    2004 (Buenos Aires, Argentina), April 2004.                            */
/*                                                                           */
/*  For definitions of and results involving Delaunay triangulations,        */
/*    constrained and conforming versions thereof, and other aspects of      */
/*    triangular mesh generation, see the excellent survey by Marshall Bern  */
/*    and David Eppstein, "Mesh Generation and Optimal Triangulation," in    */
/*    Computing and Euclidean Geometry, Ding-Zhu Du and Frank Hwang,         */
/*    editors, World Scientific, Singapore, pp. 23-90, 1992.  [*]            */
/*                                                                           */
/*  The time for incrementally adding PSLG (planar straight line graph)      */
/*    segments to create a constrained Delaunay triangulation is probably    */
/*    O(t^2) per segment in the worst case and O(t) per segment in the       */
/*    common case, where t is the number of triangles that intersect the     */
/*    segment before it is inserted.  This doesn't count point location,     */
/*    which can be much more expensive.  I could improve this to O(d log d)  */
/*    time, but d is usually quite small, so it's not worth the bother.      */
/*    (This note does not apply when the -s switch is used, invoking a       */
/*    different method is used to insert segments.)                          */
/*                                                                           */
/*  The time for deleting a vertex from a Delaunay triangulation is O(d^2)   */
/*    in the worst case and O(d) in the common case, where d is the degree   */
/*    of the vertex being deleted.  I could improve this to O(d log d) time, */
/*    but d is usually quite small, so it's not worth the bother.            */
/*                                                                           */
/*  Ruppert's Delaunay refinement algorithm typically generates triangles    */
/*    at a linear rate (constant time per triangle) after the initial        */
/*    triangulation is formed.  There may be pathological cases where        */
/*    quadratic time is required, but these never arise in practice.         */
/*                                                                           */
/*  The geometric predicates (circumcenter calculations, segment             */
/*    intersection formulae, etc.) appear in my "Lecture Notes on Geometric  */
/*    Robustness" at http://www.cs.berkeley.edu/~jrs/mesh .                  */
/*                                                                           */
/*  If you make any improvements to this code, please please please let me   */
/*    know, so that I may obtain the improvements.  Even if you don't change */
/*    the code, I'd still love to hear what it's being used for.             */
/*                                                                           */
/*****************************************************************************/
X
/* For single precision (which will save some memory and reduce paging),     */
/*   define the symbol SINGLE by using the -DSINGLE compiler switch or by    */
/*   writing "#define SINGLE" below.                                         */
/*                                                                           */
/* For double precision (which will allow you to refine meshes to a smaller  */
/*   edge length), leave SINGLE undefined.                                   */
/*                                                                           */
/* Double precision uses more memory, but improves the resolution of the     */
/*   meshes you can generate with Triangle.  It also reduces the likelihood  */
/*   of a floating exception due to overflow.  Finally, it is much faster    */
/*   than single precision on 64-bit architectures like the DEC Alpha.  I    */
/*   recommend double precision unless you want to generate a mesh for which */
/*   you do not have enough memory.                                          */
X
/* #define SINGLE */
X
#ifdef SINGLE
#define REAL float
#else /* not SINGLE */
#define REAL double
#endif /* not SINGLE */
X
/* If yours is not a Unix system, define the NO_TIMER compiler switch to     */
/*   remove the Unix-specific timing code.                                   */
X
/* #define NO_TIMER */
X
/* To insert lots of self-checks for internal errors, define the SELF_CHECK  */
/*   symbol.  This will slow down the program significantly.  It is best to  */
/*   define the symbol using the -DSELF_CHECK compiler switch, but you could */
/*   write "#define SELF_CHECK" below.  If you are modifying this code, I    */
/*   recommend you turn self-checks on until your work is debugged.          */
X
/* #define SELF_CHECK */
X
/* To compile Triangle as a callable object library (triangle.o), define the */
/*   TRILIBRARY symbol.  Read the file triangle.h for details on how to call */
/*   the procedure triangulate() that results.                               */
X
/* #define TRILIBRARY */
X
/* It is possible to generate a smaller version of Triangle using one or     */
/*   both of the following symbols.  Define the REDUCED symbol to eliminate  */
/*   all features that are primarily of research interest; specifically, the */
/*   -i, -F, -s, and -C switches.  Define the CDT_ONLY symbol to eliminate   */
/*   all meshing algorithms above and beyond constrained Delaunay            */
/*   triangulation; specifically, the -r, -q, -a, -u, -D, -S, and -s         */
/*   switches.  These reductions are most likely to be useful when           */
/*   generating an object library (triangle.o) by defining the TRILIBRARY    */
/*   symbol.                                                                 */
X
/* #define REDUCED */
/* #define CDT_ONLY */
X
/* On some machines, my exact arithmetic routines might be defeated by the   */
/*   use of internal extended precision floating-point registers.  The best  */
/*   way to solve this problem is to set the floating-point registers to use */
/*   single or double precision internally.  On 80x86 processors, this may   */
/*   be accomplished by setting the CPU86 symbol for the Microsoft C         */
/*   compiler, or the LINUX symbol for the gcc compiler running on Linux.    */
/*                                                                           */
/* An inferior solution is to declare certain values as `volatile', thus     */
/*   forcing them to be stored to memory and rounded off.  Unfortunately,    */
/*   this solution might slow Triangle down quite a bit.  To use volatile    */
/*   values, write "#define INEXACT volatile" below.  Normally, however,     */
/*   INEXACT should be defined to be nothing.  ("#define INEXACT".)          */
/*                                                                           */
/* For more discussion, see http://www.cs.cmu.edu/~quake/robust.pc.html .    */
/*   For yet more discussion, see Section 5 of my paper, "Adaptive Precision */
/*   Floating-Point Arithmetic and Fast Robust Geometric Predicates" (also   */
/*   available as Section 6.6 of my dissertation).                           */
X
/* #define CPU86 */
/* #define LINUX */
X
#define INEXACT /* Nothing */
/* #define INEXACT volatile */
X
/* Maximum number of characters in a file name (including the null).         */
X
#define FILENAMESIZE 2048
X
/* Maximum number of characters in a line read from a file (including the    */
/*   null).                                                                  */
X
#define INPUTLINESIZE 1024
X
/* For efficiency, a variety of data structures are allocated in bulk.  The  */
/*   following constants determine how many of each structure is allocated   */
/*   at once.                                                                */
X
#define TRIPERBLOCK 4092           /* Number of triangles allocated at once. */
#define SUBSEGPERBLOCK 508       /* Number of subsegments allocated at once. */
#define VERTEXPERBLOCK 4092         /* Number of vertices allocated at once. */
#define VIRUSPERBLOCK 1020   /* Number of virus triangles allocated at once. */
/* Number of encroached subsegments allocated at once. */
#define BADSUBSEGPERBLOCK 252
/* Number of skinny triangles allocated at once. */
#define BADTRIPERBLOCK 4092
/* Number of flipped triangles allocated at once. */
#define FLIPSTACKERPERBLOCK 252
/* Number of splay tree nodes allocated at once. */
#define SPLAYNODEPERBLOCK 508
X
/* The vertex types.   A DEADVERTEX has been deleted entirely.  An           */
/*   UNDEADVERTEX is not part of the mesh, but is written to the output      */
/*   .node file and affects the node indexing in the other output files.     */
X
#define INPUTVERTEX 0
#define SEGMENTVERTEX 1
#define FREEVERTEX 2
#define DEADVERTEX -32768
#define UNDEADVERTEX -32767
X
/* The next line is used to outsmart some very stupid compilers.  If your    */
/*   compiler is smarter, feel free to replace the "int" with "void".        */
/*   Not that it matters.                                                    */
X
#define VOID int
X
/* Two constants for algorithms based on random sampling.  Both constants    */
/*   have been chosen empirically to optimize their respective algorithms.   */
X
/* Used for the point location scheme of Mucke, Saias, and Zhu, to decide    */
/*   how large a random sample of triangles to inspect.                      */
X
#define SAMPLEFACTOR 11
X
/* Used in Fortune's sweepline Delaunay algorithm to determine what fraction */
/*   of boundary edges should be maintained in the splay tree for point      */
/*   location on the front.                                                  */
X
#define SAMPLERATE 10
X
/* A number that speaks for itself, every kissable digit.                    */
X
#define PI 3.141592653589793238462643383279502884197169399375105820974944592308
X
/* Another fave.                                                             */
X
#define SQUAREROOTTWO 1.4142135623730950488016887242096980785696718753769480732
X
/* And here's one for those of you who are intimidated by math.              */
X
#define ONETHIRD 0.333333333333333333333333333333333333333333333333333333333333
X
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <math.h>
#ifndef NO_TIMER
#include <sys/time.h>
#endif /* not NO_TIMER */
#ifdef CPU86
#include <float.h>
#endif /* CPU86 */
#ifdef LINUX
#include <fpu_control.h>
#endif /* LINUX */
#ifdef TRILIBRARY
#include "triangle.h"
#endif /* TRILIBRARY */
X
/* A few forward declarations.                                               */
X
#ifndef TRILIBRARY
char *readline();
char *findfield();
#endif /* not TRILIBRARY */
X
/* Labels that signify the result of point location.  The result of a        */
/*   search indicates that the point falls in the interior of a triangle, on */
/*   an edge, on a vertex, or outside the mesh.                              */
X
enum locateresult {INTRIANGLE, ONEDGE, ONVERTEX, OUTSIDE};
X
/* Labels that signify the result of vertex insertion.  The result indicates */
/*   that the vertex was inserted with complete success, was inserted but    */
/*   encroaches upon a subsegment, was not inserted because it lies on a     */
/*   segment, or was not inserted because another vertex occupies the same   */
/*   location.                                                               */
X
enum insertvertexresult {SUCCESSFULVERTEX, ENCROACHINGVERTEX, VIOLATINGVERTEX,
X                         DUPLICATEVERTEX};
X
/* Labels that signify the result of direction finding.  The result          */
/*   indicates that a segment connecting the two query points falls within   */
/*   the direction triangle, along the left edge of the direction triangle,  */
/*   or along the right edge of the direction triangle.                      */
X
enum finddirectionresult {WITHIN, LEFTCOLLINEAR, RIGHTCOLLINEAR};
X
/*****************************************************************************/
/*                                                                           */
/*  The basic mesh data structures                                           */
/*                                                                           */
/*  There are three:  vertices, triangles, and subsegments (abbreviated      */
/*  `subseg').  These three data structures, linked by pointers, comprise    */
/*  the mesh.  A vertex simply represents a mesh vertex and its properties.  */
/*  A triangle is a triangle.  A subsegment is a special data structure used */
/*  to represent an impenetrable edge of the mesh (perhaps on the outer      */
/*  boundary, on the boundary of a hole, or part of an internal boundary     */
/*  separating two triangulated regions).  Subsegments represent boundaries, */
/*  defined by the user, that triangles may not lie across.                  */
/*                                                                           */
/*  A triangle consists of a list of three vertices, a list of three         */
/*  adjoining triangles, a list of three adjoining subsegments (when         */
/*  segments exist), an arbitrary number of optional user-defined            */
/*  floating-point attributes, and an optional area constraint.  The latter  */
/*  is an upper bound on the permissible area of each triangle in a region,  */
/*  used for mesh refinement.                                                */
/*                                                                           */
/*  For a triangle on a boundary of the mesh, some or all of the neighboring */
/*  triangles may not be present.  For a triangle in the interior of the     */
/*  mesh, often no neighboring subsegments are present.  Such absent         */
/*  triangles and subsegments are never represented by NULL pointers; they   */
/*  are represented by two special records:  `dummytri', the triangle that   */
/*  fills "outer space", and `dummysub', the omnipresent subsegment.         */
/*  `dummytri' and `dummysub' are used for several reasons; for instance,    */
/*  they can be dereferenced and their contents examined without violating   */
/*  protected memory.                                                        */
/*                                                                           */
/*  However, it is important to understand that a triangle includes other    */
/*  information as well.  The pointers to adjoining vertices, triangles, and */
/*  subsegments are ordered in a way that indicates their geometric relation */
/*  to each other.  Furthermore, each of these pointers contains orientation */
/*  information.  Each pointer to an adjoining triangle indicates which face */
/*  of that triangle is contacted.  Similarly, each pointer to an adjoining  */
/*  subsegment indicates which side of that subsegment is contacted, and how */
/*  the subsegment is oriented relative to the triangle.                     */
/*                                                                           */
/*  The data structure representing a subsegment may be thought to be        */
/*  abutting the edge of one or two triangle data structures:  either        */
/*  sandwiched between two triangles, or resting against one triangle on an  */
/*  exterior boundary or hole boundary.                                      */
/*                                                                           */
/*  A subsegment consists of a list of four vertices--the vertices of the    */
/*  subsegment, and the vertices of the segment it is a part of--a list of   */
/*  two adjoining subsegments, and a list of two adjoining triangles.  One   */
/*  of the two adjoining triangles may not be present (though there should   */
/*  always be one), and neighboring subsegments might not be present.        */
/*  Subsegments also store a user-defined integer "boundary marker".         */
/*  Typically, this integer is used to indicate what boundary conditions are */
/*  to be applied at that location in a finite element simulation.           */
/*                                                                           */
/*  Like triangles, subsegments maintain information about the relative      */
/*  orientation of neighboring objects.                                      */
/*                                                                           */
/*  Vertices are relatively simple.  A vertex is a list of floating-point    */
/*  numbers, starting with the x, and y coordinates, followed by an          */
/*  arbitrary number of optional user-defined floating-point attributes,     */
/*  followed by an integer boundary marker.  During the segment insertion    */
/*  phase, there is also a pointer from each vertex to a triangle that may   */
/*  contain it.  Each pointer is not always correct, but when one is, it     */
/*  speeds up segment insertion.  These pointers are assigned values once    */
/*  at the beginning of the segment insertion phase, and are not used or     */
/*  updated except during this phase.  Edge flipping during segment          */
/*  insertion will render some of them incorrect.  Hence, don't rely upon    */
/*  them for anything.                                                       */
/*                                                                           */
/*  Other than the exception mentioned above, vertices have no information   */
/*  about what triangles, subfacets, or subsegments they are linked to.      */
/*                                                                           */
/*****************************************************************************/
X
/*****************************************************************************/
/*                                                                           */
/*  Handles                                                                  */
/*                                                                           */
/*  The oriented triangle (`otri') and oriented subsegment (`osub') data     */
/*  structures defined below do not themselves store any part of the mesh.   */
/*  The mesh itself is made of `triangle's, `subseg's, and `vertex's.        */
/*                                                                           */
/*  Oriented triangles and oriented subsegments will usually be referred to  */
/*  as "handles."  A handle is essentially a pointer into the mesh; it       */
/*  allows you to "hold" one particular part of the mesh.  Handles are used  */
/*  to specify the regions in which one is traversing and modifying the mesh.*/
/*  A single `triangle' may be held by many handles, or none at all.  (The   */
/*  latter case is not a memory leak, because the triangle is still          */
/*  connected to other triangles in the mesh.)                               */
/*                                                                           */
/*  An `otri' is a handle that holds a triangle.  It holds a specific edge   */
/*  of the triangle.  An `osub' is a handle that holds a subsegment.  It     */
/*  holds either the left or right side of the subsegment.                   */
/*                                                                           */
/*  Navigation about the mesh is accomplished through a set of mesh          */
/*  manipulation primitives, further below.  Many of these primitives take   */
/*  a handle and produce a new handle that holds the mesh near the first     */
/*  handle.  Other primitives take two handles and glue the corresponding    */
/*  parts of the mesh together.  The orientation of the handles is           */
/*  important.  For instance, when two triangles are glued together by the   */
/*  bond() primitive, they are glued at the edges on which the handles lie.  */
/*                                                                           */
/*  Because vertices have no information about which triangles they are      */
/*  attached to, I commonly represent a vertex by use of a handle whose      */
/*  origin is the vertex.  A single handle can simultaneously represent a    */
/*  triangle, an edge, and a vertex.                                         */
/*                                                                           */
/*****************************************************************************/
X
/* The triangle data structure.  Each triangle contains three pointers to    */
/*   adjoining triangles, plus three pointers to vertices, plus three        */
/*   pointers to subsegments (declared below; these pointers are usually     */
/*   `dummysub').  It may or may not also contain user-defined attributes    */
/*   and/or a floating-point "area constraint."  It may also contain extra   */
/*   pointers for nodes, when the user asks for high-order elements.         */
/*   Because the size and structure of a `triangle' is not decided until     */
/*   runtime, I haven't simply declared the type `triangle' as a struct.     */
X
typedef REAL **triangle;            /* Really:  typedef triangle *triangle   */
X
/* An oriented triangle:  includes a pointer to a triangle and orientation.  */
/*   The orientation denotes an edge of the triangle.  Hence, there are      */
/*   three possible orientations.  By convention, each edge always points    */
/*   counterclockwise about the corresponding triangle.                      */
X
struct otri {
X  triangle *tri;
X  int orient;                                         /* Ranges from 0 to 2. */
};
X
/* The subsegment data structure.  Each subsegment contains two pointers to  */
/*   adjoining subsegments, plus four pointers to vertices, plus two         */
/*   pointers to adjoining triangles, plus one boundary marker, plus one     */
/*   segment number.                                                         */
X
typedef REAL **subseg;                  /* Really:  typedef subseg *subseg   */
X
/* An oriented subsegment:  includes a pointer to a subsegment and an        */
/*   orientation.  The orientation denotes a side of the edge.  Hence, there */
/*   are two possible orientations.  By convention, the edge is always       */
/*   directed so that the "side" denoted is the right side of the edge.      */
X
struct osub {
X  subseg *ss;
X  int ssorient;                                       /* Ranges from 0 to 1. */
};
X
/* The vertex data structure.  Each vertex is actually an array of REALs.    */
/*   The number of REALs is unknown until runtime.  An integer boundary      */
/*   marker, and sometimes a pointer to a triangle, is appended after the    */
/*   REALs.                                                                  */
X
typedef REAL *vertex;
X
/* A queue used to store encroached subsegments.  Each subsegment's vertices */
/*   are stored so that we can check whether a subsegment is still the same. */
X
struct badsubseg {
X  subseg encsubseg;                             /* An encroached subsegment. */
X  vertex subsegorg, subsegdest;                         /* Its two vertices. */
};
X
/* A queue used to store bad triangles.  The key is the square of the cosine */
/*   of the smallest angle of the triangle.  Each triangle's vertices are    */
/*   stored so that one can check whether a triangle is still the same.      */
X
struct badtriang {
X  triangle poortri;                       /* A skinny or too-large triangle. */
X  REAL key;                             /* cos^2 of smallest (apical) angle. */
X  vertex triangorg, triangdest, triangapex;           /* Its three vertices. */
X  struct badtriang *nexttriang;             /* Pointer to next bad triangle. */
};
X
/* A stack of triangles flipped during the most recent vertex insertion.     */
/*   The stack is used to undo the vertex insertion if the vertex encroaches */
/*   upon a subsegment.                                                      */
X
struct flipstacker {
X  triangle flippedtri;                       /* A recently flipped triangle. */
X  struct flipstacker *prevflip;               /* Previous flip in the stack. */
};
X
/* A node in a heap used to store events for the sweepline Delaunay          */
/*   algorithm.  Nodes do not point directly to their parents or children in */
/*   the heap.  Instead, each node knows its position in the heap, and can   */
/*   look up its parent and children in a separate array.  The `eventptr'    */
/*   points either to a `vertex' or to a triangle (in encoded format, so     */
/*   that an orientation is included).  In the latter case, the origin of    */
/*   the oriented triangle is the apex of a "circle event" of the sweepline  */
/*   algorithm.  To distinguish site events from circle events, all circle   */
/*   events are given an invalid (smaller than `xmin') x-coordinate `xkey'.  */
X
struct event {
X  REAL xkey, ykey;                              /* Coordinates of the event. */
X  VOID *eventptr;      /* Can be a vertex or the location of a circle event. */
X  int heapposition;              /* Marks this event's position in the heap. */
};
X
/* A node in the splay tree.  Each node holds an oriented ghost triangle     */
/*   that represents a boundary edge of the growing triangulation.  When a   */
/*   circle event covers two boundary edges with a triangle, so that they    */
/*   are no longer boundary edges, those edges are not immediately deleted   */
/*   from the tree; rather, they are lazily deleted when they are next       */
/*   encountered.  (Since only a random sample of boundary edges are kept    */
/*   in the tree, lazy deletion is faster.)  `keydest' is used to verify     */
/*   that a triangle is still the same as when it entered the splay tree; if */
/*   it has been rotated (due to a circle event), it no longer represents a  */
/*   boundary edge and should be deleted.                                    */
X
struct splaynode {
X  struct otri keyedge;                     /* Lprev of an edge on the front. */
X  vertex keydest;           /* Used to verify that splay node is still live. */
X  struct splaynode *lchild, *rchild;              /* Children in splay tree. */
};
X
/* A type used to allocate memory.  firstblock is the first block of items.  */
/*   nowblock is the block from which items are currently being allocated.   */
/*   nextitem points to the next slab of free memory for an item.            */
/*   deaditemstack is the head of a linked list (stack) of deallocated items */
/*   that can be recycled.  unallocateditems is the number of items that     */
/*   remain to be allocated from nowblock.                                   */
/*                                                                           */
/* Traversal is the process of walking through the entire list of items, and */
/*   is separate from allocation.  Note that a traversal will visit items on */
/*   the "deaditemstack" stack as well as live items.  pathblock points to   */
/*   the block currently being traversed.  pathitem points to the next item  */
/*   to be traversed.  pathitemsleft is the number of items that remain to   */
/*   be traversed in pathblock.                                              */
/*                                                                           */
/* alignbytes determines how new records should be aligned in memory.        */
/*   itembytes is the length of a record in bytes (after rounding up).       */
/*   itemsperblock is the number of items allocated at once in a single      */
/*   block.  itemsfirstblock is the number of items in the first block,      */
/*   which can vary from the others.  items is the number of currently       */
/*   allocated items.  maxitems is the maximum number of items that have     */
/*   been allocated at once; it is the current number of items plus the      */
/*   number of records kept on deaditemstack.                                */
X
struct memorypool {
X  VOID **firstblock, **nowblock;
X  VOID *nextitem;
X  VOID *deaditemstack;
X  VOID **pathblock;
X  VOID *pathitem;
X  int alignbytes;
X  int itembytes;
X  int itemsperblock;
X  int itemsfirstblock;
X  long items, maxitems;
X  int unallocateditems;
X  int pathitemsleft;
};
X
X
/* Global constants.                                                         */
X
REAL splitter;       /* Used to split REAL factors for exact multiplication. */
REAL epsilon;                             /* Floating-point machine epsilon. */
REAL resulterrbound;
REAL ccwerrboundA, ccwerrboundB, ccwerrboundC;
REAL iccerrboundA, iccerrboundB, iccerrboundC;
REAL o3derrboundA, o3derrboundB, o3derrboundC;
X
/* Random number seed is not constant, but I've made it global anyway.       */
X
unsigned long randomseed;                     /* Current random number seed. */
X
X
/* Mesh data structure.  Triangle operates on only one mesh, but the mesh    */
/*   structure is used (instead of global variables) to allow reentrancy.    */
X
struct mesh {
X
/* Variables used to allocate memory for triangles, subsegments, vertices,   */
/*   viri (triangles being eaten), encroached segments, bad (skinny or too   */
/*   large) triangles, and splay tree nodes.                                 */
X
X  struct memorypool triangles;
X  struct memorypool subsegs;
X  struct memorypool vertices;
X  struct memorypool viri;
X  struct memorypool badsubsegs;
X  struct memorypool badtriangles;
X  struct memorypool flipstackers;
X  struct memorypool splaynodes;
X
/* Variables that maintain the bad triangle queues.  The queues are          */
/*   ordered from 4095 (highest priority) to 0 (lowest priority).            */
X
X  struct badtriang *queuefront[4096];
X  struct badtriang *queuetail[4096];
X  int nextnonemptyq[4096];
X  int firstnonemptyq;
X
/* Variable that maintains the stack of recently flipped triangles.          */
X
X  struct flipstacker *lastflip;
X
/* Other variables. */
X
X  REAL xmin, xmax, ymin, ymax;                            /* x and y bounds. */
X  REAL xminextreme;      /* Nonexistent x value used as a flag in sweepline. */
X  int invertices;                               /* Number of input vertices. */
X  int inelements;                              /* Number of input triangles. */
X  int insegments;                               /* Number of input segments. */
X  int holes;                                       /* Number of input holes. */
X  int regions;                                   /* Number of input regions. */
X  int undeads;    /* Number of input vertices that don't appear in the mesh. */
X  long edges;                                     /* Number of output edges. */
X  int mesh_dim;                                /* Dimension (ought to be 2). */
X  int nextras;                           /* Number of attributes per vertex. */
X  int eextras;                         /* Number of attributes per triangle. */
X  long hullsize;                          /* Number of edges in convex hull. */
X  int steinerleft;                 /* Number of Steiner points not yet used. */
X  int vertexmarkindex;         /* Index to find boundary marker of a vertex. */
X  int vertex2triindex;     /* Index to find a triangle adjacent to a vertex. */
X  int highorderindex;  /* Index to find extra nodes for high-order elements. */
X  int elemattribindex;            /* Index to find attributes of a triangle. */
X  int areaboundindex;             /* Index to find area bound of a triangle. */
X  int checksegments;         /* Are there segments in the triangulation yet? */
X  int checkquality;                  /* Has quality triangulation begun yet? */
X  int readnodefile;                           /* Has a .node file been read? */
X  long samples;              /* Number of random samples for point location. */
X
X  long incirclecount;                 /* Number of incircle tests performed. */
X  long counterclockcount;     /* Number of counterclockwise tests performed. */
X  long orient3dcount;           /* Number of 3D orientation tests performed. */
X  long hyperbolacount;      /* Number of right-of-hyperbola tests performed. */
X  long circumcentercount;  /* Number of circumcenter calculations performed. */
X  long circletopcount;       /* Number of circle top calculations performed. */
X
/* Triangular bounding box vertices.                                         */
X
X  vertex infvertex1, infvertex2, infvertex3;
X
/* Pointer to the `triangle' that occupies all of "outer space."             */
X
X  triangle *dummytri;
X  triangle *dummytribase;    /* Keep base address so we can free() it later. */
X
/* Pointer to the omnipresent subsegment.  Referenced by any triangle or     */
/*   subsegment that isn't really connected to a subsegment at that          */
/*   location.                                                               */
X
X  subseg *dummysub;
X  subseg *dummysubbase;      /* Keep base address so we can free() it later. */
X
/* Pointer to a recently visited triangle.  Improves point location if       */
/*   proximate vertices are inserted sequentially.                           */
X
X  struct otri recenttri;
X
};                                                  /* End of `struct mesh'. */
X
X
/* Data structure for command line switches and file names.  This structure  */
/*   is used (instead of global variables) to allow reentrancy.              */
X
struct behavior {
X
/* Switches for the triangulator.                                            */
/*   poly: -p switch.  refine: -r switch.                                    */
/*   quality: -q switch.                                                     */
/*     minangle: minimum angle bound, specified after -q switch.             */
/*     goodangle: cosine squared of minangle.                                */
/*     offconstant: constant used to place off-center Steiner points.        */
/*   vararea: -a switch without number.                                      */
/*   fixedarea: -a switch with number.                                       */
/*     maxarea: maximum area bound, specified after -a switch.               */
/*   usertest: -u switch.                                                    */
/*   regionattrib: -A switch.  convex: -c switch.                            */
/*   weighted: 1 for -w switch, 2 for -W switch.  jettison: -j switch        */
/*   firstnumber: inverse of -z switch.  All items are numbered starting     */
/*     from `firstnumber'.                                                   */
/*   edgesout: -e switch.  voronoi: -v switch.                               */
/*   neighbors: -n switch.  geomview: -g switch.                             */
/*   nobound: -B switch.  nopolywritten: -P switch.                          */
/*   nonodewritten: -N switch.  noelewritten: -E switch.                     */
/*   noiterationnum: -I switch.  noholes: -O switch.                         */
/*   noexact: -X switch.                                                     */
/*   order: element order, specified after -o switch.                        */
/*   nobisect: count of how often -Y switch is selected.                     */
/*   steiner: maximum number of Steiner points, specified after -S switch.   */
/*   incremental: -i switch.  sweepline: -F switch.                          */
/*   dwyer: inverse of -l switch.                                            */
/*   splitseg: -s switch.                                                    */
/*   conformdel: -D switch.  docheck: -C switch.                             */
/*   quiet: -Q switch.  verbose: count of how often -V switch is selected.   */
/*   usesegments: -p, -r, -q, or -c switch; determines whether segments are  */
/*     used at all.                                                          */
/*                                                                           */
/* Read the instructions to find out the meaning of these switches.          */
X
X  int poly, refine, quality, vararea, fixedarea, usertest;
X  int regionattrib, convex, weighted, jettison;
X  int firstnumber;
X  int edgesout, voronoi, neighbors, geomview;
X  int nobound, nopolywritten, nonodewritten, noelewritten, noiterationnum;
X  int noholes, noexact, conformdel;
X  int incremental, sweepline, dwyer;
X  int splitseg;
X  int docheck;
X  int quiet, verbose;
X  int usesegments;
X  int order;
X  int nobisect;
X  int steiner;
X  REAL minangle, goodangle, offconstant;
X  REAL maxarea;
X
/* Variables for file names.                                                 */
X
#ifndef TRILIBRARY
X  char innodefilename[FILENAMESIZE];
X  char inelefilename[FILENAMESIZE];
X  char inpolyfilename[FILENAMESIZE];
X  char areafilename[FILENAMESIZE];
X  char outnodefilename[FILENAMESIZE];
X  char outelefilename[FILENAMESIZE];
X  char outpolyfilename[FILENAMESIZE];
X  char edgefilename[FILENAMESIZE];
X  char vnodefilename[FILENAMESIZE];
X  char vedgefilename[FILENAMESIZE];
X  char neighborfilename[FILENAMESIZE];
X  char offfilename[FILENAMESIZE];
#endif /* not TRILIBRARY */
X
};                                              /* End of `struct behavior'. */
X
X
/*****************************************************************************/
/*                                                                           */
/*  Mesh manipulation primitives.  Each triangle contains three pointers to  */
/*  other triangles, with orientations.  Each pointer points not to the      */
/*  first byte of a triangle, but to one of the first three bytes of a       */
/*  triangle.  It is necessary to extract both the triangle itself and the   */
/*  orientation.  To save memory, I keep both pieces of information in one   */
/*  pointer.  To make this possible, I assume that all triangles are aligned */
/*  to four-byte boundaries.  The decode() routine below decodes a pointer,  */
/*  extracting an orientation (in the range 0 to 2) and a pointer to the     */
/*  beginning of a triangle.  The encode() routine compresses a pointer to a */
/*  triangle and an orientation into a single pointer.  My assumptions that  */
/*  triangles are four-byte-aligned and that the `unsigned long' type is     */
/*  long enough to hold a pointer are two of the few kludges in this program.*/
/*                                                                           */
/*  Subsegments are manipulated similarly.  A pointer to a subsegment        */
/*  carries both an address and an orientation in the range 0 to 1.          */
/*                                                                           */
/*  The other primitives take an oriented triangle or oriented subsegment,   */
/*  and return an oriented triangle or oriented subsegment or vertex; or     */
/*  they change the connections in the data structure.                       */
/*                                                                           */
/*  Below, triangles and subsegments are denoted by their vertices.  The     */
/*  triangle abc has origin (org) a, destination (dest) b, and apex (apex)   */
/*  c.  These vertices occur in counterclockwise order about the triangle.   */
/*  The handle abc may simultaneously denote vertex a, edge ab, and triangle */
/*  abc.                                                                     */
/*                                                                           */
/*  Similarly, the subsegment ab has origin (sorg) a and destination (sdest) */
/*  b.  If ab is thought to be directed upward (with b directly above a),    */
/*  then the handle ab is thought to grasp the right side of ab, and may     */
/*  simultaneously denote vertex a and edge ab.                              */
/*                                                                           */
/*  An asterisk (*) denotes a vertex whose identity is unknown.              */
/*                                                                           */
/*  Given this notation, a partial list of mesh manipulation primitives      */
/*  follows.                                                                 */
/*                                                                           */
/*                                                                           */
/*  For triangles:                                                           */
/*                                                                           */
/*  sym:  Find the abutting triangle; same edge.                             */
/*  sym(abc) -> ba*                                                          */
/*                                                                           */
/*  lnext:  Find the next edge (counterclockwise) of a triangle.             */
/*  lnext(abc) -> bca                                                        */
/*                                                                           */
/*  lprev:  Find the previous edge (clockwise) of a triangle.                */
/*  lprev(abc) -> cab                                                        */
/*                                                                           */
/*  onext:  Find the next edge counterclockwise with the same origin.        */
/*  onext(abc) -> ac*                                                        */
/*                                                                           */
/*  oprev:  Find the next edge clockwise with the same origin.               */
/*  oprev(abc) -> a*b                                                        */
/*                                                                           */
/*  dnext:  Find the next edge counterclockwise with the same destination.   */
/*  dnext(abc) -> *ba                                                        */
/*                                                                           */
/*  dprev:  Find the next edge clockwise with the same destination.          */
/*  dprev(abc) -> cb*                                                        */
/*                                                                           */
/*  rnext:  Find the next edge (counterclockwise) of the adjacent triangle.  */
/*  rnext(abc) -> *a*                                                        */
/*                                                                           */
/*  rprev:  Find the previous edge (clockwise) of the adjacent triangle.     */
/*  rprev(abc) -> b**                                                        */
/*                                                                           */
/*  org:  Origin          dest:  Destination          apex:  Apex            */
/*  org(abc) -> a         dest(abc) -> b              apex(abc) -> c         */
/*                                                                           */
/*  bond:  Bond two triangles together at the resepective handles.           */
/*  bond(abc, bad)                                                           */
/*                                                                           */
/*                                                                           */
/*  For subsegments:                                                         */
/*                                                                           */
/*  ssym:  Reverse the orientation of a subsegment.                          */
/*  ssym(ab) -> ba                                                           */
/*                                                                           */
/*  spivot:  Find adjoining subsegment with the same origin.                 */
/*  spivot(ab) -> a*                                                         */
/*                                                                           */
/*  snext:  Find next subsegment in sequence.                                */
/*  snext(ab) -> b*                                                          */
/*                                                                           */
/*  sorg:  Origin                      sdest:  Destination                   */
/*  sorg(ab) -> a                      sdest(ab) -> b                        */
/*                                                                           */
/*  sbond:  Bond two subsegments together at the respective origins.         */
/*  sbond(ab, ac)                                                            */
/*                                                                           */
/*                                                                           */
/*  For interacting tetrahedra and subfacets:                                */
/*                                                                           */
/*  tspivot:  Find a subsegment abutting a triangle.                         */
/*  tspivot(abc) -> ba                                                       */
/*                                                                           */
/*  stpivot:  Find a triangle abutting a subsegment.                         */
/*  stpivot(ab) -> ba*                                                       */
/*                                                                           */
/*  tsbond:  Bond a triangle to a subsegment.                                */
/*  tsbond(abc, ba)                                                          */
/*                                                                           */
/*****************************************************************************/
X
/********* Mesh manipulation primitives begin here                   *********/
/**                                                                         **/
/**                                                                         **/
X
/* Fast lookup arrays to speed some of the mesh manipulation primitives.     */
X
int plus1mod3[3] = {1, 2, 0};
int minus1mod3[3] = {2, 0, 1};
X
/********* Primitives for triangles                                  *********/
/*                                                                           */
/*                                                                           */
X
/* decode() converts a pointer to an oriented triangle.  The orientation is  */
/*   extracted from the two least significant bits of the pointer.           */
X
#define decode(ptr, otri)                                                     \
X  (otri).orient = (int) ((unsigned long) (ptr) & (unsigned long) 3l);         \
X  (otri).tri = (triangle *)                                                   \
X                  ((unsigned long) (ptr) ^ (unsigned long) (otri).orient)
X
/* encode() compresses an oriented triangle into a single pointer.  It       */
/*   relies on the assumption that all triangles are aligned to four-byte    */
/*   boundaries, so the two least significant bits of (otri).tri are zero.   */
X
#define encode(otri)                                                          \
X  (triangle) ((unsigned long) (otri).tri | (unsigned long) (otri).orient)
X
/* The following handle manipulation primitives are all described by Guibas  */
/*   and Stolfi.  However, Guibas and Stolfi use an edge-based data          */
/*   structure, whereas I use a triangle-based data structure.               */
X
/* sym() finds the abutting triangle, on the same edge.  Note that the edge  */
/*   direction is necessarily reversed, because the handle specified by an   */
/*   oriented triangle is directed counterclockwise around the triangle.     */
X
#define sym(otri1, otri2)                                                     \
X  ptr = (otri1).tri[(otri1).orient];                                          \
X  decode(ptr, otri2);
X
#define symself(otri)                                                         \
X  ptr = (otri).tri[(otri).orient];                                            \
X  decode(ptr, otri);
X
/* lnext() finds the next edge (counterclockwise) of a triangle.             */
X
#define lnext(otri1, otri2)                                                   \
X  (otri2).tri = (otri1).tri;                                                  \
X  (otri2).orient = plus1mod3[(otri1).orient]
X
#define lnextself(otri)                                                       \
X  (otri).orient = plus1mod3[(otri).orient]
X
/* lprev() finds the previous edge (clockwise) of a triangle.                */
X
#define lprev(otri1, otri2)                                                   \
X  (otri2).tri = (otri1).tri;                                                  \
X  (otri2).orient = minus1mod3[(otri1).orient]
X
#define lprevself(otri)                                                       \
X  (otri).orient = minus1mod3[(otri).orient]
X
/* onext() spins counterclockwise around a vertex; that is, it finds the     */
/*   next edge with the same origin in the counterclockwise direction.  This */
/*   edge is part of a different triangle.                                   */
X
#define onext(otri1, otri2)                                                   \
X  lprev(otri1, otri2);                                                        \
X  symself(otri2);
X
#define onextself(otri)                                                       \
X  lprevself(otri);                                                            \
X  symself(otri);
X
/* oprev() spins clockwise around a vertex; that is, it finds the next edge  */
/*   with the same origin in the clockwise direction.  This edge is part of  */
/*   a different triangle.                                                   */
X
#define oprev(otri1, otri2)                                                   \
X  sym(otri1, otri2);                                                          \
X  lnextself(otri2);
X
#define oprevself(otri)                                                       \
X  symself(otri);                                                              \
X  lnextself(otri);
X
/* dnext() spins counterclockwise around a vertex; that is, it finds the     */
/*   next edge with the same destination in the counterclockwise direction.  */
/*   This edge is part of a different triangle.                              */
X
#define dnext(otri1, otri2)                                                   \
X  sym(otri1, otri2);                                                          \
X  lprevself(otri2);
X
#define dnextself(otri)                                                       \
X  symself(otri);                                                              \
X  lprevself(otri);
X
/* dprev() spins clockwise around a vertex; that is, it finds the next edge  */
/*   with the same destination in the clockwise direction.  This edge is     */
/*   part of a different triangle.                                           */
X
#define dprev(otri1, otri2)                                                   \
X  lnext(otri1, otri2);                                                        \
X  symself(otri2);
X
#define dprevself(otri)                                                       \
X  lnextself(otri);                                                            \
X  symself(otri);
X
/* rnext() moves one edge counterclockwise about the adjacent triangle.      */
/*   (It's best understood by reading Guibas and Stolfi.  It involves        */
/*   changing triangles twice.)                                              */
X
#define rnext(otri1, otri2)                                                   \
X  sym(otri1, otri2);                                                          \
X  lnextself(otri2);                                                           \
X  symself(otri2);
X
#define rnextself(otri)                                                       \
X  symself(otri);                                                              \
X  lnextself(otri);                                                            \
X  symself(otri);
X
/* rprev() moves one edge clockwise about the adjacent triangle.             */
/*   (It's best understood by reading Guibas and Stolfi.  It involves        */
/*   changing triangles twice.)                                              */
X
#define rprev(otri1, otri2)                                                   \
X  sym(otri1, otri2);                                                          \
X  lprevself(otri2);                                                           \
X  symself(otri2);
X
#define rprevself(otri)                                                       \
X  symself(otri);                                                              \
X  lprevself(otri);                                                            \
X  symself(otri);
X
/* These primitives determine or set the origin, destination, or apex of a   */
/* triangle.                                                                 */
X
#define org(otri, vertexptr)                                                  \
X  vertexptr = (vertex) (otri).tri[plus1mod3[(otri).orient] + 3]
X
#define dest(otri, vertexptr)                                                 \
X  vertexptr = (vertex) (otri).tri[minus1mod3[(otri).orient] + 3]
X
#define apex(otri, vertexptr)                                                 \
X  vertexptr = (vertex) (otri).tri[(otri).orient + 3]
X
#define setorg(otri, vertexptr)                                               \
X  (otri).tri[plus1mod3[(otri).orient] + 3] = (triangle) vertexptr
X
#define setdest(otri, vertexptr)                                              \
X  (otri).tri[minus1mod3[(otri).orient] + 3] = (triangle) vertexptr
X
#define setapex(otri, vertexptr)                                              \
X  (otri).tri[(otri).orient + 3] = (triangle) vertexptr
X
/* Bond two triangles together.                                              */
X
#define bond(otri1, otri2)                                                    \
X  (otri1).tri[(otri1).orient] = encode(otri2);                                \
X  (otri2).tri[(otri2).orient] = encode(otri1)
X
/* Dissolve a bond (from one side).  Note that the other triangle will still */
/*   think it's connected to this triangle.  Usually, however, the other     */
/*   triangle is being deleted entirely, or bonded to another triangle, so   */
/*   it doesn't matter.                                                      */
X
#define dissolve(otri)                                                        \
X  (otri).tri[(otri).orient] = (triangle) m->dummytri
X
/* Copy an oriented triangle.                                                */
X
#define otricopy(otri1, otri2)                                                \
X  (otri2).tri = (otri1).tri;                                                  \
X  (otri2).orient = (otri1).orient
X
/* Test for equality of oriented triangles.                                  */
X
#define otriequal(otri1, otri2)                                               \
X  (((otri1).tri == (otri2).tri) &&                                            \
X   ((otri1).orient == (otri2).orient))
X
/* Primitives to infect or cure a triangle with the virus.  These rely on    */
/*   the assumption that all subsegments are aligned to four-byte boundaries.*/
X
#define infect(otri)                                                          \
X  (otri).tri[6] = (triangle)                                                  \
X                    ((unsigned long) (otri).tri[6] | (unsigned long) 2l)
X
#define uninfect(otri)                                                        \
X  (otri).tri[6] = (triangle)                                                  \
X                    ((unsigned long) (otri).tri[6] & ~ (unsigned long) 2l)
X
/* Test a triangle for viral infection.                                      */
X
#define infected(otri)                                                        \
X  (((unsigned long) (otri).tri[6] & (unsigned long) 2l) != 0l)
X
/* Check or set a triangle's attributes.                                     */
X
#define elemattribute(otri, attnum)                                           \
X  ((REAL *) (otri).tri)[m->elemattribindex + (attnum)]
X
#define setelemattribute(otri, attnum, value)                                 \
X  ((REAL *) (otri).tri)[m->elemattribindex + (attnum)] = value
X
/* Check or set a triangle's maximum area bound.                             */
X
#define areabound(otri)  ((REAL *) (otri).tri)[m->areaboundindex]
X
#define setareabound(otri, value)                                             \
X  ((REAL *) (otri).tri)[m->areaboundindex] = value
X
/* Check or set a triangle's deallocation.  Its second pointer is set to     */
/*   NULL to indicate that it is not allocated.  (Its first pointer is used  */
/*   for the stack of dead items.)  Its fourth pointer (its first vertex)    */
/*   is set to NULL in case a `badtriang' structure points to it.            */
X
#define deadtri(tria)  ((tria)[1] == (triangle) NULL)
X
#define killtri(tria)                                                         \
X  (tria)[1] = (triangle) NULL;                                                \
X  (tria)[3] = (triangle) NULL
X
/********* Primitives for subsegments                                *********/
/*                                                                           */
/*                                                                           */
X
/* sdecode() converts a pointer to an oriented subsegment.  The orientation  */
/*   is extracted from the least significant bit of the pointer.  The two    */
/*   least significant bits (one for orientation, one for viral infection)   */
/*   are masked out to produce the real pointer.                             */
X
#define sdecode(sptr, osub)                                                   \
X  (osub).ssorient = (int) ((unsigned long) (sptr) & (unsigned long) 1l);      \
X  (osub).ss = (subseg *)                                                      \
X              ((unsigned long) (sptr) & ~ (unsigned long) 3l)
X
/* sencode() compresses an oriented subsegment into a single pointer.  It    */
/*   relies on the assumption that all subsegments are aligned to two-byte   */
/*   boundaries, so the least significant bit of (osub).ss is zero.          */
X
#define sencode(osub)                                                         \
X  (subseg) ((unsigned long) (osub).ss | (unsigned long) (osub).ssorient)
X
/* ssym() toggles the orientation of a subsegment.                           */
X
#define ssym(osub1, osub2)                                                    \
X  (osub2).ss = (osub1).ss;                                                    \
X  (osub2).ssorient = 1 - (osub1).ssorient
X
#define ssymself(osub)                                                        \
X  (osub).ssorient = 1 - (osub).ssorient
X
/* spivot() finds the other subsegment (from the same segment) that shares   */
/*   the same origin.                                                        */
X
#define spivot(osub1, osub2)                                                  \
X  sptr = (osub1).ss[(osub1).ssorient];                                        \
X  sdecode(sptr, osub2)
X
#define spivotself(osub)                                                      \
X  sptr = (osub).ss[(osub).ssorient];                                          \
X  sdecode(sptr, osub)
X
/* snext() finds the next subsegment (from the same segment) in sequence;    */
/*   one whose origin is the input subsegment's destination.                 */
X
#define snext(osub1, osub2)                                                   \
X  sptr = (osub1).ss[1 - (osub1).ssorient];                                    \
X  sdecode(sptr, osub2)
X
#define snextself(osub)                                                       \
X  sptr = (osub).ss[1 - (osub).ssorient];                                      \
X  sdecode(sptr, osub)
X
/* These primitives determine or set the origin or destination of a          */
/*   subsegment or the segment that includes it.                             */
X
#define sorg(osub, vertexptr)                                                 \
X  vertexptr = (vertex) (osub).ss[2 + (osub).ssorient]
X
#define sdest(osub, vertexptr)                                                \
X  vertexptr = (vertex) (osub).ss[3 - (osub).ssorient]
X
#define setsorg(osub, vertexptr)                                              \
X  (osub).ss[2 + (osub).ssorient] = (subseg) vertexptr
X
#define setsdest(osub, vertexptr)                                             \
X  (osub).ss[3 - (osub).ssorient] = (subseg) vertexptr
X
#define segorg(osub, vertexptr)                                               \
X  vertexptr = (vertex) (osub).ss[4 + (osub).ssorient]
X
#define segdest(osub, vertexptr)                                              \
X  vertexptr = (vertex) (osub).ss[5 - (osub).ssorient]
X
#define setsegorg(osub, vertexptr)                                            \
X  (osub).ss[4 + (osub).ssorient] = (subseg) vertexptr
X
#define setsegdest(osub, vertexptr)                                           \
X  (osub).ss[5 - (osub).ssorient] = (subseg) vertexptr
X
/* These primitives read or set a boundary marker.  Boundary markers are     */
/*   used to hold user-defined tags for setting boundary conditions in       */
/*   finite element solvers.                                                 */
X
#define mark(osub)  (* (int *) ((osub).ss + 8))
X
#define setmark(osub, value)                                                  \
X  * (int *) ((osub).ss + 8) = value
X
/* Bond two subsegments together.                                            */
X
#define sbond(osub1, osub2)                                                   \
X  (osub1).ss[(osub1).ssorient] = sencode(osub2);                              \
X  (osub2).ss[(osub2).ssorient] = sencode(osub1)
X
/* Dissolve a subsegment bond (from one side).  Note that the other          */
/*   subsegment will still think it's connected to this subsegment.          */
X
#define sdissolve(osub)                                                       \
X  (osub).ss[(osub).ssorient] = (subseg) m->dummysub
X
/* Copy a subsegment.                                                        */
X
#define subsegcopy(osub1, osub2)                                              \
X  (osub2).ss = (osub1).ss;                                                    \
X  (osub2).ssorient = (osub1).ssorient
X
/* Test for equality of subsegments.                                         */
X
#define subsegequal(osub1, osub2)                                             \
X  (((osub1).ss == (osub2).ss) &&                                              \
X   ((osub1).ssorient == (osub2).ssorient))
X
/* Check or set a subsegment's deallocation.  Its second pointer is set to   */
/*   NULL to indicate that it is not allocated.  (Its first pointer is used  */
/*   for the stack of dead items.)  Its third pointer (its first vertex)     */
/*   is set to NULL in case a `badsubseg' structure points to it.            */
X
#define deadsubseg(sub)  ((sub)[1] == (subseg) NULL)
X
#define killsubseg(sub)                                                       \
X  (sub)[1] = (subseg) NULL;                                                   \
X  (sub)[2] = (subseg) NULL
X
/********* Primitives for interacting triangles and subsegments      *********/
/*                                                                           */
/*                                                                           */
X
/* tspivot() finds a subsegment abutting a triangle.                         */
X
#define tspivot(otri, osub)                                                   \
X  sptr = (subseg) (otri).tri[6 + (otri).orient];                              \
X  sdecode(sptr, osub)
X
/* stpivot() finds a triangle abutting a subsegment.  It requires that the   */
/*   variable `ptr' of type `triangle' be defined.                           */
X
#define stpivot(osub, otri)                                                   \
X  ptr = (triangle) (osub).ss[6 + (osub).ssorient];                            \
X  decode(ptr, otri)
X
/* Bond a triangle to a subsegment.                                          */
X
#define tsbond(otri, osub)                                                    \
X  (otri).tri[6 + (otri).orient] = (triangle) sencode(osub);                   \
X  (osub).ss[6 + (osub).ssorient] = (subseg) encode(otri)
X
/* Dissolve a bond (from the triangle side).                                 */
X
#define tsdissolve(otri)                                                      \
X  (otri).tri[6 + (otri).orient] = (triangle) m->dummysub
X
/* Dissolve a bond (from the subsegment side).                               */
X
#define stdissolve(osub)                                                      \
X  (osub).ss[6 + (osub).ssorient] = (subseg) m->dummytri
X
/********* Primitives for vertices                                   *********/
/*                                                                           */
/*                                                                           */
X
#define vertexmark(vx)  ((int *) (vx))[m->vertexmarkindex]
X
#define setvertexmark(vx, value)                                              \
X  ((int *) (vx))[m->vertexmarkindex] = value
X
#define vertextype(vx)  ((int *) (vx))[m->vertexmarkindex + 1]
X
#define setvertextype(vx, value)                                              \
X  ((int *) (vx))[m->vertexmarkindex + 1] = value
X
#define vertex2tri(vx)  ((triangle *) (vx))[m->vertex2triindex]
X
#define setvertex2tri(vx, value)                                              \
X  ((triangle *) (vx))[m->vertex2triindex] = value
X
/**                                                                         **/
/**                                                                         **/
/********* Mesh manipulation primitives end here                     *********/
X
/********* User-defined triangle evaluation routine begins here      *********/
/**                                                                         **/
/**                                                                         **/
X
/*****************************************************************************/
/*                                                                           */
/*  triunsuitable()   Determine if a triangle is unsuitable, and thus must   */
/*                    be further refined.                                    */
/*                                                                           */
/*  You may write your own procedure that decides whether or not a selected  */
/*  triangle is too big (and needs to be refined).  There are two ways to do */
/*  this.                                                                    */
/*                                                                           */
/*  (1)  Modify the procedure `triunsuitable' below, then recompile          */
/*  Triangle.                                                                */
/*                                                                           */
/*  (2)  Define the symbol EXTERNAL_TEST (either by adding the definition    */
/*  to this file, or by using the appropriate compiler switch).  This way,   */
/*  you can compile triangle.c separately from your test.  Write your own    */
/*  `triunsuitable' procedure in a separate C file (using the same prototype */
/*  as below).  Compile it and link the object code with triangle.o.         */
/*                                                                           */
/*  This procedure returns 1 if the triangle is too large and should be      */
/*  refined; 0 otherwise.                                                    */
/*                                                                           */
/*****************************************************************************/
X
#ifdef EXTERNAL_TEST
X
int triunsuitable();
X
#else /* not EXTERNAL_TEST */
X
#ifdef ANSI_DECLARATORS
int triunsuitable(vertex triorg, vertex tridest, vertex triapex, REAL area)
#else /* not ANSI_DECLARATORS */
int triunsuitable(triorg, tridest, triapex, area)
vertex triorg;                              /* The triangle's origin vertex. */
vertex tridest;                        /* The triangle's destination vertex. */
vertex triapex;                               /* The triangle's apex vertex. */
REAL area;                                      /* The area of the triangle. */
#endif /* not ANSI_DECLARATORS */
X
{
X  REAL dxoa, dxda, dxod;
X  REAL dyoa, dyda, dyod;
X  REAL oalen, dalen, odlen;
X  REAL maxlen;
X
X  dxoa = triorg[0] - triapex[0];
X  dyoa = triorg[1] - triapex[1];
X  dxda = tridest[0] - triapex[0];
X  dyda = tridest[1] - triapex[1];
X  dxod = triorg[0] - tridest[0];
X  dyod = triorg[1] - tridest[1];
X  /* Find the squares of the lengths of the triangle's three edges. */
X  oalen = dxoa * dxoa + dyoa * dyoa;
X  dalen = dxda * dxda + dyda * dyda;
X  odlen = dxod * dxod + dyod * dyod;
X  /* Find the square of the length of the longest edge. */
X  maxlen = (dalen > oalen) ? dalen : oalen;
X  maxlen = (odlen > maxlen) ? odlen : maxlen;
X
X  if (maxlen > 0.05 * (triorg[0] * triorg[0] + triorg[1] * triorg[1]) + 0.02) {
X    return 1;
X  } else {
X    return 0;
X  }
}
X
#endif /* not EXTERNAL_TEST */
X
/**                                                                         **/
/**                                                                         **/
/********* User-defined triangle evaluation routine ends here        *********/
X
/********* Memory allocation and program exit wrappers begin here    *********/
/**                                                                         **/
/**                                                                         **/
X
#ifdef ANSI_DECLARATORS
void triexit(int status)
#else /* not ANSI_DECLARATORS */
void triexit(status)
int status;
#endif /* not ANSI_DECLARATORS */
X
{
X  exit(status);
}
X
#ifdef ANSI_DECLARATORS
VOID *trimalloc(int size)
#else /* not ANSI_DECLARATORS */
VOID *trimalloc(size)
int size;
#endif /* not ANSI_DECLARATORS */
X
{
X  VOID *memptr;
X
X  memptr = (VOID *) malloc((unsigned int) size);
X  if (memptr == (VOID *) NULL) {
X    printf("Error:  Out of memory.\n");
X    triexit(1);
X  }
X  return(memptr);
}
X
#ifdef ANSI_DECLARATORS
void trifree(VOID *memptr)
#else /* not ANSI_DECLARATORS */
void trifree(memptr)
VOID *memptr;
#endif /* not ANSI_DECLARATORS */
X
{
X  free(memptr);
}
X
/**                                                                         **/
/**                                                                         **/
/********* Memory allocation and program exit wrappers end here      *********/
X
/********* User interaction routines begin here                      *********/
/**                                                                         **/
/**                                                                         **/
X
/*****************************************************************************/
/*                                                                           */
/*  syntax()   Print list of command line switches.                          */
/*                                                                           */
/*****************************************************************************/
X
#ifndef TRILIBRARY
X
void syntax()
{
#ifdef CDT_ONLY
#ifdef REDUCED
X  printf("triangle [-pAcjevngBPNEIOXzo_lQVh] input_file\n");
#else /* not REDUCED */
X  printf("triangle [-pAcjevngBPNEIOXzo_iFlCQVh] input_file\n");
#endif /* not REDUCED */
#else /* not CDT_ONLY */
#ifdef REDUCED
X  printf("triangle [-prq__a__uAcDjevngBPNEIOXzo_YS__lQVh] input_file\n");
#else /* not REDUCED */
X  printf("triangle [-prq__a__uAcDjevngBPNEIOXzo_YS__iFlsCQVh] input_file\n");
#endif /* not REDUCED */
#endif /* not CDT_ONLY */
X
X  printf("    -p  Triangulates a Planar Straight Line Graph (.poly file).\n");
#ifndef CDT_ONLY
X  printf("    -r  Refines a previously generated mesh.\n");
X  printf(
X    "    -q  Quality mesh generation.  A minimum angle may be specified.\n");
X  printf("    -a  Applies a maximum triangle area constraint.\n");
X  printf("    -u  Applies a user-defined triangle constraint.\n");
#endif /* not CDT_ONLY */
X  printf(
X    "    -A  Applies attributes to identify triangles in certain regions.\n");
X  printf("    -c  Encloses the convex hull with segments.\n");
#ifndef CDT_ONLY
X  printf("    -D  Conforming Delaunay:  all triangles are truly Delaunay.\n");
#endif /* not CDT_ONLY */
/*
X  printf("    -w  Weighted Delaunay triangulation.\n");
X  printf("    -W  Regular triangulation (lower hull of a height field).\n");
*/
X  printf("    -j  Jettison unused vertices from output .node file.\n");
X  printf("    -e  Generates an edge list.\n");
X  printf("    -v  Generates a Voronoi diagram.\n");
X  printf("    -n  Generates a list of triangle neighbors.\n");
X  printf("    -g  Generates an .off file for Geomview.\n");
X  printf("    -B  Suppresses output of boundary information.\n");
X  printf("    -P  Suppresses output of .poly file.\n");
X  printf("    -N  Suppresses output of .node file.\n");
X  printf("    -E  Suppresses output of .ele file.\n");
X  printf("    -I  Suppresses mesh iteration numbers.\n");
X  printf("    -O  Ignores holes in .poly file.\n");
X  printf("    -X  Suppresses use of exact arithmetic.\n");
X  printf("    -z  Numbers all items starting from zero (rather than one).\n");
X  printf("    -o2 Generates second-order subparametric elements.\n");
#ifndef CDT_ONLY
X  printf("    -Y  Suppresses boundary segment splitting.\n");
X  printf("    -S  Specifies maximum number of added Steiner points.\n");
#endif /* not CDT_ONLY */
#ifndef REDUCED
X  printf("    -i  Uses incremental method, rather than divide-and-conquer.\n");
X  printf("    -F  Uses Fortune's sweepline algorithm, rather than d-and-c.\n");
#endif /* not REDUCED */
X  printf("    -l  Uses vertical cuts only, rather than alternating cuts.\n");
#ifndef REDUCED
#ifndef CDT_ONLY
X  printf(
X    "    -s  Force segments into mesh by splitting (instead of using CDT).\n");
#endif /* not CDT_ONLY */
X  printf("    -C  Check consistency of final mesh.\n");
#endif /* not REDUCED */
X  printf("    -Q  Quiet:  No terminal output except errors.\n");
X  printf("    -V  Verbose:  Detailed information on what I'm doing.\n");
X  printf("    -h  Help:  Detailed instructions for Triangle.\n");
X  triexit(0);
}
X
#endif /* not TRILIBRARY */
X
/*****************************************************************************/
/*                                                                           */
/*  info()   Print out complete instructions.                                */
/*                                                                           */
/*****************************************************************************/
X
#ifndef TRILIBRARY
X
void info()
{
X  printf("Triangle\n");
X  printf(
"A Two-Dimensional Quality Mesh Generator and Delaunay Triangulator.\n");
X  printf("Version 1.6\n\n");
X  printf(
"Copyright 1993, 1995, 1997, 1998, 2002, 2005 Jonathan Richard Shewchuk\n");
X  printf("2360 Woolsey #H / Berkeley, California 94705-1927\n");
X  printf("Bugs/comments to jrs@cs.berkeley.edu\n");
X  printf(
"Created as part of the Quake project (tools for earthquake simulation).\n");
X  printf(
"Supported in part by NSF Grant CMS-9318163 and an NSERC 1967 Scholarship.\n");
X  printf("There is no warranty whatsoever.  Use at your own risk.\n");
#ifdef SINGLE
X  printf("This executable is compiled for single precision arithmetic.\n\n\n");
#else /* not SINGLE */
X  printf("This executable is compiled for double precision arithmetic.\n\n\n");
#endif /* not SINGLE */
X  printf(
"Triangle generates exact Delaunay triangulations, constrained Delaunay\n");
X  printf(
"triangulations, conforming Delaunay triangulations, Voronoi diagrams, and\n");
X  printf(
"high-quality triangular meshes.  The latter can be generated with no small\n"
);
X  printf(
"or large angles, and are thus suitable for finite element analysis.  If no\n"
);
X  printf(
"command line switch is specified, your .node input file is read, and the\n");
X  printf(
"Delaunay triangulation is returned in .node and .ele output files.  The\n");
X  printf("command syntax is:\n\n");
X  printf("triangle [-prq__a__uAcDjevngBPNEIOXzo_YS__iFlsCQVh] input_file\n\n");
X  printf(
"Underscores indicate that numbers may optionally follow certain switches.\n");
X  printf(
"Do not leave any space between a switch and its numeric parameter.\n");
X  printf(
"input_file must be a file with extension .node, or extension .poly if the\n");
X  printf(
"-p switch is used.  If -r is used, you must supply .node and .ele files,\n");
X  printf(
"and possibly a .poly file and an .area file as well.  The formats of these\n"
);
X  printf("files are described below.\n\n");
X  printf("Command Line Switches:\n\n");
X  printf(
"    -p  Reads a Planar Straight Line Graph (.poly file), which can specify\n"
);
X  printf(
"        vertices, segments, holes, regional attributes, and regional area\n");
X  printf(
"        constraints.  Generates a constrained Delaunay triangulation (CDT)\n"
);
X  printf(
"        fitting the input; or, if -s, -q, -a, or -u is used, a conforming\n");
X  printf(
"        constrained Delaunay triangulation (CCDT).  If you want a truly\n");
X  printf(
"        Delaunay (not just constrained Delaunay) triangulation, use -D as\n");
X  printf(
"        well.  When -p is not used, Triangle reads a .node file by default.\n"
);
X  printf(
"    -r  Refines a previously generated mesh.  The mesh is read from a .node\n"
);
X  printf(
"        file and an .ele file.  If -p is also used, a .poly file is read\n");
X  printf(
"        and used to constrain segments in the mesh.  If -a is also used\n");
X  printf(
"        (with no number following), an .area file is read and used to\n");
X  printf(
"        impose area constraints on the mesh.  Further details on refinement\n"
);
X  printf("        appear below.\n");
X  printf(
"    -q  Quality mesh generation by Delaunay refinement (a hybrid of Paul\n");
X  printf(
"        Chew's and Jim Ruppert's algorithms).  Adds vertices to the mesh to\n"
);
X  printf(
"        ensure that all angles are between 20 and 140 degrees.  An\n");
X  printf(
"        alternative bound on the minimum angle, replacing 20 degrees, may\n");
X  printf(
"        be specified after the `q'.  The specified angle may include a\n");
X  printf(
"        decimal point, but not exponential notation.  Note that a bound of\n"
);
X  printf(
"        theta degrees on the smallest angle also implies a bound of\n");
X  printf(
"        (180 - 2 theta) on the largest angle.  If the minimum angle is 28.6\n"
);
X  printf(
"        degrees or smaller, Triangle is mathematically guaranteed to\n");
X  printf(
"        terminate (assuming infinite precision arithmetic--Triangle may\n");
X  printf(
"        fail to terminate if you run out of precision).  In practice,\n");
X  printf(
"        Triangle often succeeds for minimum angles up to 34 degrees.  For\n");
X  printf(
"        some meshes, however, you might need to reduce the minimum angle to\n"
);
X  printf(
"        avoid problems associated with insufficient floating-point\n");
X  printf("        precision.\n");
X  printf(
"    -a  Imposes a maximum triangle area.  If a number follows the `a', no\n");
X  printf(
"        triangle is generated whose area is larger than that number.  If no\n"
);
X  printf(
"        number is specified, an .area file (if -r is used) or .poly file\n");
X  printf(
"        (if -r is not used) specifies a set of maximum area constraints.\n");
X  printf(
"        An .area file contains a separate area constraint for each\n");
X  printf(
"        triangle, and is useful for refining a finite element mesh based on\n"
);
X  printf(
"        a posteriori error estimates.  A .poly file can optionally contain\n"
);
X  printf(
"        an area constraint for each segment-bounded region, thereby\n");
X  printf(
"        controlling triangle densities in a first triangulation of a PSLG.\n"
);
X  printf(
"        You can impose both a fixed area constraint and a varying area\n");
X  printf(
"        constraint by invoking the -a switch twice, once with and once\n");
X  printf(
"        without a number following.  Each area specified may include a\n");
X  printf("        decimal point.\n");
X  printf(
"    -u  Imposes a user-defined constraint on triangle size.  There are two\n"
);
X  printf(
"        ways to use this feature.  One is to edit the triunsuitable()\n");
X  printf(
"        procedure in triangle.c to encode any constraint you like, then\n");
X  printf(
"        recompile Triangle.  The other is to compile triangle.c with the\n");
X  printf(
"        EXTERNAL_TEST symbol set (compiler switch -DEXTERNAL_TEST), then\n");
X  printf(
"        link Triangle with a separate object file that implements\n");
X  printf(
"        triunsuitable().  In either case, the -u switch causes the user-\n");
X  printf("        defined test to be applied to every triangle.\n");
X  printf(
"    -A  Assigns an additional floating-point attribute to each triangle\n");
X  printf(
"        that identifies what segment-bounded region each triangle belongs\n");
X  printf(
"        to.  Attributes are assigned to regions by the .poly file.  If a\n");
X  printf(
"        region is not explicitly marked by the .poly file, triangles in\n");
X  printf(
"        that region are assigned an attribute of zero.  The -A switch has\n");
X  printf(
"        an effect only when the -p switch is used and the -r switch is not.\n"
);
X  printf(
"    -c  Creates segments on the convex hull of the triangulation.  If you\n");
X  printf(
"        are triangulating a vertex set, this switch causes a .poly file to\n"
);
X  printf(
"        be written, containing all edges of the convex hull.  If you are\n");
X  printf(
"        triangulating a PSLG, this switch specifies that the whole convex\n");
X  printf(
"        hull of the PSLG should be triangulated, regardless of what\n");
X  printf(
"        segments the PSLG has.  If you do not use this switch when\n");
X  printf(
"        triangulating a PSLG, Triangle assumes that you have identified the\n"
);
X  printf(
"        region to be triangulated by surrounding it with segments of the\n");
X  printf(
"        input PSLG.  Beware:  if you are not careful, this switch can cause\n"
);
X  printf(
"        the introduction of an extremely thin angle between a PSLG segment\n"
);
X  printf(
"        and a convex hull segment, which can cause overrefinement (and\n");
X  printf(
"        possibly failure if Triangle runs out of precision).  If you are\n");
X  printf(
"        refining a mesh, the -c switch works differently:  it causes a\n");
X  printf(
"        .poly file to be written containing the boundary edges of the mesh\n"
);
X  printf("        (useful if no .poly file was read).\n");
X  printf(
"    -D  Conforming Delaunay triangulation:  use this switch if you want to\n"
);
X  printf(
"        ensure that all the triangles in the mesh are Delaunay, and not\n");
X  printf(
"        merely constrained Delaunay; or if you want to ensure that all the\n"
);
X  printf(
"        Voronoi vertices lie within the triangulation.  (Some finite volume\n"
);
X  printf(
"        methods have this requirement.)  This switch invokes Ruppert's\n");
X  printf(
"        original algorithm, which splits every subsegment whose diametral\n");
X  printf(
"        circle is encroached.  It usually increases the number of vertices\n"
);
X  printf("        and triangles.\n");
X  printf(
"    -j  Jettisons vertices that are not part of the final triangulation\n");
X  printf(
"        from the output .node file.  By default, Triangle copies all\n");
X  printf(
"        vertices in the input .node file to the output .node file, in the\n");
X  printf(
"        same order, so their indices do not change.  The -j switch prevents\n"
);
X  printf(
"        duplicated input vertices, or vertices `eaten' by holes, from\n");
X  printf(
"        appearing in the output .node file.  Thus, if two input vertices\n");
X  printf(
"        have exactly the same coordinates, only the first appears in the\n");
X  printf(
"        output.  If any vertices are jettisoned, the vertex numbering in\n");
X  printf(
"        the output .node file differs from that of the input .node file.\n");
X  printf(
"    -e  Outputs (to an .edge file) a list of edges of the triangulation.\n");
X  printf(
"    -v  Outputs the Voronoi diagram associated with the triangulation.\n");
X  printf(
"        Does not attempt to detect degeneracies, so some Voronoi vertices\n");
X  printf(
"        may be duplicated.  See the discussion of Voronoi diagrams below.\n");
X  printf(
"    -n  Outputs (to a .neigh file) a list of triangles neighboring each\n");
X  printf("        triangle.\n");
X  printf(
"    -g  Outputs the mesh to an Object File Format (.off) file, suitable for\n"
);
X  printf("        viewing with the Geometry Center's Geomview package.\n");
X  printf(
"    -B  No boundary markers in the output .node, .poly, and .edge output\n");
X  printf(
"        files.  See the detailed discussion of boundary markers below.\n");
X  printf(
"    -P  No output .poly file.  Saves disk space, but you lose the ability\n");
X  printf(
"        to maintain constraining segments on later refinements of the mesh.\n"
);
X  printf("    -N  No output .node file.\n");
X  printf("    -E  No output .ele file.\n");
X  printf(
"    -I  No iteration numbers.  Suppresses the output of .node and .poly\n");
X  printf(
"        files, so your input files won't be overwritten.  (If your input is\n"
);
X  printf(
"        a .poly file only, a .node file is written.)  Cannot be used with\n");
X  printf(
"        the -r switch, because that would overwrite your input .ele file.\n");
X  printf(
"        Shouldn't be used with the -q, -a, -u, or -s switch if you are\n");
X  printf(
"        using a .node file for input, because no .node file is written, so\n"
);
X  printf("        there is no record of any added Steiner points.\n");
X  printf("    -O  No holes.  Ignores the holes in the .poly file.\n");
X  printf(
"    -X  No exact arithmetic.  Normally, Triangle uses exact floating-point\n"
);
X  printf(
"        arithmetic for certain tests if it thinks the inexact tests are not\n"
);
X  printf(
"        accurate enough.  Exact arithmetic ensures the robustness of the\n");
X  printf(
"        triangulation algorithms, despite floating-point roundoff error.\n");
X  printf(
"        Disabling exact arithmetic with the -X switch causes a small\n");
X  printf(
"        improvement in speed and creates the possibility that Triangle will\n"
);
X  printf("        fail to produce a valid mesh.  Not recommended.\n");
X  printf(
"    -z  Numbers all items starting from zero (rather than one).  Note that\n"
);
X  printf(
"        this switch is normally overridden by the value used to number the\n"
);
X  printf(
"        first vertex of the input .node or .poly file.  However, this\n");
X  printf(
"        switch is useful when calling Triangle from another program.\n");
X  printf(
"    -o2 Generates second-order subparametric elements with six nodes each.\n"
);
X  printf(
"    -Y  No new vertices on the boundary.  This switch is useful when the\n");
X  printf(
"        mesh boundary must be preserved so that it conforms to some\n");
X  printf(
"        adjacent mesh.  Be forewarned that you will probably sacrifice much\n"
);
X  printf(
"        of the quality of the mesh; Triangle will try, but the resulting\n");
X  printf(
"        mesh may contain poorly shaped triangles.  Works well if all the\n");
X  printf(
"        boundary vertices are closely spaced.  Specify this switch twice\n");
X  printf(
"        (`-YY') to prevent all segment splitting, including internal\n");
X  printf("        boundaries.\n");
X  printf(
"    -S  Specifies the maximum number of Steiner points (vertices that are\n");
X  printf(
"        not in the input, but are added to meet the constraints on minimum\n"
);
X  printf(
"        angle and maximum area).  The default is to allow an unlimited\n");
X  printf(
"        number.  If you specify this switch with no number after it,\n");
X  printf(
"        the limit is set to zero.  Triangle always adds vertices at segment\n"
);
X  printf(
"        intersections, even if it needs to use more vertices than the limit\n"
);
X  printf(
"        you set.  When Triangle inserts segments by splitting (-s), it\n");
X  printf(
"        always adds enough vertices to ensure that all the segments of the\n"
);
X  printf("        PLSG are recovered, ignoring the limit if necessary.\n");
X  printf(
"    -i  Uses an incremental rather than a divide-and-conquer algorithm to\n");
X  printf(
"        construct a Delaunay triangulation.  Try it if the divide-and-\n");
X  printf("        conquer algorithm fails.\n");
X  printf(
"    -F  Uses Steven Fortune's sweepline algorithm to construct a Delaunay\n");
X  printf(
"        triangulation.  Warning:  does not use exact arithmetic for all\n");
X  printf("        calculations.  An exact result is not guaranteed.\n");
X  printf(
"    -l  Uses only vertical cuts in the divide-and-conquer algorithm.  By\n");
X  printf(
"        default, Triangle alternates between vertical and horizontal cuts,\n"
);
X  printf(
"        which usually improve the speed except with vertex sets that are\n");
X  printf(
"        small or short and wide.  This switch is primarily of theoretical\n");
X  printf("        interest.\n");
X  printf(
"    -s  Specifies that segments should be forced into the triangulation by\n"
);
X  printf(
"        recursively splitting them at their midpoints, rather than by\n");
X  printf(
"        generating a constrained Delaunay triangulation.  Segment splitting\n"
);
X  printf(
"        is true to Ruppert's original algorithm, but can create needlessly\n"
);
X  printf(
"        small triangles.  This switch is primarily of theoretical interest.\n"
);
X  printf(
"    -C  Check the consistency of the final mesh.  Uses exact arithmetic for\n"
);
X  printf(
"        checking, even if the -X switch is used.  Useful if you suspect\n");
X  printf("        Triangle is buggy.\n");
X  printf(
"    -Q  Quiet:  Suppresses all explanation of what Triangle is doing,\n");
X  printf("        unless an error occurs.\n");
X  printf(
"    -V  Verbose:  Gives detailed information about what Triangle is doing.\n"
);
X  printf(
"        Add more `V's for increasing amount of detail.  `-V' is most\n");
X  printf(
"        useful; itgives information on algorithmic progress and much more\n");
X  printf(
"        detailed statistics.  `-VV' gives vertex-by-vertex details, and\n");
X  printf(
"        prints so much that Triangle runs much more slowly.  `-VVVV' gives\n"
);
X  printf("        information only a debugger could love.\n");
X  printf("    -h  Help:  Displays these instructions.\n");
X  printf("\n");
X  printf("Definitions:\n");
X  printf("\n");
X  printf(
"  A Delaunay triangulation of a vertex set is a triangulation whose\n");
X  printf(
"  vertices are the vertex set, that covers the convex hull of the vertex\n");
X  printf(
"  set.  A Delaunay triangulation has the property that no vertex lies\n");
X  printf(
"  inside the circumscribing circle (circle that passes through all three\n");
X  printf("  vertices) of any triangle in the triangulation.\n\n");
X  printf(
"  A Voronoi diagram of a vertex set is a subdivision of the plane into\n");
X  printf(
"  polygonal cells (some of which may be unbounded, meaning infinitely\n");
X  printf(
"  large), where each cell is the set of points in the plane that are closer\n"
);
X  printf(
"  to some input vertex than to any other input vertex.  The Voronoi diagram\n"
);
X  printf("  is a geometric dual of the Delaunay triangulation.\n\n");
X  printf(
"  A Planar Straight Line Graph (PSLG) is a set of vertices and segments.\n");
X  printf(
"  Segments are simply edges, whose endpoints are all vertices in the PSLG.\n"
);
X  printf(
"  Segments may intersect each other only at their endpoints.  The file\n");
X  printf("  format for PSLGs (.poly files) is described below.\n\n");
X  printf(
"  A constrained Delaunay triangulation (CDT) of a PSLG is similar to a\n");
X  printf(
"  Delaunay triangulation, but each PSLG segment is present as a single edge\n"
);
X  printf(
"  of the CDT.  (A constrained Delaunay triangulation is not truly a\n");
X  printf(
"  Delaunay triangulation, because some of its triangles might not be\n");
X  printf(
"  Delaunay.)  By definition, a CDT does not have any vertices other than\n");
X  printf(
"  those specified in the input PSLG.  Depending on context, a CDT might\n");
X  printf(
"  cover the convex hull of the PSLG, or it might cover only a segment-\n");
X  printf("  bounded region (e.g. a polygon).\n\n");
X  printf(
"  A conforming Delaunay triangulation of a PSLG is a triangulation in which\n"
);
X  printf(
"  each triangle is truly Delaunay, and each PSLG segment is represented by\n"
);
X  printf(
"  a linear contiguous sequence of edges of the triangulation.  New vertices\n"
);
X  printf(
"  (not part of the PSLG) may appear, and each input segment may have been\n");
X  printf(
"  subdivided into shorter edges (subsegments) by these additional vertices.\n"
);
X  printf(
"  The new vertices are frequently necessary to maintain the Delaunay\n");
X  printf("  property while ensuring that every segment is represented.\n\n");
X  printf(
"  A conforming constrained Delaunay triangulation (CCDT) of a PSLG is a\n");
X  printf(
"  triangulation of a PSLG whose triangles are constrained Delaunay.  New\n");
X  printf("  vertices may appear, and input segments may be subdivided into\n");
X  printf(
"  subsegments, but not to guarantee that segments are respected; rather, to\n"
);
X  printf(
"  improve the quality of the triangles.  The high-quality meshes produced\n");
X  printf(
"  by the -q switch are usually CCDTs, but can be made conforming Delaunay\n");
X  printf("  with the -D switch.\n\n");
X  printf("File Formats:\n\n");
X  printf(
"  All files may contain comments prefixed by the character '#'.  Vertices,\n"
);
X  printf(
"  triangles, edges, holes, and maximum area constraints must be numbered\n");
X  printf(
"  consecutively, starting from either 1 or 0.  Whichever you choose, all\n");
X  printf(
"  input files must be consistent; if the vertices are numbered from 1, so\n");
X  printf(
"  must be all other objects.  Triangle automatically detects your choice\n");
X  printf(
"  while reading the .node (or .poly) file.  (When calling Triangle from\n");
X  printf(
"  another program, use the -z switch if you wish to number objects from\n");
X  printf("  zero.)  Examples of these file formats are given below.\n\n");
X  printf("  .node files:\n");
X  printf(
"    First line:  <# of vertices> <dimension (must be 2)> <# of attributes>\n"
);
X  printf(
"                                           <# of boundary markers (0 or 1)>\n"
);
X  printf(
"    Remaining lines:  <vertex #> <x> <y> [attributes] [boundary marker]\n");
X  printf("\n");
X  printf(
"    The attributes, which are typically floating-point values of physical\n");
X  printf(
"    quantities (such as mass or conductivity) associated with the nodes of\n"
);
X  printf(
"    a finite element mesh, are copied unchanged to the output mesh.  If -q,\n"
);
X  printf(
"    -a, -u, -D, or -s is selected, each new Steiner point added to the mesh\n"
);
X  printf("    has attributes assigned to it by linear interpolation.\n\n");
X  printf(
"    If the fourth entry of the first line is `1', the last column of the\n");
X  printf(
"    remainder of the file is assumed to contain boundary markers.  Boundary\n"
);
X  printf(
"    markers are used to identify boundary vertices and vertices resting on\n"
);
X  printf(
"    PSLG segments; a complete description appears in a section below.  The\n"
);
X  printf(
"    .node file produced by Triangle contains boundary markers in the last\n");
X  printf("    column unless they are suppressed by the -B switch.\n\n");
X  printf("  .ele files:\n");
X  printf(
"    First line:  <# of triangles> <nodes per triangle> <# of attributes>\n");
X  printf(
"    Remaining lines:  <triangle #> <node> <node> <node> ... [attributes]\n");
X  printf("\n");
X  printf(
"    Nodes are indices into the corresponding .node file.  The first three\n");
X  printf(
"    nodes are the corner vertices, and are listed in counterclockwise order\n"
);
X  printf(
"    around each triangle.  (The remaining nodes, if any, depend on the type\n"
);
X  printf("    of finite element used.)\n\n");
X  printf(
"    The attributes are just like those of .node files.  Because there is no\n"
);
X  printf(
"    simple mapping from input to output triangles, Triangle attempts to\n");
X  printf(
"    interpolate attributes, and may cause a lot of diffusion of attributes\n"
);
X  printf(
"    among nearby triangles as the triangulation is refined.  Attributes do\n"
);
X  printf("    not diffuse across segments, so attributes used to identify\n");
X  printf("    segment-bounded regions remain intact.\n\n");
X  printf(
"    In .ele files produced by Triangle, each triangular element has three\n");
X  printf(
"    nodes (vertices) unless the -o2 switch is used, in which case\n");
X  printf(
"    subparametric quadratic elements with six nodes each are generated.\n");
X  printf(
"    The first three nodes are the corners in counterclockwise order, and\n");
X  printf(
"    the fourth, fifth, and sixth nodes lie on the midpoints of the edges\n");
X  printf(
"    opposite the first, second, and third vertices, respectively.\n");
X  printf("\n");
X  printf("  .poly files:\n");
X  printf(
"    First line:  <# of vertices> <dimension (must be 2)> <# of attributes>\n"
);
X  printf(
"                                           <# of boundary markers (0 or 1)>\n"
);
X  printf(
"    Following lines:  <vertex #> <x> <y> [attributes] [boundary marker]\n");
X  printf("    One line:  <# of segments> <# of boundary markers (0 or 1)>\n");
X  printf(
"    Following lines:  <segment #> <endpoint> <endpoint> [boundary marker]\n");
X  printf("    One line:  <# of holes>\n");
X  printf("    Following lines:  <hole #> <x> <y>\n");
X  printf(
"    Optional line:  <# of regional attributes and/or area constraints>\n");
X  printf(
"    Optional following lines:  <region #> <x> <y> <attribute> <max area>\n");
X  printf("\n");
X  printf(
"    A .poly file represents a PSLG, as well as some additional information.\n"
);
X  printf(
"    The first section lists all the vertices, and is identical to the\n");
X  printf(
"    format of .node files.  <# of vertices> may be set to zero to indicate\n"
);
X  printf(
"    that the vertices are listed in a separate .node file; .poly files\n");
X  printf(
"    produced by Triangle always have this format.  A vertex set represented\n"
);
X  printf(
"    this way has the advantage that it may easily be triangulated with or\n");
X  printf(
"    without segments (depending on whether the -p switch is invoked).\n");
X  printf("\n");
X  printf(
"    The second section lists the segments.  Segments are edges whose\n");
X  printf(
"    presence in the triangulation is enforced.  (Depending on the choice of\n"
);
X  printf(
"    switches, segment might be subdivided into smaller edges).  Each\n");
X  printf(
"    segment is specified by listing the indices of its two endpoints.  This\n"
);
X  printf(
"    means that you must include its endpoints in the vertex list.  Each\n");
X  printf("    segment, like each point, may have a boundary marker.\n\n");
X  printf(
"    If -q, -a, -u, and -s are not selected, Triangle produces a constrained\n"
);
X  printf(
"    Delaunay triangulation (CDT), in which each segment appears as a single\n"
);
X  printf(
"    edge in the triangulation.  If -q, -a, -u, or -s is selected, Triangle\n"
);
X  printf(
"    produces a conforming constrained Delaunay triangulation (CCDT), in\n");
X  printf(
"    which segments may be subdivided into smaller edges.  If -D is\n");
X  printf(
"    selected, Triangle produces a conforming Delaunay triangulation, so\n");
X  printf(
"    that every triangle is Delaunay, and not just constrained Delaunay.\n");
X  printf("\n");
X  printf(
"    The third section lists holes (and concavities, if -c is selected) in\n");
X  printf(
"    the triangulation.  Holes are specified by identifying a point inside\n");
X  printf(
"    each hole.  After the triangulation is formed, Triangle creates holes\n");
X  printf(
"    by eating triangles, spreading out from each hole point until its\n");
X  printf(
"    progress is blocked by segments in the PSLG.  You must be careful to\n");
X  printf(
"    enclose each hole in segments, or your whole triangulation might be\n");
X  printf(
"    eaten away.  If the two triangles abutting a segment are eaten, the\n");
X  printf(
"    segment itself is also eaten.  Do not place a hole directly on a\n");
X  printf("    segment; if you do, Triangle chooses one side of the segment\n");
X  printf("    arbitrarily.\n\n");
X  printf(
"    The optional fourth section lists regional attributes (to be assigned\n");
X  printf(
"    to all triangles in a region) and regional constraints on the maximum\n");
X  printf(
"    triangle area.  Triangle reads this section only if the -A switch is\n");
X  printf(
"    used or the -a switch is used without a number following it, and the -r\n"
);
X  printf(
"    switch is not used.  Regional attributes and area constraints are\n");
X  printf(
"    propagated in the same manner as holes:  you specify a point for each\n");
X  printf(
"    attribute and/or constraint, and the attribute and/or constraint\n");
X  printf(
"    affects the whole region (bounded by segments) containing the point.\n");
X  printf(
"    If two values are written on a line after the x and y coordinate, the\n");
X  printf(
"    first such value is assumed to be a regional attribute (but is only\n");
X  printf(
"    applied if the -A switch is selected), and the second value is assumed\n"
);
X  printf(
"    to be a regional area constraint (but is only applied if the -a switch\n"
);
X  printf(
"    is selected).  You may specify just one value after the coordinates,\n");
X  printf(
"    which can serve as both an attribute and an area constraint, depending\n"
);
X  printf(
"    on the choice of switches.  If you are using the -A and -a switches\n");
X  printf(
"    simultaneously and wish to assign an attribute to some region without\n");
X  printf("    imposing an area constraint, use a negative maximum area.\n\n");
X  printf(
"    When a triangulation is created from a .poly file, you must either\n");
X  printf(
"    enclose the entire region to be triangulated in PSLG segments, or\n");
X  printf(
"    use the -c switch, which automatically creates extra segments that\n");
X  printf(
"    enclose the convex hull of the PSLG.  If you do not use the -c switch,\n"
);
X  printf(
"    Triangle eats all triangles that are not enclosed by segments; if you\n");
X  printf(
"    are not careful, your whole triangulation may be eaten away.  If you do\n"
);
X  printf(
"    use the -c switch, you can still produce concavities by the appropriate\n"
);
X  printf(
"    placement of holes just inside the boundary of the convex hull.\n");
X  printf("\n");
X  printf(
"    An ideal PSLG has no intersecting segments, nor any vertices that lie\n");
X  printf(
"    upon segments (except, of course, the endpoints of each segment).  You\n"
);
X  printf(
"    aren't required to make your .poly files ideal, but you should be aware\n"
);
X  printf(
"    of what can go wrong.  Segment intersections are relatively safe--\n");
X  printf(
"    Triangle calculates the intersection points for you and adds them to\n");
X  printf(
"    the triangulation--as long as your machine's floating-point precision\n");
X  printf(
"    doesn't become a problem.  You are tempting the fates if you have three\n"
);
X  printf(
"    segments that cross at the same location, and expect Triangle to figure\n"
);
X  printf(
"    out where the intersection point is.  Thanks to floating-point roundoff\n"
);
X  printf(
"    error, Triangle will probably decide that the three segments intersect\n"
);
X  printf(
"    at three different points, and you will find a minuscule triangle in\n");
X  printf(
"    your output--unless Triangle tries to refine the tiny triangle, uses\n");
X  printf(
"    up the last bit of machine precision, and fails to terminate at all.\n");
X  printf(
"    You're better off putting the intersection point in the input files,\n");
X  printf(
"    and manually breaking up each segment into two.  Similarly, if you\n");
X  printf(
"    place a vertex at the middle of a segment, and hope that Triangle will\n"
);
X  printf(
"    break up the segment at that vertex, you might get lucky.  On the other\n"
);
X  printf(
"    hand, Triangle might decide that the vertex doesn't lie precisely on\n");
X  printf(
"    the segment, and you'll have a needle-sharp triangle in your output--or\n"
);
X  printf("    a lot of tiny triangles if you're generating a quality mesh.\n");
X  printf("\n");
X  printf(
"    When Triangle reads a .poly file, it also writes a .poly file, which\n");
X  printf(
"    includes all the subsegments--the edges that are parts of input\n");
X  printf(
"    segments.  If the -c switch is used, the output .poly file also\n");
X  printf(
"    includes all of the edges on the convex hull.  Hence, the output .poly\n"
);
X  printf(
"    file is useful for finding edges associated with input segments and for\n"
);
X  printf(
"    setting boundary conditions in finite element simulations.  Moreover,\n");
X  printf(
"    you will need the output .poly file if you plan to refine the output\n");
X  printf(
"    mesh, and don't want segments to be missing in later triangulations.\n");
X  printf("\n");
X  printf("  .area files:\n");
X  printf("    First line:  <# of triangles>\n");
X  printf("    Following lines:  <triangle #> <maximum area>\n");
X  printf("\n");
X  printf(
"    An .area file associates with each triangle a maximum area that is used\n"
);
X  printf(
"    for mesh refinement.  As with other file formats, every triangle must\n");
X  printf(
"    be represented, and the triangles must be numbered consecutively.  A\n");
X  printf(
"    triangle may be left unconstrained by assigning it a negative maximum\n");
X  printf("    area.\n\n");
X  printf("  .edge files:\n");
X  printf("    First line:  <# of edges> <# of boundary markers (0 or 1)>\n");
X  printf(
"    Following lines:  <edge #> <endpoint> <endpoint> [boundary marker]\n");
X  printf("\n");
X  printf(
"    Endpoints are indices into the corresponding .node file.  Triangle can\n"
);
X  printf(
"    produce .edge files (use the -e switch), but cannot read them.  The\n");
X  printf(
"    optional column of boundary markers is suppressed by the -B switch.\n");
X  printf("\n");
X  printf(
"    In Voronoi diagrams, one also finds a special kind of edge that is an\n");
X  printf(
"    infinite ray with only one endpoint.  For these edges, a different\n");
X  printf("    format is used:\n\n");
X  printf("        <edge #> <endpoint> -1 <direction x> <direction y>\n\n");
X  printf(
"    The `direction' is a floating-point vector that indicates the direction\n"
);
X  printf("    of the infinite ray.\n\n");
X  printf("  .neigh files:\n");
X  printf(
"    First line:  <# of triangles> <# of neighbors per triangle (always 3)>\n"
);
X  printf(
"    Following lines:  <triangle #> <neighbor> <neighbor> <neighbor>\n");
X  printf("\n");
X  printf(
"    Neighbors are indices into the corresponding .ele file.  An index of -1\n"
);
X  printf(
"    indicates no neighbor (because the triangle is on an exterior\n");
X  printf(
"    boundary).  The first neighbor of triangle i is opposite the first\n");
X  printf("    corner of triangle i, and so on.\n\n");
X  printf(
"    Triangle can produce .neigh files (use the -n switch), but cannot read\n"
);
X  printf("    them.\n\n");
X  printf("Boundary Markers:\n\n");
X  printf(
"  Boundary markers are tags used mainly to identify which output vertices\n");
X  printf(
"  and edges are associated with which PSLG segment, and to identify which\n");
X  printf(
"  vertices and edges occur on a boundary of the triangulation.  A common\n");
X  printf(
"  use is to determine where boundary conditions should be applied to a\n");
X  printf(
"  finite element mesh.  You can prevent boundary markers from being written\n"
);
X  printf("  into files produced by Triangle by using the -B switch.\n\n");
X  printf(
"  The boundary marker associated with each segment in an output .poly file\n"
);
X  printf("  and each edge in an output .edge file is chosen as follows:\n");
X  printf(
"    - If an output edge is part or all of a PSLG segment with a nonzero\n");
X  printf(
"      boundary marker, then the edge is assigned the same marker.\n");
X  printf(
"    - Otherwise, if the edge lies on a boundary of the triangulation\n");
X  printf(
"      (even the boundary of a hole), then the edge is assigned the marker\n");
X  printf("      one (1).\n");
X  printf("    - Otherwise, the edge is assigned the marker zero (0).\n");
X  printf(
"  The boundary marker associated with each vertex in an output .node file\n");
X  printf("  is chosen as follows:\n");
X  printf(
"    - If a vertex is assigned a nonzero boundary marker in the input file,\n"
);
X  printf(
"      then it is assigned the same marker in the output .node file.\n");
X  printf(
"    - Otherwise, if the vertex lies on a PSLG segment (even if it is an\n");
X  printf(
"      endpoint of the segment) with a nonzero boundary marker, then the\n");
X  printf(
"      vertex is assigned the same marker.  If the vertex lies on several\n");
X  printf("      such segments, one of the markers is chosen arbitrarily.\n");
X  printf(
"    - Otherwise, if the vertex occurs on a boundary of the triangulation,\n");
X  printf("      then the vertex is assigned the marker one (1).\n");
X  printf("    - Otherwise, the vertex is assigned the marker zero (0).\n");
X  printf("\n");
X  printf(
"  If you want Triangle to determine for you which vertices and edges are on\n"
);
X  printf(
"  the boundary, assign them the boundary marker zero (or use no markers at\n"
);
X  printf(
"  all) in your input files.  In the output files, all boundary vertices,\n");
X  printf("  edges, and segments will be assigned the value one.\n\n");
X  printf("Triangulation Iteration Numbers:\n\n");
X  printf(
"  Because Triangle can read and refine its own triangulations, input\n");
X  printf(
"  and output files have iteration numbers.  For instance, Triangle might\n");
X  printf(
"  read the files mesh.3.node, mesh.3.ele, and mesh.3.poly, refine the\n");
X  printf(
"  triangulation, and output the files mesh.4.node, mesh.4.ele, and\n");
X  printf("  mesh.4.poly.  Files with no iteration number are treated as if\n");
X  printf(
"  their iteration number is zero; hence, Triangle might read the file\n");
X  printf(
"  points.node, triangulate it, and produce the files points.1.node and\n");
X  printf("  points.1.ele.\n\n");
X  printf(
"  Iteration numbers allow you to create a sequence of successively finer\n");
X  printf(
"  meshes suitable for multigrid methods.  They also allow you to produce a\n"
);
X  printf(
"  sequence of meshes using error estimate-driven mesh refinement.\n");
X  printf("\n");
X  printf(
"  If you're not using refinement or quality meshing, and you don't like\n");
X  printf(
"  iteration numbers, use the -I switch to disable them.  This switch also\n");
X  printf(
"  disables output of .node and .poly files to prevent your input files from\n"
);
X  printf(
"  being overwritten.  (If the input is a .poly file that contains its own\n");
X  printf(
"  points, a .node file is written.  This can be quite convenient for\n");
X  printf("  computing CDTs or quality meshes.)\n\n");
X  printf("Examples of How to Use Triangle:\n\n");
X  printf(
"  `triangle dots' reads vertices from dots.node, and writes their Delaunay\n"
);
X  printf(
"  triangulation to dots.1.node and dots.1.ele.  (dots.1.node is identical\n");
X  printf(
"  to dots.node.)  `triangle -I dots' writes the triangulation to dots.ele\n");
X  printf(
"  instead.  (No additional .node file is needed, so none is written.)\n");
X  printf("\n");
X  printf(
"  `triangle -pe object.1' reads a PSLG from object.1.poly (and possibly\n");
X  printf(
"  object.1.node, if the vertices are omitted from object.1.poly) and writes\n"
);
X  printf(
"  its constrained Delaunay triangulation to object.2.node and object.2.ele.\n"
);
X  printf(
"  The segments are copied to object.2.poly, and all edges are written to\n");
X  printf("  object.2.edge.\n\n");
X  printf(
"  `triangle -pq31.5a.1 object' reads a PSLG from object.poly (and possibly\n"
);
X  printf(
"  object.node), generates a mesh whose angles are all between 31.5 and 117\n"
);
X  printf(
"  degrees and whose triangles all have areas of 0.1 or less, and writes the\n"
);
X  printf(
"  mesh to object.1.node and object.1.ele.  Each segment may be broken up\n");
X  printf("  into multiple subsegments; these are written to object.1.poly.\n");
X  printf("\n");
X  printf(
"  Here is a sample file `box.poly' describing a square with a square hole:\n"
);
X  printf("\n");
X  printf(
"    # A box with eight vertices in 2D, no attributes, one boundary marker.\n"
);
X  printf("    8 2 0 1\n");
X  printf("     # Outer box has these vertices:\n");
X  printf("     1   0 0   0\n");
X  printf("     2   0 3   0\n");
X  printf("     3   3 0   0\n");
X  printf("     4   3 3   33     # A special marker for this vertex.\n");
X  printf("     # Inner square has these vertices:\n");
X  printf("     5   1 1   0\n");
X  printf("     6   1 2   0\n");
X  printf("     7   2 1   0\n");
X  printf("     8   2 2   0\n");
X  printf("    # Five segments with boundary markers.\n");
X  printf("    5 1\n");
X  printf("     1   1 2   5      # Left side of outer box.\n");
X  printf("     # Square hole has these segments:\n");
X  printf("     2   5 7   0\n");
X  printf("     3   7 8   0\n");
X  printf("     4   8 6   10\n");
X  printf("     5   6 5   0\n");
X  printf("    # One hole in the middle of the inner square.\n");
X  printf("    1\n");
X  printf("     1   1.5 1.5\n");
X  printf("\n");
X  printf(
"  Note that some segments are missing from the outer square, so you must\n");
X  printf(
"  use the `-c' switch.  After `triangle -pqc box.poly', here is the output\n"
);
X  printf(
"  file `box.1.node', with twelve vertices.  The last four vertices were\n");
X  printf(
"  added to meet the angle constraint.  Vertices 1, 2, and 9 have markers\n");
X  printf(
"  from segment 1.  Vertices 6 and 8 have markers from segment 4.  All the\n");
X  printf(
"  other vertices but 4 have been marked to indicate that they lie on a\n");
X  printf("  boundary.\n\n");
X  printf("    12  2  0  1\n");
X  printf("       1    0   0      5\n");
X  printf("       2    0   3      5\n");
X  printf("       3    3   0      1\n");
X  printf("       4    3   3     33\n");
X  printf("       5    1   1      1\n");
X  printf("       6    1   2     10\n");
X  printf("       7    2   1      1\n");
X  printf("       8    2   2     10\n");
X  printf("       9    0   1.5    5\n");
X  printf("      10    1.5   0    1\n");
X  printf("      11    3   1.5    1\n");
X  printf("      12    1.5   3    1\n");
X  printf("    # Generated by triangle -pqc box.poly\n");
X  printf("\n");
X  printf("  Here is the output file `box.1.ele', with twelve triangles.\n");
X  printf("\n");
X  printf("    12  3  0\n");
X  printf("       1     5   6   9\n");
X  printf("       2    10   3   7\n");
X  printf("       3     6   8  12\n");
X  printf("       4     9   1   5\n");
X  printf("       5     6   2   9\n");
X  printf("       6     7   3  11\n");
X  printf("       7    11   4   8\n");
X  printf("       8     7   5  10\n");
X  printf("       9    12   2   6\n");
X  printf("      10     8   7  11\n");
X  printf("      11     5   1  10\n");
X  printf("      12     8   4  12\n");
X  printf("    # Generated by triangle -pqc box.poly\n\n");
X  printf(
"  Here is the output file `box.1.poly'.  Note that segments have been added\n"
);
X  printf(
"  to represent the convex hull, and some segments have been subdivided by\n");
X  printf(
"  newly added vertices.  Note also that <# of vertices> is set to zero to\n");
X  printf("  indicate that the vertices should be read from the .node file.\n");
X  printf("\n");
X  printf("    0  2  0  1\n");
X  printf("    12  1\n");
X  printf("       1     1   9     5\n");
X  printf("       2     5   7     1\n");
X  printf("       3     8   7     1\n");
X  printf("       4     6   8    10\n");
X  printf("       5     5   6     1\n");
X  printf("       6     3  10     1\n");
X  printf("       7     4  11     1\n");
X  printf("       8     2  12     1\n");
X  printf("       9     9   2     5\n");
X  printf("      10    10   1     1\n");
X  printf("      11    11   3     1\n");
X  printf("      12    12   4     1\n");
X  printf("    1\n");
X  printf("       1   1.5 1.5\n");
X  printf("    # Generated by triangle -pqc box.poly\n");
X  printf("\n");
X  printf("Refinement and Area Constraints:\n");
X  printf("\n");
X  printf(
"  The -r switch causes a mesh (.node and .ele files) to be read and\n");
X  printf(
"  refined.  If the -p switch is also used, a .poly file is read and used to\n"
);
X  printf(
"  specify edges that are constrained and cannot be eliminated (although\n");
X  printf(
"  they can be subdivided into smaller edges) by the refinement process.\n");
X  printf("\n");
X  printf(
"  When you refine a mesh, you generally want to impose tighter constraints.\n"
);
X  printf(
"  One way to accomplish this is to use -q with a larger angle, or -a\n");
X  printf(
"  followed by a smaller area than you used to generate the mesh you are\n");
X  printf(
"  refining.  Another way to do this is to create an .area file, which\n");
X  printf(
"  specifies a maximum area for each triangle, and use the -a switch\n");
X  printf(
"  (without a number following).  Each triangle's area constraint is applied\n"
);
X  printf(
"  to that triangle.  Area constraints tend to diffuse as the mesh is\n");
X  printf(
"  refined, so if there are large variations in area constraint between\n");
X  printf(
"  adjacent triangles, you may not get the results you want.  In that case,\n"
);
X  printf(
"  consider instead using the -u switch and writing a C procedure that\n");
X  printf("  determines which triangles are too large.\n\n");
X  printf(
"  If you are refining a mesh composed of linear (three-node) elements, the\n"
);
X  printf(
"  output mesh contains all the nodes present in the input mesh, in the same\n"
);
X  printf(
"  order, with new nodes added at the end of the .node file.  However, the\n");
X  printf(
"  refinement is not hierarchical: there is no guarantee that each output\n");
X  printf(
"  element is contained in a single input element.  Often, an output element\n"
);
X  printf(
"  can overlap two or three input elements, and some input edges are not\n");
X  printf(
"  present in the output mesh.  Hence, a sequence of refined meshes forms a\n"
);
X  printf(
"  hierarchy of nodes, but not a hierarchy of elements.  If you refine a\n");
X  printf(
"  mesh of higher-order elements, the hierarchical property applies only to\n"
);
X  printf(
"  the nodes at the corners of an element; the midpoint nodes on each edge\n");
X  printf("  are discarded before the mesh is refined.\n\n");
X  printf(
"  Maximum area constraints in .poly files operate differently from those in\n"
);
X  printf(
"  .area files.  A maximum area in a .poly file applies to the whole\n");
X  printf(
"  (segment-bounded) region in which a point falls, whereas a maximum area\n");
X  printf(
"  in an .area file applies to only one triangle.  Area constraints in .poly\n"
);
X  printf(
"  files are used only when a mesh is first generated, whereas area\n");
X  printf(
"  constraints in .area files are used only to refine an existing mesh, and\n"
);
X  printf(
"  are typically based on a posteriori error estimates resulting from a\n");
X  printf("  finite element simulation on that mesh.\n\n");
X  printf(
"  `triangle -rq25 object.1' reads object.1.node and object.1.ele, then\n");
X  printf(
"  refines the triangulation to enforce a 25 degree minimum angle, and then\n"
);
X  printf(
"  writes the refined triangulation to object.2.node and object.2.ele.\n");
X  printf("\n");
X  printf(
"  `triangle -rpaa6.2 z.3' reads z.3.node, z.3.ele, z.3.poly, and z.3.area.\n"
);
X  printf(
"  After reconstructing the mesh and its subsegments, Triangle refines the\n");
X  printf(
"  mesh so that no triangle has area greater than 6.2, and furthermore the\n");
X  printf(
"  triangles satisfy the maximum area constraints in z.3.area.  No angle\n");
X  printf(
"  bound is imposed at all.  The output is written to z.4.node, z.4.ele, and\n"
);
X  printf("  z.4.poly.\n\n");
X  printf(
"  The sequence `triangle -qa1 x', `triangle -rqa.3 x.1', `triangle -rqa.1\n");
X  printf(
"  x.2' creates a sequence of successively finer meshes x.1, x.2, and x.3,\n");
X  printf("  suitable for multigrid.\n\n");
X  printf("Convex Hulls and Mesh Boundaries:\n\n");
X  printf(
"  If the input is a vertex set (not a PSLG), Triangle produces its convex\n");
X  printf(
"  hull as a by-product in the output .poly file if you use the -c switch.\n");
X  printf(
"  There are faster algorithms for finding a two-dimensional convex hull\n");
X  printf("  than triangulation, of course, but this one comes for free.\n\n");
X  printf(
"  If the input is an unconstrained mesh (you are using the -r switch but\n");
X  printf(
"  not the -p switch), Triangle produces a list of its boundary edges\n");
X  printf(
"  (including hole boundaries) as a by-product when you use the -c switch.\n");
X  printf(
"  If you also use the -p switch, the output .poly file contains all the\n");
X  printf("  segments from the input .poly file as well.\n\n");
X  printf("Voronoi Diagrams:\n\n");
X  printf(
"  The -v switch produces a Voronoi diagram, in files suffixed .v.node and\n");
X  printf(
"  .v.edge.  For example, `triangle -v points' reads points.node, produces\n");
X  printf(
"  its Delaunay triangulation in points.1.node and points.1.ele, and\n");
X  printf(
"  produces its Voronoi diagram in points.1.v.node and points.1.v.edge.  The\n"
);
X  printf(
"  .v.node file contains a list of all Voronoi vertices, and the .v.edge\n");
X  printf(
"  file contains a list of all Voronoi edges, some of which may be infinite\n"
);
X  printf(
"  rays.  (The choice of filenames makes it easy to run the set of Voronoi\n");
X  printf("  vertices through Triangle, if so desired.)\n\n");
X  printf(
"  This implementation does not use exact arithmetic to compute the Voronoi\n"
);
X  printf(
"  vertices, and does not check whether neighboring vertices are identical.\n"
);
X  printf(
"  Be forewarned that if the Delaunay triangulation is degenerate or\n");
X  printf(
"  near-degenerate, the Voronoi diagram may have duplicate vertices or\n");
X  printf("  crossing edges.\n\n");
X  printf(
"  The result is a valid Voronoi diagram only if Triangle's output is a true\n"
);
X  printf(
"  Delaunay triangulation.  The Voronoi output is usually meaningless (and\n");
X  printf(
"  may contain crossing edges and other pathology) if the output is a CDT or\n"
);
X  printf(
"  CCDT, or if it has holes or concavities.  If the triangulated domain is\n");
X  printf(
"  convex and has no holes, you can use -D switch to force Triangle to\n");
X  printf(
"  construct a conforming Delaunay triangulation instead of a CCDT, so the\n");
X  printf("  Voronoi diagram will be valid.\n\n");
X  printf("Mesh Topology:\n\n");
X  printf(
"  You may wish to know which triangles are adjacent to a certain Delaunay\n");
X  printf(
"  edge in an .edge file, which Voronoi cells are adjacent to a certain\n");
X  printf(
"  Voronoi edge in a .v.edge file, or which Voronoi cells are adjacent to\n");
X  printf(
"  each other.  All of this information can be found by cross-referencing\n");
X  printf(
"  output files with the recollection that the Delaunay triangulation and\n");
X  printf("  the Voronoi diagram are planar duals.\n\n");
X  printf(
"  Specifically, edge i of an .edge file is the dual of Voronoi edge i of\n");
X  printf(
"  the corresponding .v.edge file, and is rotated 90 degrees counterclock-\n");
X  printf(
"  wise from the Voronoi edge.  Triangle j of an .ele file is the dual of\n");
X  printf(
"  vertex j of the corresponding .v.node file.  Voronoi cell k is the dual\n");
X  printf("  of vertex k of the corresponding .node file.\n\n");
X  printf(
"  Hence, to find the triangles adjacent to a Delaunay edge, look at the\n");
X  printf(
"  vertices of the corresponding Voronoi edge.  If the endpoints of a\n");
X  printf(
"  Voronoi edge are Voronoi vertices 2 and 6 respectively, then triangles 2\n"
);
X  printf(
"  and 6 adjoin the left and right sides of the corresponding Delaunay edge,\n"
);
X  printf(
"  respectively.  To find the Voronoi cells adjacent to a Voronoi edge, look\n"
);
X  printf(
"  at the endpoints of the corresponding Delaunay edge.  If the endpoints of\n"
);
X  printf(
"  a Delaunay edge are input vertices 7 and 12, then Voronoi cells 7 and 12\n"
);
X  printf(
"  adjoin the right and left sides of the corresponding Voronoi edge,\n");
X  printf(
"  respectively.  To find which Voronoi cells are adjacent to each other,\n");
X  printf("  just read the list of Delaunay edges.\n\n");
X  printf(
"  Triangle does not write a list of the edges adjoining each Voronoi cell,\n"
);
X  printf(
"  but you can reconstructed it straightforwardly.  For instance, to find\n");
X  printf(
"  all the edges of Voronoi cell 1, search the output .edge file for every\n");
X  printf(
"  edge that has input vertex 1 as an endpoint.  The corresponding dual\n");
X  printf(
"  edges in the output .v.edge file form the boundary of Voronoi cell 1.\n");
X  printf("\n");
X  printf(
"  For each Voronoi vertex, the .neigh file gives a list of the three\n");
X  printf(
"  Voronoi vertices attached to it.  You might find this more convenient\n");
X  printf("  than the .v.edge file.\n\n");
X  printf("Quadratic Elements:\n\n");
X  printf(
"  Triangle generates meshes with subparametric quadratic elements if the\n");
X  printf(
"  -o2 switch is specified.  Quadratic elements have six nodes per element,\n"
);
X  printf(
"  rather than three.  `Subparametric' means that the edges of the triangles\n"
);
X  printf(
"  are always straight, so that subparametric quadratic elements are\n");
X  printf(
"  geometrically identical to linear elements, even though they can be used\n"
);
X  printf(
"  with quadratic interpolating functions.  The three extra nodes of an\n");
X  printf(
"  element fall at the midpoints of the three edges, with the fourth, fifth,\n"
);
X  printf(
"  and sixth nodes appearing opposite the first, second, and third corners\n");
X  printf("  respectively.\n\n");
X  printf("Domains with Small Angles:\n\n");
X  printf(
"  If two input segments adjoin each other at a small angle, clearly the -q\n"
);
X  printf(
"  switch cannot remove the small angle.  Moreover, Triangle may have no\n");
X  printf(
"  choice but to generate additional triangles whose smallest angles are\n");
X  printf(
"  smaller than the specified bound.  However, these triangles only appear\n");
X  printf(
"  between input segments separated by small angles.  Moreover, if you\n");
X  printf(
"  request a minimum angle of theta degrees, Triangle will generally produce\n"
);
X  printf(
"  no angle larger than 180 - 2 theta, even if it is forced to compromise on\n"
);
X  printf("  the minimum angle.\n\n");
X  printf("Statistics:\n\n");
X  printf(
"  After generating a mesh, Triangle prints a count of entities in the\n");
X  printf(
"  output mesh, including the number of vertices, triangles, edges, exterior\n"
);
X  printf(
"  boundary edges (i.e. subsegments on the boundary of the triangulation,\n");
X  printf(
"  including hole boundaries), interior boundary edges (i.e. subsegments of\n"
);
X  printf(
"  input segments not on the boundary), and total subsegments.  If you've\n");
X  printf(
"  forgotten the statistics for an existing mesh, run Triangle on that mesh\n"
);
X  printf(
"  with the -rNEP switches to read the mesh and print the statistics without\n"
);
X  printf(
"  writing any files.  Use -rpNEP if you've got a .poly file for the mesh.\n");
X  printf("\n");
X  printf(
"  The -V switch produces extended statistics, including a rough estimate\n");
X  printf(
"  of memory use, the number of calls to geometric predicates, and\n");
X  printf(
"  histograms of the angles and the aspect ratios of the triangles in the\n");
X  printf("  mesh.\n\n");
X  printf("Exact Arithmetic:\n\n");
X  printf(
"  Triangle uses adaptive exact arithmetic to perform what computational\n");
X  printf(
"  geometers call the `orientation' and `incircle' tests.  If the floating-\n"
);
X  printf(
"  point arithmetic of your machine conforms to the IEEE 754 standard (as\n");
X  printf(
"  most workstations do), and does not use extended precision internal\n");
X  printf(
"  floating-point registers, then your output is guaranteed to be an\n");
X  printf(
"  absolutely true Delaunay or constrained Delaunay triangulation, roundoff\n"
);
X  printf(
"  error notwithstanding.  The word `adaptive' implies that these arithmetic\n"
);
X  printf(
"  routines compute the result only to the precision necessary to guarantee\n"
);
X  printf(
"  correctness, so they are usually nearly as fast as their approximate\n");
X  printf("  counterparts.\n\n");
X  printf(
"  May CPUs, including Intel x86 processors, have extended precision\n");
X  printf(
"  floating-point registers.  These must be reconfigured so their precision\n"
);
X  printf(
"  is reduced to memory precision.  Triangle does this if it is compiled\n");
X  printf("  correctly.  See the makefile for details.\n\n");
X  printf(
"  The exact tests can be disabled with the -X switch.  On most inputs, this\n"
);
X  printf(
"  switch reduces the computation time by about eight percent--it's not\n");
X  printf(
"  worth the risk.  There are rare difficult inputs (having many collinear\n");
X  printf(
"  and cocircular vertices), however, for which the difference in speed\n");
X  printf(
"  could be a factor of two.  Be forewarned that these are precisely the\n");
X  printf(
"  inputs most likely to cause errors if you use the -X switch.  Hence, the\n"
);
X  printf("  -X switch is not recommended.\n\n");
X  printf(
"  Unfortunately, the exact tests don't solve every numerical problem.\n");
X  printf(
"  Exact arithmetic is not used to compute the positions of new vertices,\n");
X  printf(
"  because the bit complexity of vertex coordinates would grow without\n");
X  printf(
"  bound.  Hence, segment intersections aren't computed exactly; in very\n");
X  printf(
"  unusual cases, roundoff error in computing an intersection point might\n");
X  printf(
"  actually lead to an inverted triangle and an invalid triangulation.\n");
X  printf(
"  (This is one reason to specify your own intersection points in your .poly\n"
);
X  printf(
"  files.)  Similarly, exact arithmetic is not used to compute the vertices\n"
);
X  printf("  of the Voronoi diagram.\n\n");
X  printf(
"  Another pair of problems not solved by the exact arithmetic routines is\n");
X  printf(
"  underflow and overflow.  If Triangle is compiled for double precision\n");
X  printf(
"  arithmetic, I believe that Triangle's geometric predicates work correctly\n"
);
X  printf(
"  if the exponent of every input coordinate falls in the range [-148, 201].\n"
);
X  printf(
"  Underflow can silently prevent the orientation and incircle tests from\n");
X  printf(
"  being performed exactly, while overflow typically causes a floating\n");
X  printf("  exception.\n\n");
X  printf("Calling Triangle from Another Program:\n\n");
X  printf("  Read the file triangle.h for details.\n\n");
X  printf("Troubleshooting:\n\n");
X  printf("  Please read this section before mailing me bugs.\n\n");
X  printf("  `My output mesh has no triangles!'\n\n");
X  printf(
"    If you're using a PSLG, you've probably failed to specify a proper set\n"
);
X  printf(
"    of bounding segments, or forgotten to use the -c switch.  Or you may\n");
X  printf(
"    have placed a hole badly, thereby eating all your triangles.  To test\n");
X  printf("    these possibilities, try again with the -c and -O switches.\n");
X  printf(
"    Alternatively, all your input vertices may be collinear, in which case\n"
);
X  printf("    you can hardly expect to triangulate them.\n\n");
X  printf("  `Triangle doesn't terminate, or just crashes.'\n\n");
X  printf(
"    Bad things can happen when triangles get so small that the distance\n");
X  printf(
"    between their vertices isn't much larger than the precision of your\n");
X  printf(
"    machine's arithmetic.  If you've compiled Triangle for single-precision\n"
);
X  printf(
"    arithmetic, you might do better by recompiling it for double-precision.\n"
);
X  printf(
"    Then again, you might just have to settle for more lenient constraints\n"
);
X  printf(
"    on the minimum angle and the maximum area than you had planned.\n");
X  printf("\n");
X  printf(
"    You can minimize precision problems by ensuring that the origin lies\n");
X  printf(
"    inside your vertex set, or even inside the densest part of your\n");
X  printf(
"    mesh.  If you're triangulating an object whose x-coordinates all fall\n");
X  printf(
"    between 6247133 and 6247134, you're not leaving much floating-point\n");
X  printf("    precision for Triangle to work with.\n\n");
X  printf(
"    Precision problems can occur covertly if the input PSLG contains two\n");
X  printf(
"    segments that meet (or intersect) at an extremely small angle, or if\n");
X  printf(
"    such an angle is introduced by the -c switch.  If you don't realize\n");
X  printf(
"    that a tiny angle is being formed, you might never discover why\n");
X  printf(
"    Triangle is crashing.  To check for this possibility, use the -S switch\n"
);
X  printf(
"    (with an appropriate limit on the number of Steiner points, found by\n");
X  printf(
"    trial-and-error) to stop Triangle early, and view the output .poly file\n"
);
X  printf(
"    with Show Me (described below).  Look carefully for regions where dense\n"
);
X  printf(
"    clusters of vertices are forming and for small angles between segments.\n"
);
X  printf(
"    Zoom in closely, as such segments might look like a single segment from\n"
);
X  printf("    a distance.\n\n");
X  printf(
"    If some of the input values are too large, Triangle may suffer a\n");
X  printf(
"    floating exception due to overflow when attempting to perform an\n");
X  printf(
"    orientation or incircle test.  (Read the section on exact arithmetic\n");
X  printf(
"    above.)  Again, I recommend compiling Triangle for double (rather\n");
X  printf("    than single) precision arithmetic.\n\n");
X  printf(
"    Unexpected problems can arise if you use quality meshing (-q, -a, or\n");
X  printf(
"    -u) with an input that is not segment-bounded--that is, if your input\n");
X  printf(
"    is a vertex set, or you're using the -c switch.  If the convex hull of\n"
);
X  printf(
"    your input vertices has collinear vertices on its boundary, an input\n");
X  printf(
"    vertex that you think lies on the convex hull might actually lie just\n");
X  printf(
"    inside the convex hull.  If so, the vertex and the nearby convex hull\n");
X  printf(
"    edge form an extremely thin triangle.  When Triangle tries to refine\n");
X  printf(
"    the mesh to enforce angle and area constraints, Triangle might generate\n"
);
X  printf(
"    extremely tiny triangles, or it might fail because of insufficient\n");
X  printf("    floating-point precision.\n\n");
X  printf(
"  `The numbering of the output vertices doesn't match the input vertices.'\n"
);
X  printf("\n");
X  printf(
"    You may have had duplicate input vertices, or you may have eaten some\n");
X  printf(
"    of your input vertices with a hole, or by placing them outside the area\n"
);
X  printf(
"    enclosed by segments.  In any case, you can solve the problem by not\n");
X  printf("    using the -j switch.\n\n");
X  printf(
"  `Triangle executes without incident, but when I look at the resulting\n");
X  printf(
"  mesh, it has overlapping triangles or other geometric inconsistencies.'\n");
X  printf("\n");
X  printf(
"    If you select the -X switch, Triangle occasionally makes mistakes due\n");
X  printf(
"    to floating-point roundoff error.  Although these errors are rare,\n");
X  printf(
"    don't use the -X switch.  If you still have problems, please report the\n"
);
X  printf("    bug.\n\n");
X  printf(
"  `Triangle executes without incident, but when I look at the resulting\n");
X  printf("  Voronoi diagram, it has overlapping edges or other geometric\n");
X  printf("  inconsistencies.'\n");
X  printf("\n");
X  printf(
"    If your input is a PSLG (-p), you can only expect a meaningful Voronoi\n"
);
X  printf(
"    diagram if the domain you are triangulating is convex and free of\n");
X  printf(
"    holes, and you use the -D switch to construct a conforming Delaunay\n");
X  printf("    triangulation (instead of a CDT or CCDT).\n\n");
X  printf(
"  Strange things can happen if you've taken liberties with your PSLG.  Do\n");
X  printf(
"  you have a vertex lying in the middle of a segment?  Triangle sometimes\n");
X  printf(
"  copes poorly with that sort of thing.  Do you want to lay out a collinear\n"
);
X  printf(
"  row of evenly spaced, segment-connected vertices?  Have you simply\n");
X  printf(
"  defined one long segment connecting the leftmost vertex to the rightmost\n"
);
X  printf(
"  vertex, and a bunch of vertices lying along it?  This method occasionally\n"
);
X  printf(
"  works, especially with horizontal and vertical lines, but often it\n");
X  printf(
"  doesn't, and you'll have to connect each adjacent pair of vertices with a\n"
);
X  printf("  separate segment.  If you don't like it, tough.\n\n");
X  printf(
"  Furthermore, if you have segments that intersect other than at their\n");
X  printf(
"  endpoints, try not to let the intersections fall extremely close to PSLG\n"
);
X  printf("  vertices or each other.\n\n");
X  printf(
"  If you have problems refining a triangulation not produced by Triangle:\n");
X  printf(
"  Are you sure the triangulation is geometrically valid?  Is it formatted\n");
X  printf(
"  correctly for Triangle?  Are the triangles all listed so the first three\n"
);
X  printf(
"  vertices are their corners in counterclockwise order?  Are all of the\n");
X  printf(
"  triangles constrained Delaunay?  Triangle's Delaunay refinement algorithm\n"
);
X  printf("  assumes that it starts with a CDT.\n\n");
X  printf("Show Me:\n\n");
X  printf(
"  Triangle comes with a separate program named `Show Me', whose primary\n");
X  printf(
"  purpose is to draw meshes on your screen or in PostScript.  Its secondary\n"
);
X  printf(
"  purpose is to check the validity of your input files, and do so more\n");
X  printf(
"  thoroughly than Triangle does.  Unlike Triangle, Show Me requires that\n");
X  printf(
"  you have the X Windows system.  Sorry, Microsoft Windows users.\n");
X  printf("\n");
X  printf("Triangle on the Web:\n");
X  printf("\n");
X  printf("  To see an illustrated version of these instructions, check out\n");
X  printf("\n");
X  printf("    http://www.cs.cmu.edu/~quake/triangle.html\n");
X  printf("\n");
X  printf("A Brief Plea:\n");
X  printf("\n");
X  printf(
"  If you use Triangle, and especially if you use it to accomplish real\n");
X  printf(
"  work, I would like very much to hear from you.  A short letter or email\n");
X  printf(
"  (to jrs@cs.berkeley.edu) describing how you use Triangle will mean a lot\n"
);
X  printf(
"  to me.  The more people I know are using this program, the more easily I\n"
);
X  printf(
"  can justify spending time on improvements, which in turn will benefit\n");
X  printf(
"  you.  Also, I can put you on a list to receive email whenever a new\n");
X  printf("  version of Triangle is available.\n\n");
X  printf(
"  If you use a mesh generated by Triangle in a publication, please include\n"
);
X  printf(
"  an acknowledgment as well.  And please spell Triangle with a capital `T'!\n"
);
X  printf(
"  If you want to include a citation, use `Jonathan Richard Shewchuk,\n");
X  printf(
"  ``Triangle: Engineering a 2D Quality Mesh Generator and Delaunay\n");
X  printf(
"  Triangulator,'' in Applied Computational Geometry:  Towards Geometric\n");
X  printf(
"  Engineering (Ming C. Lin and Dinesh Manocha, editors), volume 1148 of\n");
X  printf(
"  Lecture Notes in Computer Science, pages 203-222, Springer-Verlag,\n");
X  printf(
"  Berlin, May 1996.  (From the First ACM Workshop on Applied Computational\n"
);
X  printf("  Geometry.)'\n\n");
X  printf("Research credit:\n\n");
X  printf(
"  Of course, I can take credit for only a fraction of the ideas that made\n");
X  printf(
"  this mesh generator possible.  Triangle owes its existence to the efforts\n"
);
X  printf(
"  of many fine computational geometers and other researchers, including\n");
X  printf(
"  Marshall Bern, L. Paul Chew, Kenneth L. Clarkson, Boris Delaunay, Rex A.\n"
);
X  printf(
"  Dwyer, David Eppstein, Steven Fortune, Leonidas J. Guibas, Donald E.\n");
X  printf(
"  Knuth, Charles L. Lawson, Der-Tsai Lee, Gary L. Miller, Ernst P. Mucke,\n");
X  printf(
"  Steven E. Pav, Douglas M. Priest, Jim Ruppert, Isaac Saias, Bruce J.\n");
X  printf(
"  Schachter, Micha Sharir, Peter W. Shor, Daniel D. Sleator, Jorge Stolfi,\n"
);
X  printf("  Robert E. Tarjan, Alper Ungor, Christopher J. Van Wyk, Noel J.\n");
X  printf(
"  Walkington, and Binhai Zhu.  See the comments at the beginning of the\n");
X  printf("  source code for references.\n\n");
X  triexit(0);
}
X
#endif /* not TRILIBRARY */
X
/*****************************************************************************/
/*                                                                           */
/*  internalerror()   Ask the user to send me the defective product.  Exit.  */
/*                                                                           */
/*****************************************************************************/
X
void internalerror()
{
X  printf("  Please report this bug to jrs@cs.berkeley.edu\n");
X  printf("  Include the message above, your input data set, and the exact\n");
X  printf("    command line you used to run Triangle.\n");
X  triexit(1);
}
X
/*****************************************************************************/
/*                                                                           */
/*  parsecommandline()   Read the command line, identify switches, and set   */
/*                       up options and file names.                          */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
void parsecommandline(int argc, char **argv, struct behavior *b)
#else /* not ANSI_DECLARATORS */
void parsecommandline(argc, argv, b)
int argc;
char **argv;
struct behavior *b;
#endif /* not ANSI_DECLARATORS */
X
{
#ifdef TRILIBRARY
#define STARTINDEX 0
#else /* not TRILIBRARY */
#define STARTINDEX 1
X  int increment;
X  int meshnumber;
#endif /* not TRILIBRARY */
X  int i, j, k;
X  char workstring[FILENAMESIZE];
X
X  b->poly = b->refine = b->quality = 0;
X  b->vararea = b->fixedarea = b->usertest = 0;
X  b->regionattrib = b->convex = b->weighted = b->jettison = 0;
X  b->firstnumber = 1;
X  b->edgesout = b->voronoi = b->neighbors = b->geomview = 0;
X  b->nobound = b->nopolywritten = b->nonodewritten = b->noelewritten = 0;
X  b->noiterationnum = 0;
X  b->noholes = b->noexact = 0;
X  b->incremental = b->sweepline = 0;
X  b->dwyer = 1;
X  b->splitseg = 0;
X  b->docheck = 0;
X  b->nobisect = 0;
X  b->conformdel = 0;
X  b->steiner = -1;
X  b->order = 1;
X  b->minangle = 0.0;
X  b->maxarea = -1.0;
X  b->quiet = b->verbose = 0;
#ifndef TRILIBRARY
X  b->innodefilename[0] = '\0';
#endif /* not TRILIBRARY */
X
X  for (i = STARTINDEX; i < argc; i++) {
#ifndef TRILIBRARY
X    if (argv[i][0] == '-') {
#endif /* not TRILIBRARY */
X      for (j = STARTINDEX; argv[i][j] != '\0'; j++) {
X        if (argv[i][j] == 'p') {
X          b->poly = 1;
X	}
#ifndef CDT_ONLY
X        if (argv[i][j] == 'r') {
X          b->refine = 1;
X	}
X        if (argv[i][j] == 'q') {
X          b->quality = 1;
X          if (((argv[i][j + 1] >= '0') && (argv[i][j + 1] <= '9')) ||
X              (argv[i][j + 1] == '.')) {
X            k = 0;
X            while (((argv[i][j + 1] >= '0') && (argv[i][j + 1] <= '9')) ||
X                   (argv[i][j + 1] == '.')) {
X              j++;
X              workstring[k] = argv[i][j];
X              k++;
X            }
X            workstring[k] = '\0';
X            b->minangle = (REAL) strtod(workstring, (char **) NULL);
X	  } else {
X            b->minangle = 20.0;
X	  }
X	}
X        if (argv[i][j] == 'a') {
X          b->quality = 1;
X          if (((argv[i][j + 1] >= '0') && (argv[i][j + 1] <= '9')) ||
X              (argv[i][j + 1] == '.')) {
X            b->fixedarea = 1;
X            k = 0;
X            while (((argv[i][j + 1] >= '0') && (argv[i][j + 1] <= '9')) ||
X                   (argv[i][j + 1] == '.')) {
X              j++;
X              workstring[k] = argv[i][j];
X              k++;
X            }
X            workstring[k] = '\0';
X            b->maxarea = (REAL) strtod(workstring, (char **) NULL);
X            if (b->maxarea <= 0.0) {
X              printf("Error:  Maximum area must be greater than zero.\n");
X              triexit(1);
X	    }
X	  } else {
X            b->vararea = 1;
X	  }
X	}
X        if (argv[i][j] == 'u') {
X          b->quality = 1;
X          b->usertest = 1;
X        }
#endif /* not CDT_ONLY */
X        if (argv[i][j] == 'A') {
X          b->regionattrib = 1;
X        }
X        if (argv[i][j] == 'c') {
X          b->convex = 1;
X        }
X        if (argv[i][j] == 'w') {
X          b->weighted = 1;
X        }
X        if (argv[i][j] == 'W') {
X          b->weighted = 2;
X        }
X        if (argv[i][j] == 'j') {
X          b->jettison = 1;
X        }
X        if (argv[i][j] == 'z') {
X          b->firstnumber = 0;
X        }
X        if (argv[i][j] == 'e') {
X          b->edgesout = 1;
X	}
X        if (argv[i][j] == 'v') {
X          b->voronoi = 1;
X	}
X        if (argv[i][j] == 'n') {
X          b->neighbors = 1;
X	}
X        if (argv[i][j] == 'g') {
X          b->geomview = 1;
X	}
X        if (argv[i][j] == 'B') {
X          b->nobound = 1;
X	}
X        if (argv[i][j] == 'P') {
X          b->nopolywritten = 1;
X	}
X        if (argv[i][j] == 'N') {
X          b->nonodewritten = 1;
X	}
X        if (argv[i][j] == 'E') {
X          b->noelewritten = 1;
X	}
#ifndef TRILIBRARY
X        if (argv[i][j] == 'I') {
X          b->noiterationnum = 1;
X	}
#endif /* not TRILIBRARY */
X        if (argv[i][j] == 'O') {
X          b->noholes = 1;
X	}
X        if (argv[i][j] == 'X') {
X          b->noexact = 1;
X	}
X        if (argv[i][j] == 'o') {
X          if (argv[i][j + 1] == '2') {
X            j++;
X            b->order = 2;
X          }
X	}
#ifndef CDT_ONLY
X        if (argv[i][j] == 'Y') {
X          b->nobisect++;
X	}
X        if (argv[i][j] == 'S') {
X          b->steiner = 0;
X          while ((argv[i][j + 1] >= '0') && (argv[i][j + 1] <= '9')) {
X            j++;
X            b->steiner = b->steiner * 10 + (int) (argv[i][j] - '0');
X          }
X        }
#endif /* not CDT_ONLY */
#ifndef REDUCED
X        if (argv[i][j] == 'i') {
X          b->incremental = 1;
X        }
X        if (argv[i][j] == 'F') {
X          b->sweepline = 1;
X        }
#endif /* not REDUCED */
X        if (argv[i][j] == 'l') {
X          b->dwyer = 0;
X        }
#ifndef REDUCED
#ifndef CDT_ONLY
X        if (argv[i][j] == 's') {
X          b->splitseg = 1;
X        }
X        if ((argv[i][j] == 'D') || (argv[i][j] == 'L')) {
X          b->quality = 1;
X          b->conformdel = 1;
X        }
#endif /* not CDT_ONLY */
X        if (argv[i][j] == 'C') {
X          b->docheck = 1;
X        }
#endif /* not REDUCED */
X        if (argv[i][j] == 'Q') {
X          b->quiet = 1;
X        }
X        if (argv[i][j] == 'V') {
X          b->verbose++;
X        }
#ifndef TRILIBRARY
X        if ((argv[i][j] == 'h') || (argv[i][j] == 'H') ||
X            (argv[i][j] == '?')) {
X          info();
X	}
#endif /* not TRILIBRARY */
X      }
#ifndef TRILIBRARY
X    } else {
X      strncpy(b->innodefilename, argv[i], FILENAMESIZE - 1);
X      b->innodefilename[FILENAMESIZE - 1] = '\0';
X    }
#endif /* not TRILIBRARY */
X  }
#ifndef TRILIBRARY
X  if (b->innodefilename[0] == '\0') {
X    syntax();
X  }
X  if (!strcmp(&b->innodefilename[strlen(b->innodefilename) - 5], ".node")) {
X    b->innodefilename[strlen(b->innodefilename) - 5] = '\0';
X  }
X  if (!strcmp(&b->innodefilename[strlen(b->innodefilename) - 5], ".poly")) {
X    b->innodefilename[strlen(b->innodefilename) - 5] = '\0';
X    b->poly = 1;
X  }
#ifndef CDT_ONLY
X  if (!strcmp(&b->innodefilename[strlen(b->innodefilename) - 4], ".ele")) {
X    b->innodefilename[strlen(b->innodefilename) - 4] = '\0';
X    b->refine = 1;
X  }
X  if (!strcmp(&b->innodefilename[strlen(b->innodefilename) - 5], ".area")) {
X    b->innodefilename[strlen(b->innodefilename) - 5] = '\0';
X    b->refine = 1;
X    b->quality = 1;
X    b->vararea = 1;
X  }
#endif /* not CDT_ONLY */
#endif /* not TRILIBRARY */
X  b->usesegments = b->poly || b->refine || b->quality || b->convex;
X  b->goodangle = cos(b->minangle * PI / 180.0);
X  if (b->goodangle == 1.0) {
X    b->offconstant = 0.0;
X  } else {
X    b->offconstant = 0.475 * sqrt((1.0 + b->goodangle) / (1.0 - b->goodangle));
X  }
X  b->goodangle *= b->goodangle;
X  if (b->refine && b->noiterationnum) {
X    printf(
X      "Error:  You cannot use the -I switch when refining a triangulation.\n");
X    triexit(1);
X  }
X  /* Be careful not to allocate space for element area constraints that */
X  /*   will never be assigned any value (other than the default -1.0).  */
X  if (!b->refine && !b->poly) {
X    b->vararea = 0;
X  }
X  /* Be careful not to add an extra attribute to each element unless the */
X  /*   input supports it (PSLG in, but not refining a preexisting mesh). */
X  if (b->refine || !b->poly) {
X    b->regionattrib = 0;
X  }
X  /* Regular/weighted triangulations are incompatible with PSLGs */
X  /*   and meshing.                                              */
X  if (b->weighted && (b->poly || b->quality)) {
X    b->weighted = 0;
X    if (!b->quiet) {
X      printf("Warning:  weighted triangulations (-w, -W) are incompatible\n");
X      printf("  with PSLGs (-p) and meshing (-q, -a, -u).  Weights ignored.\n"
X             );
X    }
X  }
X  if (b->jettison && b->nonodewritten && !b->quiet) {
X    printf("Warning:  -j and -N switches are somewhat incompatible.\n");
X    printf("  If any vertices are jettisoned, you will need the output\n");
X    printf("  .node file to reconstruct the new node indices.");
X  }
X
#ifndef TRILIBRARY
X  strcpy(b->inpolyfilename, b->innodefilename);
X  strcpy(b->inelefilename, b->innodefilename);
X  strcpy(b->areafilename, b->innodefilename);
X  increment = 0;
X  strcpy(workstring, b->innodefilename);
X  j = 1;
X  while (workstring[j] != '\0') {
X    if ((workstring[j] == '.') && (workstring[j + 1] != '\0')) {
X      increment = j + 1;
X    }
X    j++;
X  }
X  meshnumber = 0;
X  if (increment > 0) {
X    j = increment;
X    do {
X      if ((workstring[j] >= '0') && (workstring[j] <= '9')) {
X        meshnumber = meshnumber * 10 + (int) (workstring[j] - '0');
X      } else {
X        increment = 0;
X      }
X      j++;
X    } while (workstring[j] != '\0');
X  }
X  if (b->noiterationnum) {
X    strcpy(b->outnodefilename, b->innodefilename);
X    strcpy(b->outelefilename, b->innodefilename);
X    strcpy(b->edgefilename, b->innodefilename);
X    strcpy(b->vnodefilename, b->innodefilename);
X    strcpy(b->vedgefilename, b->innodefilename);
X    strcpy(b->neighborfilename, b->innodefilename);
X    strcpy(b->offfilename, b->innodefilename);
X    strcat(b->outnodefilename, ".node");
X    strcat(b->outelefilename, ".ele");
X    strcat(b->edgefilename, ".edge");
X    strcat(b->vnodefilename, ".v.node");
X    strcat(b->vedgefilename, ".v.edge");
X    strcat(b->neighborfilename, ".neigh");
X    strcat(b->offfilename, ".off");
X  } else if (increment == 0) {
X    strcpy(b->outnodefilename, b->innodefilename);
X    strcpy(b->outpolyfilename, b->innodefilename);
X    strcpy(b->outelefilename, b->innodefilename);
X    strcpy(b->edgefilename, b->innodefilename);
X    strcpy(b->vnodefilename, b->innodefilename);
X    strcpy(b->vedgefilename, b->innodefilename);
X    strcpy(b->neighborfilename, b->innodefilename);
X    strcpy(b->offfilename, b->innodefilename);
X    strcat(b->outnodefilename, ".1.node");
X    strcat(b->outpolyfilename, ".1.poly");
X    strcat(b->outelefilename, ".1.ele");
X    strcat(b->edgefilename, ".1.edge");
X    strcat(b->vnodefilename, ".1.v.node");
X    strcat(b->vedgefilename, ".1.v.edge");
X    strcat(b->neighborfilename, ".1.neigh");
X    strcat(b->offfilename, ".1.off");
X  } else {
X    workstring[increment] = '%';
X    workstring[increment + 1] = 'd';
X    workstring[increment + 2] = '\0';
X    sprintf(b->outnodefilename, workstring, meshnumber + 1);
X    strcpy(b->outpolyfilename, b->outnodefilename);
X    strcpy(b->outelefilename, b->outnodefilename);
X    strcpy(b->edgefilename, b->outnodefilename);
X    strcpy(b->vnodefilename, b->outnodefilename);
X    strcpy(b->vedgefilename, b->outnodefilename);
X    strcpy(b->neighborfilename, b->outnodefilename);
X    strcpy(b->offfilename, b->outnodefilename);
X    strcat(b->outnodefilename, ".node");
X    strcat(b->outpolyfilename, ".poly");
X    strcat(b->outelefilename, ".ele");
X    strcat(b->edgefilename, ".edge");
X    strcat(b->vnodefilename, ".v.node");
X    strcat(b->vedgefilename, ".v.edge");
X    strcat(b->neighborfilename, ".neigh");
X    strcat(b->offfilename, ".off");
X  }
X  strcat(b->innodefilename, ".node");
X  strcat(b->inpolyfilename, ".poly");
X  strcat(b->inelefilename, ".ele");
X  strcat(b->areafilename, ".area");
#endif /* not TRILIBRARY */
}
X
/**                                                                         **/
/**                                                                         **/
/********* User interaction routines begin here                      *********/
X
/********* Debugging routines begin here                             *********/
/**                                                                         **/
/**                                                                         **/
X
/*****************************************************************************/
/*                                                                           */
/*  printtriangle()   Print out the details of an oriented triangle.         */
/*                                                                           */
/*  I originally wrote this procedure to simplify debugging; it can be       */
/*  called directly from the debugger, and presents information about an     */
/*  oriented triangle in digestible form.  It's also used when the           */
/*  highest level of verbosity (`-VVV') is specified.                        */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
void printtriangle(struct mesh *m, struct behavior *b, struct otri *t)
#else /* not ANSI_DECLARATORS */
void printtriangle(m, b, t)
struct mesh *m;
struct behavior *b;
struct otri *t;
#endif /* not ANSI_DECLARATORS */
X
{
X  struct otri printtri;
X  struct osub printsh;
X  vertex printvertex;
X
X  printf("triangle x%lx with orientation %d:\n", (unsigned long) t->tri,
X         t->orient);
X  decode(t->tri[0], printtri);
X  if (printtri.tri == m->dummytri) {
X    printf("    [0] = Outer space\n");
X  } else {
X    printf("    [0] = x%lx  %d\n", (unsigned long) printtri.tri,
X           printtri.orient);
X  }
X  decode(t->tri[1], printtri);
X  if (printtri.tri == m->dummytri) {
X    printf("    [1] = Outer space\n");
X  } else {
X    printf("    [1] = x%lx  %d\n", (unsigned long) printtri.tri,
X           printtri.orient);
X  }
X  decode(t->tri[2], printtri);
X  if (printtri.tri == m->dummytri) {
X    printf("    [2] = Outer space\n");
X  } else {
X    printf("    [2] = x%lx  %d\n", (unsigned long) printtri.tri,
X           printtri.orient);
X  }
X
X  org(*t, printvertex);
X  if (printvertex == (vertex) NULL)
X    printf("    Origin[%d] = NULL\n", (t->orient + 1) % 3 + 3);
X  else
X    printf("    Origin[%d] = x%lx  (%.12g, %.12g)\n",
X           (t->orient + 1) % 3 + 3, (unsigned long) printvertex,
X           printvertex[0], printvertex[1]);
X  dest(*t, printvertex);
X  if (printvertex == (vertex) NULL)
X    printf("    Dest  [%d] = NULL\n", (t->orient + 2) % 3 + 3);
X  else
X    printf("    Dest  [%d] = x%lx  (%.12g, %.12g)\n",
X           (t->orient + 2) % 3 + 3, (unsigned long) printvertex,
X           printvertex[0], printvertex[1]);
X  apex(*t, printvertex);
X  if (printvertex == (vertex) NULL)
X    printf("    Apex  [%d] = NULL\n", t->orient + 3);
X  else
X    printf("    Apex  [%d] = x%lx  (%.12g, %.12g)\n",
X           t->orient + 3, (unsigned long) printvertex,
X           printvertex[0], printvertex[1]);
X
X  if (b->usesegments) {
X    sdecode(t->tri[6], printsh);
X    if (printsh.ss != m->dummysub) {
X      printf("    [6] = x%lx  %d\n", (unsigned long) printsh.ss,
X             printsh.ssorient);
X    }
X    sdecode(t->tri[7], printsh);
X    if (printsh.ss != m->dummysub) {
X      printf("    [7] = x%lx  %d\n", (unsigned long) printsh.ss,
X             printsh.ssorient);
X    }
X    sdecode(t->tri[8], printsh);
X    if (printsh.ss != m->dummysub) {
X      printf("    [8] = x%lx  %d\n", (unsigned long) printsh.ss,
X             printsh.ssorient);
X    }
X  }
X
X  if (b->vararea) {
X    printf("    Area constraint:  %.4g\n", areabound(*t));
X  }
}
X
/*****************************************************************************/
/*                                                                           */
/*  printsubseg()   Print out the details of an oriented subsegment.         */
/*                                                                           */
/*  I originally wrote this procedure to simplify debugging; it can be       */
/*  called directly from the debugger, and presents information about an     */
/*  oriented subsegment in digestible form.  It's also used when the highest */
/*  level of verbosity (`-VVV') is specified.                                */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
void printsubseg(struct mesh *m, struct behavior *b, struct osub *s)
#else /* not ANSI_DECLARATORS */
void printsubseg(m, b, s)
struct mesh *m;
struct behavior *b;
struct osub *s;
#endif /* not ANSI_DECLARATORS */
X
{
X  struct osub printsh;
X  struct otri printtri;
X  vertex printvertex;
X
X  printf("subsegment x%lx with orientation %d and mark %d:\n",
X         (unsigned long) s->ss, s->ssorient, mark(*s));
X  sdecode(s->ss[0], printsh);
X  if (printsh.ss == m->dummysub) {
X    printf("    [0] = No subsegment\n");
X  } else {
X    printf("    [0] = x%lx  %d\n", (unsigned long) printsh.ss,
X           printsh.ssorient);
X  }
X  sdecode(s->ss[1], printsh);
X  if (printsh.ss == m->dummysub) {
X    printf("    [1] = No subsegment\n");
X  } else {
X    printf("    [1] = x%lx  %d\n", (unsigned long) printsh.ss,
X           printsh.ssorient);
X  }
X
X  sorg(*s, printvertex);
X  if (printvertex == (vertex) NULL)
X    printf("    Origin[%d] = NULL\n", 2 + s->ssorient);
X  else
X    printf("    Origin[%d] = x%lx  (%.12g, %.12g)\n",
X           2 + s->ssorient, (unsigned long) printvertex,
X           printvertex[0], printvertex[1]);
X  sdest(*s, printvertex);
X  if (printvertex == (vertex) NULL)
X    printf("    Dest  [%d] = NULL\n", 3 - s->ssorient);
X  else
X    printf("    Dest  [%d] = x%lx  (%.12g, %.12g)\n",
X           3 - s->ssorient, (unsigned long) printvertex,
X           printvertex[0], printvertex[1]);
X
X  decode(s->ss[6], printtri);
X  if (printtri.tri == m->dummytri) {
X    printf("    [6] = Outer space\n");
X  } else {
X    printf("    [6] = x%lx  %d\n", (unsigned long) printtri.tri,
X           printtri.orient);
X  }
X  decode(s->ss[7], printtri);
X  if (printtri.tri == m->dummytri) {
X    printf("    [7] = Outer space\n");
X  } else {
X    printf("    [7] = x%lx  %d\n", (unsigned long) printtri.tri,
X           printtri.orient);
X  }
X
X  segorg(*s, printvertex);
X  if (printvertex == (vertex) NULL)
X    printf("    Segment origin[%d] = NULL\n", 4 + s->ssorient);
X  else
X    printf("    Segment origin[%d] = x%lx  (%.12g, %.12g)\n",
X           4 + s->ssorient, (unsigned long) printvertex,
X           printvertex[0], printvertex[1]);
X  segdest(*s, printvertex);
X  if (printvertex == (vertex) NULL)
X    printf("    Segment dest  [%d] = NULL\n", 5 - s->ssorient);
X  else
X    printf("    Segment dest  [%d] = x%lx  (%.12g, %.12g)\n",
X           5 - s->ssorient, (unsigned long) printvertex,
X           printvertex[0], printvertex[1]);
}
X
/**                                                                         **/
/**                                                                         **/
/********* Debugging routines end here                               *********/
X
/********* Memory management routines begin here                     *********/
/**                                                                         **/
/**                                                                         **/
X
/*****************************************************************************/
/*                                                                           */
/*  poolzero()   Set all of a pool's fields to zero.                         */
/*                                                                           */
/*  This procedure should never be called on a pool that has any memory      */
/*  allocated to it, as that memory would leak.                              */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
void poolzero(struct memorypool *pool)
#else /* not ANSI_DECLARATORS */
void poolzero(pool)
struct memorypool *pool;
#endif /* not ANSI_DECLARATORS */
X
{
X  pool->firstblock = (VOID **) NULL;
X  pool->nowblock = (VOID **) NULL;
X  pool->nextitem = (VOID *) NULL;
X  pool->deaditemstack = (VOID *) NULL;
X  pool->pathblock = (VOID **) NULL;
X  pool->pathitem = (VOID *) NULL;
X  pool->alignbytes = 0;
X  pool->itembytes = 0;
X  pool->itemsperblock = 0;
X  pool->itemsfirstblock = 0;
X  pool->items = 0;
X  pool->maxitems = 0;
X  pool->unallocateditems = 0;
X  pool->pathitemsleft = 0;
}
X
/*****************************************************************************/
/*                                                                           */
/*  poolrestart()   Deallocate all items in a pool.                          */
/*                                                                           */
/*  The pool is returned to its starting state, except that no memory is     */
/*  freed to the operating system.  Rather, the previously allocated blocks  */
/*  are ready to be reused.                                                  */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
void poolrestart(struct memorypool *pool)
#else /* not ANSI_DECLARATORS */
void poolrestart(pool)
struct memorypool *pool;
#endif /* not ANSI_DECLARATORS */
X
{
X  unsigned long alignptr;
X
X  pool->items = 0;
X  pool->maxitems = 0;
X
X  /* Set the currently active block. */
X  pool->nowblock = pool->firstblock;
X  /* Find the first item in the pool.  Increment by the size of (VOID *). */
X  alignptr = (unsigned long) (pool->nowblock + 1);
X  /* Align the item on an `alignbytes'-byte boundary. */
X  pool->nextitem = (VOID *)
X    (alignptr + (unsigned long) pool->alignbytes -
X     (alignptr % (unsigned long) pool->alignbytes));
X  /* There are lots of unallocated items left in this block. */
X  pool->unallocateditems = pool->itemsfirstblock;
X  /* The stack of deallocated items is empty. */
X  pool->deaditemstack = (VOID *) NULL;
}
X
/*****************************************************************************/
/*                                                                           */
/*  poolinit()   Initialize a pool of memory for allocation of items.        */
/*                                                                           */
/*  This routine initializes the machinery for allocating items.  A `pool'   */
/*  is created whose records have size at least `bytecount'.  Items will be  */
/*  allocated in `itemcount'-item blocks.  Each item is assumed to be a      */
/*  collection of words, and either pointers or floating-point values are    */
/*  assumed to be the "primary" word type.  (The "primary" word type is used */
/*  to determine alignment of items.)  If `alignment' isn't zero, all items  */
/*  will be `alignment'-byte aligned in memory.  `alignment' must be either  */
/*  a multiple or a factor of the primary word size; powers of two are safe. */
/*  `alignment' is normally used to create a few unused bits at the bottom   */
/*  of each item's pointer, in which information may be stored.              */
/*                                                                           */
/*  Don't change this routine unless you understand it.                      */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
void poolinit(struct memorypool *pool, int bytecount, int itemcount,
X              int firstitemcount, int alignment)
#else /* not ANSI_DECLARATORS */
void poolinit(pool, bytecount, itemcount, firstitemcount, alignment)
struct memorypool *pool;
int bytecount;
int itemcount;
int firstitemcount;
int alignment;
#endif /* not ANSI_DECLARATORS */
X
{
X  /* Find the proper alignment, which must be at least as large as:   */
X  /*   - The parameter `alignment'.                                   */
X  /*   - sizeof(VOID *), so the stack of dead items can be maintained */
X  /*       without unaligned accesses.                                */
X  if (alignment > sizeof(VOID *)) {
X    pool->alignbytes = alignment;
X  } else {
X    pool->alignbytes = sizeof(VOID *);
X  }
X  pool->itembytes = ((bytecount - 1) / pool->alignbytes + 1) *
X                    pool->alignbytes;
X  pool->itemsperblock = itemcount;
X  if (firstitemcount == 0) {
X    pool->itemsfirstblock = itemcount;
X  } else {
X    pool->itemsfirstblock = firstitemcount;
X  }
X
X  /* Allocate a block of items.  Space for `itemsfirstblock' items and one  */
X  /*   pointer (to point to the next block) are allocated, as well as space */
X  /*   to ensure alignment of the items.                                    */
X  pool->firstblock = (VOID **)
X    trimalloc(pool->itemsfirstblock * pool->itembytes + (int) sizeof(VOID *) +
X              pool->alignbytes);
X  /* Set the next block pointer to NULL. */
X  *(pool->firstblock) = (VOID *) NULL;
X  poolrestart(pool);
}
X
/*****************************************************************************/
/*                                                                           */
/*  pooldeinit()   Free to the operating system all memory taken by a pool.  */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
void pooldeinit(struct memorypool *pool)
#else /* not ANSI_DECLARATORS */
void pooldeinit(pool)
struct memorypool *pool;
#endif /* not ANSI_DECLARATORS */
X
{
X  while (pool->firstblock != (VOID **) NULL) {
X    pool->nowblock = (VOID **) *(pool->firstblock);
X    trifree((VOID *) pool->firstblock);
X    pool->firstblock = pool->nowblock;
X  }
}
X
/*****************************************************************************/
/*                                                                           */
/*  poolalloc()   Allocate space for an item.                                */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
VOID *poolalloc(struct memorypool *pool)
#else /* not ANSI_DECLARATORS */
VOID *poolalloc(pool)
struct memorypool *pool;
#endif /* not ANSI_DECLARATORS */
X
{
X  VOID *newitem;
X  VOID **newblock;
X  unsigned long alignptr;
X
X  /* First check the linked list of dead items.  If the list is not   */
X  /*   empty, allocate an item from the list rather than a fresh one. */
X  if (pool->deaditemstack != (VOID *) NULL) {
X    newitem = pool->deaditemstack;               /* Take first item in list. */
X    pool->deaditemstack = * (VOID **) pool->deaditemstack;
X  } else {
X    /* Check if there are any free items left in the current block. */
X    if (pool->unallocateditems == 0) {
X      /* Check if another block must be allocated. */
X      if (*(pool->nowblock) == (VOID *) NULL) {
X        /* Allocate a new block of items, pointed to by the previous block. */
X        newblock = (VOID **) trimalloc(pool->itemsperblock * pool->itembytes +
X                                       (int) sizeof(VOID *) +
X                                       pool->alignbytes);
X        *(pool->nowblock) = (VOID *) newblock;
X        /* The next block pointer is NULL. */
X        *newblock = (VOID *) NULL;
X      }
X
X      /* Move to the new block. */
X      pool->nowblock = (VOID **) *(pool->nowblock);
X      /* Find the first item in the block.    */
X      /*   Increment by the size of (VOID *). */
X      alignptr = (unsigned long) (pool->nowblock + 1);
X      /* Align the item on an `alignbytes'-byte boundary. */
X      pool->nextitem = (VOID *)
X        (alignptr + (unsigned long) pool->alignbytes -
X         (alignptr % (unsigned long) pool->alignbytes));
X      /* There are lots of unallocated items left in this block. */
X      pool->unallocateditems = pool->itemsperblock;
X    }
X
X    /* Allocate a new item. */
X    newitem = pool->nextitem;
X    /* Advance `nextitem' pointer to next free item in block. */
X    pool->nextitem = (VOID *) ((char *) pool->nextitem + pool->itembytes);
X    pool->unallocateditems--;
X    pool->maxitems++;
X  }
X  pool->items++;
X  return newitem;
}
X
/*****************************************************************************/
/*                                                                           */
/*  pooldealloc()   Deallocate space for an item.                            */
/*                                                                           */
/*  The deallocated space is stored in a queue for later reuse.              */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
void pooldealloc(struct memorypool *pool, VOID *dyingitem)
#else /* not ANSI_DECLARATORS */
void pooldealloc(pool, dyingitem)
struct memorypool *pool;
VOID *dyingitem;
#endif /* not ANSI_DECLARATORS */
X
{
X  /* Push freshly killed item onto stack. */
X  *((VOID **) dyingitem) = pool->deaditemstack;
X  pool->deaditemstack = dyingitem;
X  pool->items--;
}
X
/*****************************************************************************/
/*                                                                           */
/*  traversalinit()   Prepare to traverse the entire list of items.          */
/*                                                                           */
/*  This routine is used in conjunction with traverse().                     */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
void traversalinit(struct memorypool *pool)
#else /* not ANSI_DECLARATORS */
void traversalinit(pool)
struct memorypool *pool;
#endif /* not ANSI_DECLARATORS */
X
{
X  unsigned long alignptr;
X
X  /* Begin the traversal in the first block. */
X  pool->pathblock = pool->firstblock;
X  /* Find the first item in the block.  Increment by the size of (VOID *). */
X  alignptr = (unsigned long) (pool->pathblock + 1);
X  /* Align with item on an `alignbytes'-byte boundary. */
X  pool->pathitem = (VOID *)
X    (alignptr + (unsigned long) pool->alignbytes -
X     (alignptr % (unsigned long) pool->alignbytes));
X  /* Set the number of items left in the current block. */
X  pool->pathitemsleft = pool->itemsfirstblock;
}
X
/*****************************************************************************/
/*                                                                           */
/*  traverse()   Find the next item in the list.                             */
/*                                                                           */
/*  This routine is used in conjunction with traversalinit().  Be forewarned */
/*  that this routine successively returns all items in the list, including  */
/*  deallocated ones on the deaditemqueue.  It's up to you to figure out     */
/*  which ones are actually dead.  Why?  I don't want to allocate extra      */
/*  space just to demarcate dead items.  It can usually be done more         */
/*  space-efficiently by a routine that knows something about the structure  */
/*  of the item.                                                             */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
VOID *traverse(struct memorypool *pool)
#else /* not ANSI_DECLARATORS */
VOID *traverse(pool)
struct memorypool *pool;
#endif /* not ANSI_DECLARATORS */
X
{
X  VOID *newitem;
X  unsigned long alignptr;
X
X  /* Stop upon exhausting the list of items. */
X  if (pool->pathitem == pool->nextitem) {
X    return (VOID *) NULL;
X  }
X
X  /* Check whether any untraversed items remain in the current block. */
X  if (pool->pathitemsleft == 0) {
X    /* Find the next block. */
X    pool->pathblock = (VOID **) *(pool->pathblock);
X    /* Find the first item in the block.  Increment by the size of (VOID *). */
X    alignptr = (unsigned long) (pool->pathblock + 1);
X    /* Align with item on an `alignbytes'-byte boundary. */
X    pool->pathitem = (VOID *)
X      (alignptr + (unsigned long) pool->alignbytes -
X       (alignptr % (unsigned long) pool->alignbytes));
X    /* Set the number of items left in the current block. */
X    pool->pathitemsleft = pool->itemsperblock;
X  }
X
X  newitem = pool->pathitem;
X  /* Find the next item in the block. */
X  pool->pathitem = (VOID *) ((char *) pool->pathitem + pool->itembytes);
X  pool->pathitemsleft--;
X  return newitem;
}
X
/*****************************************************************************/
/*                                                                           */
/*  dummyinit()   Initialize the triangle that fills "outer space" and the   */
/*                omnipresent subsegment.                                    */
/*                                                                           */
/*  The triangle that fills "outer space," called `dummytri', is pointed to  */
/*  by every triangle and subsegment on a boundary (be it outer or inner) of */
/*  the triangulation.  Also, `dummytri' points to one of the triangles on   */
/*  the convex hull (until the holes and concavities are carved), making it  */
/*  possible to find a starting triangle for point location.                 */
/*                                                                           */
/*  The omnipresent subsegment, `dummysub', is pointed to by every triangle  */
/*  or subsegment that doesn't have a full complement of real subsegments    */
/*  to point to.                                                             */
/*                                                                           */
/*  `dummytri' and `dummysub' are generally required to fulfill only a few   */
/*  invariants:  their vertices must remain NULL and `dummytri' must always  */
/*  be bonded (at offset zero) to some triangle on the convex hull of the    */
/*  mesh, via a boundary edge.  Otherwise, the connections of `dummytri' and */
/*  `dummysub' may change willy-nilly.  This makes it possible to avoid      */
/*  writing a good deal of special-case code (in the edge flip, for example) */
/*  for dealing with the boundary of the mesh, places where no subsegment is */
/*  present, and so forth.  Other entities are frequently bonded to          */
/*  `dummytri' and `dummysub' as if they were real mesh entities, with no    */
/*  harm done.                                                               */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
void dummyinit(struct mesh *m, struct behavior *b, int trianglebytes,
X               int subsegbytes)
#else /* not ANSI_DECLARATORS */
void dummyinit(m, b, trianglebytes, subsegbytes)
struct mesh *m;
struct behavior *b;
int trianglebytes;
int subsegbytes;
#endif /* not ANSI_DECLARATORS */
X
{
X  unsigned long alignptr;
X
X  /* Set up `dummytri', the `triangle' that occupies "outer space." */
X  m->dummytribase = (triangle *) trimalloc(trianglebytes +
X                                           m->triangles.alignbytes);
X  /* Align `dummytri' on a `triangles.alignbytes'-byte boundary. */
X  alignptr = (unsigned long) m->dummytribase;
X  m->dummytri = (triangle *)
X    (alignptr + (unsigned long) m->triangles.alignbytes -
X     (alignptr % (unsigned long) m->triangles.alignbytes));
X  /* Initialize the three adjoining triangles to be "outer space."  These  */
X  /*   will eventually be changed by various bonding operations, but their */
X  /*   values don't really matter, as long as they can legally be          */
X  /*   dereferenced.                                                       */
X  m->dummytri[0] = (triangle) m->dummytri;
X  m->dummytri[1] = (triangle) m->dummytri;
X  m->dummytri[2] = (triangle) m->dummytri;
X  /* Three NULL vertices. */
X  m->dummytri[3] = (triangle) NULL;
X  m->dummytri[4] = (triangle) NULL;
X  m->dummytri[5] = (triangle) NULL;
X
X  if (b->usesegments) {
X    /* Set up `dummysub', the omnipresent subsegment pointed to by any */
X    /*   triangle side or subsegment end that isn't attached to a real */
X    /*   subsegment.                                                   */
X    m->dummysubbase = (subseg *) trimalloc(subsegbytes +
X                                           m->subsegs.alignbytes);
X    /* Align `dummysub' on a `subsegs.alignbytes'-byte boundary. */
X    alignptr = (unsigned long) m->dummysubbase;
X    m->dummysub = (subseg *)
X      (alignptr + (unsigned long) m->subsegs.alignbytes -
X       (alignptr % (unsigned long) m->subsegs.alignbytes));
X    /* Initialize the two adjoining subsegments to be the omnipresent      */
X    /*   subsegment.  These will eventually be changed by various bonding  */
X    /*   operations, but their values don't really matter, as long as they */
X    /*   can legally be dereferenced.                                      */
X    m->dummysub[0] = (subseg) m->dummysub;
X    m->dummysub[1] = (subseg) m->dummysub;
X    /* Four NULL vertices. */
X    m->dummysub[2] = (subseg) NULL;
X    m->dummysub[3] = (subseg) NULL;
X    m->dummysub[4] = (subseg) NULL;
X    m->dummysub[5] = (subseg) NULL;
X    /* Initialize the two adjoining triangles to be "outer space." */
X    m->dummysub[6] = (subseg) m->dummytri;
X    m->dummysub[7] = (subseg) m->dummytri;
X    /* Set the boundary marker to zero. */
X    * (int *) (m->dummysub + 8) = 0;
X
X    /* Initialize the three adjoining subsegments of `dummytri' to be */
X    /*   the omnipresent subsegment.                                  */
X    m->dummytri[6] = (triangle) m->dummysub;
X    m->dummytri[7] = (triangle) m->dummysub;
X    m->dummytri[8] = (triangle) m->dummysub;
X  }
}
X
/*****************************************************************************/
/*                                                                           */
/*  initializevertexpool()   Calculate the size of the vertex data structure */
/*                           and initialize its memory pool.                 */
/*                                                                           */
/*  This routine also computes the `vertexmarkindex' and `vertex2triindex'   */
/*  indices used to find values within each vertex.                          */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
void initializevertexpool(struct mesh *m, struct behavior *b)
#else /* not ANSI_DECLARATORS */
void initializevertexpool(m, b)
struct mesh *m;
struct behavior *b;
#endif /* not ANSI_DECLARATORS */
X
{
X  int vertexsize;
X
X  /* The index within each vertex at which the boundary marker is found,    */
X  /*   followed by the vertex type.  Ensure the vertex marker is aligned to */
X  /*   a sizeof(int)-byte address.                                          */
X  m->vertexmarkindex = ((m->mesh_dim + m->nextras) * sizeof(REAL) +
X                        sizeof(int) - 1) /
X                       sizeof(int);
X  vertexsize = (m->vertexmarkindex + 2) * sizeof(int);
X  if (b->poly) {
X    /* The index within each vertex at which a triangle pointer is found.  */
X    /*   Ensure the pointer is aligned to a sizeof(triangle)-byte address. */
X    m->vertex2triindex = (vertexsize + sizeof(triangle) - 1) /
X                         sizeof(triangle);
X    vertexsize = (m->vertex2triindex + 1) * sizeof(triangle);
X  }
X
X  /* Initialize the pool of vertices. */
X  poolinit(&m->vertices, vertexsize, VERTEXPERBLOCK,
X           m->invertices > VERTEXPERBLOCK ? m->invertices : VERTEXPERBLOCK,
X           sizeof(REAL));
}
X
/*****************************************************************************/
/*                                                                           */
/*  initializetrisubpools()   Calculate the sizes of the triangle and        */
/*                            subsegment data structures and initialize      */
/*                            their memory pools.                            */
/*                                                                           */
/*  This routine also computes the `highorderindex', `elemattribindex', and  */
/*  `areaboundindex' indices used to find values within each triangle.       */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
void initializetrisubpools(struct mesh *m, struct behavior *b)
#else /* not ANSI_DECLARATORS */
void initializetrisubpools(m, b)
struct mesh *m;
struct behavior *b;
#endif /* not ANSI_DECLARATORS */
X
{
X  int trisize;
X
X  /* The index within each triangle at which the extra nodes (above three)  */
X  /*   associated with high order elements are found.  There are three      */
X  /*   pointers to other triangles, three pointers to corners, and possibly */
X  /*   three pointers to subsegments before the extra nodes.                */
X  m->highorderindex = 6 + (b->usesegments * 3);
X  /* The number of bytes occupied by a triangle. */
X  trisize = ((b->order + 1) * (b->order + 2) / 2 + (m->highorderindex - 3)) *
X            sizeof(triangle);
X  /* The index within each triangle at which its attributes are found, */
X  /*   where the index is measured in REALs.                           */
X  m->elemattribindex = (trisize + sizeof(REAL) - 1) / sizeof(REAL);
X  /* The index within each triangle at which the maximum area constraint  */
X  /*   is found, where the index is measured in REALs.  Note that if the  */
X  /*   `regionattrib' flag is set, an additional attribute will be added. */
X  m->areaboundindex = m->elemattribindex + m->eextras + b->regionattrib;
X  /* If triangle attributes or an area bound are needed, increase the number */
X  /*   of bytes occupied by a triangle.                                      */
X  if (b->vararea) {
X    trisize = (m->areaboundindex + 1) * sizeof(REAL);
X  } else if (m->eextras + b->regionattrib > 0) {
X    trisize = m->areaboundindex * sizeof(REAL);
X  }
X  /* If a Voronoi diagram or triangle neighbor graph is requested, make    */
X  /*   sure there's room to store an integer index in each triangle.  This */
X  /*   integer index can occupy the same space as the subsegment pointers  */
X  /*   or attributes or area constraint or extra nodes.                    */
X  if ((b->voronoi || b->neighbors) &&
X      (trisize < 6 * sizeof(triangle) + sizeof(int))) {
X    trisize = 6 * sizeof(triangle) + sizeof(int);
X  }
X
X  /* Having determined the memory size of a triangle, initialize the pool. */
X  poolinit(&m->triangles, trisize, TRIPERBLOCK,
X           (2 * m->invertices - 2) > TRIPERBLOCK ? (2 * m->invertices - 2) :
X           TRIPERBLOCK, 4);
X
X  if (b->usesegments) {
X    /* Initialize the pool of subsegments.  Take into account all eight */
X    /*   pointers and one boundary marker.                              */
X    poolinit(&m->subsegs, 8 * sizeof(triangle) + sizeof(int),
X             SUBSEGPERBLOCK, SUBSEGPERBLOCK, 4);
X
X    /* Initialize the "outer space" triangle and omnipresent subsegment. */
X    dummyinit(m, b, m->triangles.itembytes, m->subsegs.itembytes);
X  } else {
X    /* Initialize the "outer space" triangle. */
X    dummyinit(m, b, m->triangles.itembytes, 0);
X  }
}
X
/*****************************************************************************/
/*                                                                           */
/*  triangledealloc()   Deallocate space for a triangle, marking it dead.    */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
void triangledealloc(struct mesh *m, triangle *dyingtriangle)
#else /* not ANSI_DECLARATORS */
void triangledealloc(m, dyingtriangle)
struct mesh *m;
triangle *dyingtriangle;
#endif /* not ANSI_DECLARATORS */
X
{
X  /* Mark the triangle as dead.  This makes it possible to detect dead */
X  /*   triangles when traversing the list of all triangles.            */
X  killtri(dyingtriangle);
X  pooldealloc(&m->triangles, (VOID *) dyingtriangle);
}
X
/*****************************************************************************/
/*                                                                           */
/*  triangletraverse()   Traverse the triangles, skipping dead ones.         */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
triangle *triangletraverse(struct mesh *m)
#else /* not ANSI_DECLARATORS */
triangle *triangletraverse(m)
struct mesh *m;
#endif /* not ANSI_DECLARATORS */
X
{
X  triangle *newtriangle;
X
X  do {
X    newtriangle = (triangle *) traverse(&m->triangles);
X    if (newtriangle == (triangle *) NULL) {
X      return (triangle *) NULL;
X    }
X  } while (deadtri(newtriangle));                         /* Skip dead ones. */
X  return newtriangle;
}
X
/*****************************************************************************/
/*                                                                           */
/*  subsegdealloc()   Deallocate space for a subsegment, marking it dead.    */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
void subsegdealloc(struct mesh *m, subseg *dyingsubseg)
#else /* not ANSI_DECLARATORS */
void subsegdealloc(m, dyingsubseg)
struct mesh *m;
subseg *dyingsubseg;
#endif /* not ANSI_DECLARATORS */
X
{
X  /* Mark the subsegment as dead.  This makes it possible to detect dead */
X  /*   subsegments when traversing the list of all subsegments.          */
X  killsubseg(dyingsubseg);
X  pooldealloc(&m->subsegs, (VOID *) dyingsubseg);
}
X
/*****************************************************************************/
/*                                                                           */
/*  subsegtraverse()   Traverse the subsegments, skipping dead ones.         */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
subseg *subsegtraverse(struct mesh *m)
#else /* not ANSI_DECLARATORS */
subseg *subsegtraverse(m)
struct mesh *m;
#endif /* not ANSI_DECLARATORS */
X
{
X  subseg *newsubseg;
X
X  do {
X    newsubseg = (subseg *) traverse(&m->subsegs);
X    if (newsubseg == (subseg *) NULL) {
X      return (subseg *) NULL;
X    }
X  } while (deadsubseg(newsubseg));                        /* Skip dead ones. */
X  return newsubseg;
}
X
/*****************************************************************************/
/*                                                                           */
/*  vertexdealloc()   Deallocate space for a vertex, marking it dead.        */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
void vertexdealloc(struct mesh *m, vertex dyingvertex)
#else /* not ANSI_DECLARATORS */
void vertexdealloc(m, dyingvertex)
struct mesh *m;
vertex dyingvertex;
#endif /* not ANSI_DECLARATORS */
X
{
X  /* Mark the vertex as dead.  This makes it possible to detect dead */
X  /*   vertices when traversing the list of all vertices.            */
X  setvertextype(dyingvertex, DEADVERTEX);
X  pooldealloc(&m->vertices, (VOID *) dyingvertex);
}
X
/*****************************************************************************/
/*                                                                           */
/*  vertextraverse()   Traverse the vertices, skipping dead ones.            */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
vertex vertextraverse(struct mesh *m)
#else /* not ANSI_DECLARATORS */
vertex vertextraverse(m)
struct mesh *m;
#endif /* not ANSI_DECLARATORS */
X
{
X  vertex newvertex;
X
X  do {
X    newvertex = (vertex) traverse(&m->vertices);
X    if (newvertex == (vertex) NULL) {
X      return (vertex) NULL;
X    }
X  } while (vertextype(newvertex) == DEADVERTEX);          /* Skip dead ones. */
X  return newvertex;
}
X
/*****************************************************************************/
/*                                                                           */
/*  badsubsegdealloc()   Deallocate space for a bad subsegment, marking it   */
/*                       dead.                                               */
/*                                                                           */
/*****************************************************************************/
X
#ifndef CDT_ONLY
X
#ifdef ANSI_DECLARATORS
void badsubsegdealloc(struct mesh *m, struct badsubseg *dyingseg)
#else /* not ANSI_DECLARATORS */
void badsubsegdealloc(m, dyingseg)
struct mesh *m;
struct badsubseg *dyingseg;
#endif /* not ANSI_DECLARATORS */
X
{
X  /* Set subsegment's origin to NULL.  This makes it possible to detect dead */
X  /*   badsubsegs when traversing the list of all badsubsegs             .   */
X  dyingseg->subsegorg = (vertex) NULL;
X  pooldealloc(&m->badsubsegs, (VOID *) dyingseg);
}
X
#endif /* not CDT_ONLY */
X
/*****************************************************************************/
/*                                                                           */
/*  badsubsegtraverse()   Traverse the bad subsegments, skipping dead ones.  */
/*                                                                           */
/*****************************************************************************/
X
#ifndef CDT_ONLY
X
#ifdef ANSI_DECLARATORS
struct badsubseg *badsubsegtraverse(struct mesh *m)
#else /* not ANSI_DECLARATORS */
struct badsubseg *badsubsegtraverse(m)
struct mesh *m;
#endif /* not ANSI_DECLARATORS */
X
{
X  struct badsubseg *newseg;
X
X  do {
X    newseg = (struct badsubseg *) traverse(&m->badsubsegs);
X    if (newseg == (struct badsubseg *) NULL) {
X      return (struct badsubseg *) NULL;
X    }
X  } while (newseg->subsegorg == (vertex) NULL);           /* Skip dead ones. */
X  return newseg;
}
X
#endif /* not CDT_ONLY */
X
/*****************************************************************************/
/*                                                                           */
/*  getvertex()   Get a specific vertex, by number, from the list.           */
/*                                                                           */
/*  The first vertex is number 'firstnumber'.                                */
/*                                                                           */
/*  Note that this takes O(n) time (with a small constant, if VERTEXPERBLOCK */
/*  is large).  I don't care to take the trouble to make it work in constant */
/*  time.                                                                    */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
vertex getvertex(struct mesh *m, struct behavior *b, int number)
#else /* not ANSI_DECLARATORS */
vertex getvertex(m, b, number)
struct mesh *m;
struct behavior *b;
int number;
#endif /* not ANSI_DECLARATORS */
X
{
X  VOID **getblock;
X  char *foundvertex;
X  unsigned long alignptr;
X  int current;
X
X  getblock = m->vertices.firstblock;
X  current = b->firstnumber;
X
X  /* Find the right block. */
X  if (current + m->vertices.itemsfirstblock <= number) {
X    getblock = (VOID **) *getblock;
X    current += m->vertices.itemsfirstblock;
X    while (current + m->vertices.itemsperblock <= number) {
X      getblock = (VOID **) *getblock;
X      current += m->vertices.itemsperblock;
X    }
X  }
X
X  /* Now find the right vertex. */
X  alignptr = (unsigned long) (getblock + 1);
X  foundvertex = (char *) (alignptr + (unsigned long) m->vertices.alignbytes -
X                          (alignptr % (unsigned long) m->vertices.alignbytes));
X  return (vertex) (foundvertex + m->vertices.itembytes * (number - current));
}
X
/*****************************************************************************/
/*                                                                           */
/*  triangledeinit()   Free all remaining allocated memory.                  */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
void triangledeinit(struct mesh *m, struct behavior *b)
#else /* not ANSI_DECLARATORS */
void triangledeinit(m, b)
struct mesh *m;
struct behavior *b;
#endif /* not ANSI_DECLARATORS */
X
{
X  pooldeinit(&m->triangles);
X  trifree((VOID *) m->dummytribase);
X  if (b->usesegments) {
X    pooldeinit(&m->subsegs);
X    trifree((VOID *) m->dummysubbase);
X  }
X  pooldeinit(&m->vertices);
#ifndef CDT_ONLY
X  if (b->quality) {
X    pooldeinit(&m->badsubsegs);
X    if ((b->minangle > 0.0) || b->vararea || b->fixedarea || b->usertest) {
X      pooldeinit(&m->badtriangles);
X      pooldeinit(&m->flipstackers);
X    }
X  }
#endif /* not CDT_ONLY */
}
X
/**                                                                         **/
/**                                                                         **/
/********* Memory management routines end here                       *********/
X
/********* Constructors begin here                                   *********/
/**                                                                         **/
/**                                                                         **/
X
/*****************************************************************************/
/*                                                                           */
/*  maketriangle()   Create a new triangle with orientation zero.            */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
void maketriangle(struct mesh *m, struct behavior *b, struct otri *newotri)
#else /* not ANSI_DECLARATORS */
void maketriangle(m, b, newotri)
struct mesh *m;
struct behavior *b;
struct otri *newotri;
#endif /* not ANSI_DECLARATORS */
X
{
X  int i;
X
X  newotri->tri = (triangle *) poolalloc(&m->triangles);
X  /* Initialize the three adjoining triangles to be "outer space". */
X  newotri->tri[0] = (triangle) m->dummytri;
X  newotri->tri[1] = (triangle) m->dummytri;
X  newotri->tri[2] = (triangle) m->dummytri;
X  /* Three NULL vertices. */
X  newotri->tri[3] = (triangle) NULL;
X  newotri->tri[4] = (triangle) NULL;
X  newotri->tri[5] = (triangle) NULL;
X  if (b->usesegments) {
X    /* Initialize the three adjoining subsegments to be the omnipresent */
X    /*   subsegment.                                                    */
X    newotri->tri[6] = (triangle) m->dummysub;
X    newotri->tri[7] = (triangle) m->dummysub;
X    newotri->tri[8] = (triangle) m->dummysub;
X  }
X  for (i = 0; i < m->eextras; i++) {
X    setelemattribute(*newotri, i, 0.0);
X  }
X  if (b->vararea) {
X    setareabound(*newotri, -1.0);
X  }
X
X  newotri->orient = 0;
}
X
/*****************************************************************************/
/*                                                                           */
/*  makesubseg()   Create a new subsegment with orientation zero.            */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
void makesubseg(struct mesh *m, struct osub *newsubseg)
#else /* not ANSI_DECLARATORS */
void makesubseg(m, newsubseg)
struct mesh *m;
struct osub *newsubseg;
#endif /* not ANSI_DECLARATORS */
X
{
X  newsubseg->ss = (subseg *) poolalloc(&m->subsegs);
X  /* Initialize the two adjoining subsegments to be the omnipresent */
X  /*   subsegment.                                                  */
X  newsubseg->ss[0] = (subseg) m->dummysub;
X  newsubseg->ss[1] = (subseg) m->dummysub;
X  /* Four NULL vertices. */
X  newsubseg->ss[2] = (subseg) NULL;
X  newsubseg->ss[3] = (subseg) NULL;
X  newsubseg->ss[4] = (subseg) NULL;
X  newsubseg->ss[5] = (subseg) NULL;
X  /* Initialize the two adjoining triangles to be "outer space." */
X  newsubseg->ss[6] = (subseg) m->dummytri;
X  newsubseg->ss[7] = (subseg) m->dummytri;
X  /* Set the boundary marker to zero. */
X  setmark(*newsubseg, 0);
X
X  newsubseg->ssorient = 0;
}
X
/**                                                                         **/
/**                                                                         **/
/********* Constructors end here                                     *********/
X
/********* Geometric primitives begin here                           *********/
/**                                                                         **/
/**                                                                         **/
X
/* The adaptive exact arithmetic geometric predicates implemented herein are */
/*   described in detail in my paper, "Adaptive Precision Floating-Point     */
/*   Arithmetic and Fast Robust Geometric Predicates."  See the header for a */
/*   full citation.                                                          */
X
/* Which of the following two methods of finding the absolute values is      */
/*   fastest is compiler-dependent.  A few compilers can inline and optimize */
/*   the fabs() call; but most will incur the overhead of a function call,   */
/*   which is disastrously slow.  A faster way on IEEE machines might be to  */
/*   mask the appropriate bit, but that's difficult to do in C without       */
/*   forcing the value to be stored to memory (rather than be kept in the    */
/*   register to which the optimizer assigned it).                           */
X
#define Absolute(a)  ((a) >= 0.0 ? (a) : -(a))
/* #define Absolute(a)  fabs(a) */
X
/* Many of the operations are broken up into two pieces, a main part that    */
/*   performs an approximate operation, and a "tail" that computes the       */
/*   roundoff error of that operation.                                       */
/*                                                                           */
/* The operations Fast_Two_Sum(), Fast_Two_Diff(), Two_Sum(), Two_Diff(),    */
/*   Split(), and Two_Product() are all implemented as described in the      */
/*   reference.  Each of these macros requires certain variables to be       */
/*   defined in the calling routine.  The variables `bvirt', `c', `abig',    */
/*   `_i', `_j', `_k', `_l', `_m', and `_n' are declared `INEXACT' because   */
/*   they store the result of an operation that may incur roundoff error.    */
/*   The input parameter `x' (or the highest numbered `x_' parameter) must   */
/*   also be declared `INEXACT'.                                             */
X
#define Fast_Two_Sum_Tail(a, b, x, y) \
X  bvirt = x - a; \
X  y = b - bvirt
X
#define Fast_Two_Sum(a, b, x, y) \
X  x = (REAL) (a + b); \
X  Fast_Two_Sum_Tail(a, b, x, y)
X
#define Two_Sum_Tail(a, b, x, y) \
X  bvirt = (REAL) (x - a); \
X  avirt = x - bvirt; \
X  bround = b - bvirt; \
X  around = a - avirt; \
X  y = around + bround
X
#define Two_Sum(a, b, x, y) \
X  x = (REAL) (a + b); \
X  Two_Sum_Tail(a, b, x, y)
X
#define Two_Diff_Tail(a, b, x, y) \
X  bvirt = (REAL) (a - x); \
X  avirt = x + bvirt; \
X  bround = bvirt - b; \
X  around = a - avirt; \
X  y = around + bround
X
#define Two_Diff(a, b, x, y) \
X  x = (REAL) (a - b); \
X  Two_Diff_Tail(a, b, x, y)
X
#define Split(a, ahi, alo) \
X  c = (REAL) (splitter * a); \
X  abig = (REAL) (c - a); \
X  ahi = c - abig; \
X  alo = a - ahi
X
#define Two_Product_Tail(a, b, x, y) \
X  Split(a, ahi, alo); \
X  Split(b, bhi, blo); \
X  err1 = x - (ahi * bhi); \
X  err2 = err1 - (alo * bhi); \
X  err3 = err2 - (ahi * blo); \
X  y = (alo * blo) - err3
X
#define Two_Product(a, b, x, y) \
X  x = (REAL) (a * b); \
X  Two_Product_Tail(a, b, x, y)
X
/* Two_Product_Presplit() is Two_Product() where one of the inputs has       */
/*   already been split.  Avoids redundant splitting.                        */
X
#define Two_Product_Presplit(a, b, bhi, blo, x, y) \
X  x = (REAL) (a * b); \
X  Split(a, ahi, alo); \
X  err1 = x - (ahi * bhi); \
X  err2 = err1 - (alo * bhi); \
X  err3 = err2 - (ahi * blo); \
X  y = (alo * blo) - err3
X
/* Square() can be done more quickly than Two_Product().                     */
X
#define Square_Tail(a, x, y) \
X  Split(a, ahi, alo); \
X  err1 = x - (ahi * ahi); \
X  err3 = err1 - ((ahi + ahi) * alo); \
X  y = (alo * alo) - err3
X
#define Square(a, x, y) \
X  x = (REAL) (a * a); \
X  Square_Tail(a, x, y)
X
/* Macros for summing expansions of various fixed lengths.  These are all    */
/*   unrolled versions of Expansion_Sum().                                   */
X
#define Two_One_Sum(a1, a0, b, x2, x1, x0) \
X  Two_Sum(a0, b , _i, x0); \
X  Two_Sum(a1, _i, x2, x1)
X
#define Two_One_Diff(a1, a0, b, x2, x1, x0) \
X  Two_Diff(a0, b , _i, x0); \
X  Two_Sum( a1, _i, x2, x1)
X
#define Two_Two_Sum(a1, a0, b1, b0, x3, x2, x1, x0) \
X  Two_One_Sum(a1, a0, b0, _j, _0, x0); \
X  Two_One_Sum(_j, _0, b1, x3, x2, x1)
X
#define Two_Two_Diff(a1, a0, b1, b0, x3, x2, x1, x0) \
X  Two_One_Diff(a1, a0, b0, _j, _0, x0); \
X  Two_One_Diff(_j, _0, b1, x3, x2, x1)
X
/* Macro for multiplying a two-component expansion by a single component.    */
X
#define Two_One_Product(a1, a0, b, x3, x2, x1, x0) \
X  Split(b, bhi, blo); \
X  Two_Product_Presplit(a0, b, bhi, blo, _i, x0); \
X  Two_Product_Presplit(a1, b, bhi, blo, _j, _0); \
X  Two_Sum(_i, _0, _k, x1); \
X  Fast_Two_Sum(_j, _k, x3, x2)
X
/*****************************************************************************/
/*                                                                           */
/*  exactinit()   Initialize the variables used for exact arithmetic.        */
/*                                                                           */
/*  `epsilon' is the largest power of two such that 1.0 + epsilon = 1.0 in   */
/*  floating-point arithmetic.  `epsilon' bounds the relative roundoff       */
/*  error.  It is used for floating-point error analysis.                    */
/*                                                                           */
/*  `splitter' is used to split floating-point numbers into two half-        */
/*  length significands for exact multiplication.                            */
/*                                                                           */
/*  I imagine that a highly optimizing compiler might be too smart for its   */
/*  own good, and somehow cause this routine to fail, if it pretends that    */
/*  floating-point arithmetic is too much like real arithmetic.              */
/*                                                                           */
/*  Don't change this routine unless you fully understand it.                */
/*                                                                           */
/*****************************************************************************/
X
void exactinit()
{
X  REAL half;
X  REAL check, lastcheck;
X  int every_other;
#ifdef LINUX
X  int cword;
#endif /* LINUX */
X
#ifdef CPU86
#ifdef SINGLE
X  _control87(_PC_24, _MCW_PC); /* Set FPU control word for single precision. */
#else /* not SINGLE */
X  _control87(_PC_53, _MCW_PC); /* Set FPU control word for double precision. */
#endif /* not SINGLE */
#endif /* CPU86 */
#ifdef LINUX
#ifdef SINGLE
X  /*  cword = 4223; */
X  cword = 4210;                 /* set FPU control word for single precision */
#else /* not SINGLE */
X  /*  cword = 4735; */
X  cword = 4722;                 /* set FPU control word for double precision */
#endif /* not SINGLE */
X  _FPU_SETCW(cword);
#endif /* LINUX */
X
X  every_other = 1;
X  half = 0.5;
X  epsilon = 1.0;
X  splitter = 1.0;
X  check = 1.0;
X  /* Repeatedly divide `epsilon' by two until it is too small to add to      */
X  /*   one without causing roundoff.  (Also check if the sum is equal to     */
X  /*   the previous sum, for machines that round up instead of using exact   */
X  /*   rounding.  Not that these routines will work on such machines.)       */
X  do {
X    lastcheck = check;
X    epsilon *= half;
X    if (every_other) {
X      splitter *= 2.0;
X    }
X    every_other = !every_other;
X    check = 1.0 + epsilon;
X  } while ((check != 1.0) && (check != lastcheck));
X  splitter += 1.0;
X  /* Error bounds for orientation and incircle tests. */
X  resulterrbound = (3.0 + 8.0 * epsilon) * epsilon;
X  ccwerrboundA = (3.0 + 16.0 * epsilon) * epsilon;
X  ccwerrboundB = (2.0 + 12.0 * epsilon) * epsilon;
X  ccwerrboundC = (9.0 + 64.0 * epsilon) * epsilon * epsilon;
X  iccerrboundA = (10.0 + 96.0 * epsilon) * epsilon;
X  iccerrboundB = (4.0 + 48.0 * epsilon) * epsilon;
X  iccerrboundC = (44.0 + 576.0 * epsilon) * epsilon * epsilon;
X  o3derrboundA = (7.0 + 56.0 * epsilon) * epsilon;
X  o3derrboundB = (3.0 + 28.0 * epsilon) * epsilon;
X  o3derrboundC = (26.0 + 288.0 * epsilon) * epsilon * epsilon;
}
X
/*****************************************************************************/
/*                                                                           */
/*  fast_expansion_sum_zeroelim()   Sum two expansions, eliminating zero     */
/*                                  components from the output expansion.    */
/*                                                                           */
/*  Sets h = e + f.  See my Robust Predicates paper for details.             */
/*                                                                           */
/*  If round-to-even is used (as with IEEE 754), maintains the strongly      */
/*  nonoverlapping property.  (That is, if e is strongly nonoverlapping, h   */
/*  will be also.)  Does NOT maintain the nonoverlapping or nonadjacent      */
/*  properties.                                                              */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
int fast_expansion_sum_zeroelim(int elen, REAL *e, int flen, REAL *f, REAL *h)
#else /* not ANSI_DECLARATORS */
int fast_expansion_sum_zeroelim(elen, e, flen, f, h)  /* h cannot be e or f. */
int elen;
REAL *e;
int flen;
REAL *f;
REAL *h;
#endif /* not ANSI_DECLARATORS */
X
{
X  REAL Q;
X  INEXACT REAL Qnew;
X  INEXACT REAL hh;
X  INEXACT REAL bvirt;
X  REAL avirt, bround, around;
X  int eindex, findex, hindex;
X  REAL enow, fnow;
X
X  enow = e[0];
X  fnow = f[0];
X  eindex = findex = 0;
X  if ((fnow > enow) == (fnow > -enow)) {
X    Q = enow;
X    enow = e[++eindex];
X  } else {
X    Q = fnow;
X    fnow = f[++findex];
X  }
X  hindex = 0;
X  if ((eindex < elen) && (findex < flen)) {
X    if ((fnow > enow) == (fnow > -enow)) {
X      Fast_Two_Sum(enow, Q, Qnew, hh);
X      enow = e[++eindex];
X    } else {
X      Fast_Two_Sum(fnow, Q, Qnew, hh);
X      fnow = f[++findex];
X    }
X    Q = Qnew;
X    if (hh != 0.0) {
X      h[hindex++] = hh;
X    }
X    while ((eindex < elen) && (findex < flen)) {
X      if ((fnow > enow) == (fnow > -enow)) {
X        Two_Sum(Q, enow, Qnew, hh);
X        enow = e[++eindex];
X      } else {
X        Two_Sum(Q, fnow, Qnew, hh);
X        fnow = f[++findex];
X      }
X      Q = Qnew;
X      if (hh != 0.0) {
X        h[hindex++] = hh;
X      }
X    }
X  }
X  while (eindex < elen) {
X    Two_Sum(Q, enow, Qnew, hh);
X    enow = e[++eindex];
X    Q = Qnew;
X    if (hh != 0.0) {
X      h[hindex++] = hh;
X    }
X  }
X  while (findex < flen) {
X    Two_Sum(Q, fnow, Qnew, hh);
X    fnow = f[++findex];
X    Q = Qnew;
X    if (hh != 0.0) {
X      h[hindex++] = hh;
X    }
X  }
X  if ((Q != 0.0) || (hindex == 0)) {
X    h[hindex++] = Q;
X  }
X  return hindex;
}
X
/*****************************************************************************/
/*                                                                           */
/*  scale_expansion_zeroelim()   Multiply an expansion by a scalar,          */
/*                               eliminating zero components from the        */
/*                               output expansion.                           */
/*                                                                           */
/*  Sets h = be.  See my Robust Predicates paper for details.                */
/*                                                                           */
/*  Maintains the nonoverlapping property.  If round-to-even is used (as     */
/*  with IEEE 754), maintains the strongly nonoverlapping and nonadjacent    */
/*  properties as well.  (That is, if e has one of these properties, so      */
/*  will h.)                                                                 */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
int scale_expansion_zeroelim(int elen, REAL *e, REAL b, REAL *h)
#else /* not ANSI_DECLARATORS */
int scale_expansion_zeroelim(elen, e, b, h)   /* e and h cannot be the same. */
int elen;
REAL *e;
REAL b;
REAL *h;
#endif /* not ANSI_DECLARATORS */
X
{
X  INEXACT REAL Q, sum;
X  REAL hh;
X  INEXACT REAL product1;
X  REAL product0;
X  int eindex, hindex;
X  REAL enow;
X  INEXACT REAL bvirt;
X  REAL avirt, bround, around;
X  INEXACT REAL c;
X  INEXACT REAL abig;
X  REAL ahi, alo, bhi, blo;
X  REAL err1, err2, err3;
X
X  Split(b, bhi, blo);
X  Two_Product_Presplit(e[0], b, bhi, blo, Q, hh);
X  hindex = 0;
X  if (hh != 0) {
X    h[hindex++] = hh;
X  }
X  for (eindex = 1; eindex < elen; eindex++) {
X    enow = e[eindex];
X    Two_Product_Presplit(enow, b, bhi, blo, product1, product0);
X    Two_Sum(Q, product0, sum, hh);
X    if (hh != 0) {
X      h[hindex++] = hh;
X    }
X    Fast_Two_Sum(product1, sum, Q, hh);
X    if (hh != 0) {
X      h[hindex++] = hh;
X    }
X  }
X  if ((Q != 0.0) || (hindex == 0)) {
X    h[hindex++] = Q;
X  }
X  return hindex;
}
X
/*****************************************************************************/
/*                                                                           */
/*  estimate()   Produce a one-word estimate of an expansion's value.        */
/*                                                                           */
/*  See my Robust Predicates paper for details.                              */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
REAL estimate(int elen, REAL *e)
#else /* not ANSI_DECLARATORS */
REAL estimate(elen, e)
int elen;
REAL *e;
#endif /* not ANSI_DECLARATORS */
X
{
X  REAL Q;
X  int eindex;
X
X  Q = e[0];
X  for (eindex = 1; eindex < elen; eindex++) {
X    Q += e[eindex];
X  }
X  return Q;
}
X
/*****************************************************************************/
/*                                                                           */
/*  counterclockwise()   Return a positive value if the points pa, pb, and   */
/*                       pc occur in counterclockwise order; a negative      */
/*                       value if they occur in clockwise order; and zero    */
/*                       if they are collinear.  The result is also a rough  */
/*                       approximation of twice the signed area of the       */
/*                       triangle defined by the three points.               */
/*                                                                           */
/*  Uses exact arithmetic if necessary to ensure a correct answer.  The      */
/*  result returned is the determinant of a matrix.  This determinant is     */
/*  computed adaptively, in the sense that exact arithmetic is used only to  */
/*  the degree it is needed to ensure that the returned value has the        */
/*  correct sign.  Hence, this function is usually quite fast, but will run  */
/*  more slowly when the input points are collinear or nearly so.            */
/*                                                                           */
/*  See my Robust Predicates paper for details.                              */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
REAL counterclockwiseadapt(vertex pa, vertex pb, vertex pc, REAL detsum)
#else /* not ANSI_DECLARATORS */
REAL counterclockwiseadapt(pa, pb, pc, detsum)
vertex pa;
vertex pb;
vertex pc;
REAL detsum;
#endif /* not ANSI_DECLARATORS */
X
{
X  INEXACT REAL acx, acy, bcx, bcy;
X  REAL acxtail, acytail, bcxtail, bcytail;
X  INEXACT REAL detleft, detright;
X  REAL detlefttail, detrighttail;
X  REAL det, errbound;
X  REAL B[4], C1[8], C2[12], D[16];
X  INEXACT REAL B3;
X  int C1length, C2length, Dlength;
X  REAL u[4];
X  INEXACT REAL u3;
X  INEXACT REAL s1, t1;
X  REAL s0, t0;
X
X  INEXACT REAL bvirt;
X  REAL avirt, bround, around;
X  INEXACT REAL c;
X  INEXACT REAL abig;
X  REAL ahi, alo, bhi, blo;
X  REAL err1, err2, err3;
X  INEXACT REAL _i, _j;
X  REAL _0;
X
X  acx = (REAL) (pa[0] - pc[0]);
X  bcx = (REAL) (pb[0] - pc[0]);
X  acy = (REAL) (pa[1] - pc[1]);
X  bcy = (REAL) (pb[1] - pc[1]);
X
X  Two_Product(acx, bcy, detleft, detlefttail);
X  Two_Product(acy, bcx, detright, detrighttail);
X
X  Two_Two_Diff(detleft, detlefttail, detright, detrighttail,
X               B3, B[2], B[1], B[0]);
X  B[3] = B3;
X
X  det = estimate(4, B);
X  errbound = ccwerrboundB * detsum;
X  if ((det >= errbound) || (-det >= errbound)) {
X    return det;
X  }
X
X  Two_Diff_Tail(pa[0], pc[0], acx, acxtail);
X  Two_Diff_Tail(pb[0], pc[0], bcx, bcxtail);
X  Two_Diff_Tail(pa[1], pc[1], acy, acytail);
X  Two_Diff_Tail(pb[1], pc[1], bcy, bcytail);
X
X  if ((acxtail == 0.0) && (acytail == 0.0)
X      && (bcxtail == 0.0) && (bcytail == 0.0)) {
X    return det;
X  }
X
X  errbound = ccwerrboundC * detsum + resulterrbound * Absolute(det);
X  det += (acx * bcytail + bcy * acxtail)
X       - (acy * bcxtail + bcx * acytail);
X  if ((det >= errbound) || (-det >= errbound)) {
X    return det;
X  }
X
X  Two_Product(acxtail, bcy, s1, s0);
X  Two_Product(acytail, bcx, t1, t0);
X  Two_Two_Diff(s1, s0, t1, t0, u3, u[2], u[1], u[0]);
X  u[3] = u3;
X  C1length = fast_expansion_sum_zeroelim(4, B, 4, u, C1);
X
X  Two_Product(acx, bcytail, s1, s0);
X  Two_Product(acy, bcxtail, t1, t0);
X  Two_Two_Diff(s1, s0, t1, t0, u3, u[2], u[1], u[0]);
X  u[3] = u3;
X  C2length = fast_expansion_sum_zeroelim(C1length, C1, 4, u, C2);
X
X  Two_Product(acxtail, bcytail, s1, s0);
X  Two_Product(acytail, bcxtail, t1, t0);
X  Two_Two_Diff(s1, s0, t1, t0, u3, u[2], u[1], u[0]);
X  u[3] = u3;
X  Dlength = fast_expansion_sum_zeroelim(C2length, C2, 4, u, D);
X
X  return(D[Dlength - 1]);
}
X
#ifdef ANSI_DECLARATORS
REAL counterclockwise(struct mesh *m, struct behavior *b,
X                      vertex pa, vertex pb, vertex pc)
#else /* not ANSI_DECLARATORS */
REAL counterclockwise(m, b, pa, pb, pc)
struct mesh *m;
struct behavior *b;
vertex pa;
vertex pb;
vertex pc;
#endif /* not ANSI_DECLARATORS */
X
{
X  REAL detleft, detright, det;
X  REAL detsum, errbound;
X
X  m->counterclockcount++;
X
X  detleft = (pa[0] - pc[0]) * (pb[1] - pc[1]);
X  detright = (pa[1] - pc[1]) * (pb[0] - pc[0]);
X  det = detleft - detright;
X
X  if (b->noexact) {
X    return det;
X  }
X
X  if (detleft > 0.0) {
X    if (detright <= 0.0) {
X      return det;
X    } else {
X      detsum = detleft + detright;
X    }
X  } else if (detleft < 0.0) {
X    if (detright >= 0.0) {
X      return det;
X    } else {
X      detsum = -detleft - detright;
X    }
X  } else {
X    return det;
X  }
X
X  errbound = ccwerrboundA * detsum;
X  if ((det >= errbound) || (-det >= errbound)) {
X    return det;
X  }
X
X  return counterclockwiseadapt(pa, pb, pc, detsum);
}
X
/*****************************************************************************/
/*                                                                           */
/*  incircle()   Return a positive value if the point pd lies inside the     */
/*               circle passing through pa, pb, and pc; a negative value if  */
/*               it lies outside; and zero if the four points are cocircular.*/
/*               The points pa, pb, and pc must be in counterclockwise       */
/*               order, or the sign of the result will be reversed.          */
/*                                                                           */
/*  Uses exact arithmetic if necessary to ensure a correct answer.  The      */
/*  result returned is the determinant of a matrix.  This determinant is     */
/*  computed adaptively, in the sense that exact arithmetic is used only to  */
/*  the degree it is needed to ensure that the returned value has the        */
/*  correct sign.  Hence, this function is usually quite fast, but will run  */
/*  more slowly when the input points are cocircular or nearly so.           */
/*                                                                           */
/*  See my Robust Predicates paper for details.                              */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
REAL incircleadapt(vertex pa, vertex pb, vertex pc, vertex pd, REAL permanent)
#else /* not ANSI_DECLARATORS */
REAL incircleadapt(pa, pb, pc, pd, permanent)
vertex pa;
vertex pb;
vertex pc;
vertex pd;
REAL permanent;
#endif /* not ANSI_DECLARATORS */
X
{
X  INEXACT REAL adx, bdx, cdx, ady, bdy, cdy;
X  REAL det, errbound;
X
X  INEXACT REAL bdxcdy1, cdxbdy1, cdxady1, adxcdy1, adxbdy1, bdxady1;
X  REAL bdxcdy0, cdxbdy0, cdxady0, adxcdy0, adxbdy0, bdxady0;
X  REAL bc[4], ca[4], ab[4];
X  INEXACT REAL bc3, ca3, ab3;
X  REAL axbc[8], axxbc[16], aybc[8], ayybc[16], adet[32];
X  int axbclen, axxbclen, aybclen, ayybclen, alen;
X  REAL bxca[8], bxxca[16], byca[8], byyca[16], bdet[32];
X  int bxcalen, bxxcalen, bycalen, byycalen, blen;
X  REAL cxab[8], cxxab[16], cyab[8], cyyab[16], cdet[32];
X  int cxablen, cxxablen, cyablen, cyyablen, clen;
X  REAL abdet[64];
X  int ablen;
X  REAL fin1[1152], fin2[1152];
X  REAL *finnow, *finother, *finswap;
X  int finlength;
X
X  REAL adxtail, bdxtail, cdxtail, adytail, bdytail, cdytail;
X  INEXACT REAL adxadx1, adyady1, bdxbdx1, bdybdy1, cdxcdx1, cdycdy1;
X  REAL adxadx0, adyady0, bdxbdx0, bdybdy0, cdxcdx0, cdycdy0;
X  REAL aa[4], bb[4], cc[4];
X  INEXACT REAL aa3, bb3, cc3;
X  INEXACT REAL ti1, tj1;
X  REAL ti0, tj0;
X  REAL u[4], v[4];
X  INEXACT REAL u3, v3;
X  REAL temp8[8], temp16a[16], temp16b[16], temp16c[16];
X  REAL temp32a[32], temp32b[32], temp48[48], temp64[64];
X  int temp8len, temp16alen, temp16blen, temp16clen;
X  int temp32alen, temp32blen, temp48len, temp64len;
X  REAL axtbb[8], axtcc[8], aytbb[8], aytcc[8];
X  int axtbblen, axtcclen, aytbblen, aytcclen;
X  REAL bxtaa[8], bxtcc[8], bytaa[8], bytcc[8];
X  int bxtaalen, bxtcclen, bytaalen, bytcclen;
X  REAL cxtaa[8], cxtbb[8], cytaa[8], cytbb[8];
X  int cxtaalen, cxtbblen, cytaalen, cytbblen;
X  REAL axtbc[8], aytbc[8], bxtca[8], bytca[8], cxtab[8], cytab[8];
X  int axtbclen, aytbclen, bxtcalen, bytcalen, cxtablen, cytablen;
X  REAL axtbct[16], aytbct[16], bxtcat[16], bytcat[16], cxtabt[16], cytabt[16];
X  int axtbctlen, aytbctlen, bxtcatlen, bytcatlen, cxtabtlen, cytabtlen;
X  REAL axtbctt[8], aytbctt[8], bxtcatt[8];
X  REAL bytcatt[8], cxtabtt[8], cytabtt[8];
X  int axtbcttlen, aytbcttlen, bxtcattlen, bytcattlen, cxtabttlen, cytabttlen;
X  REAL abt[8], bct[8], cat[8];
X  int abtlen, bctlen, catlen;
X  REAL abtt[4], bctt[4], catt[4];
X  int abttlen, bcttlen, cattlen;
X  INEXACT REAL abtt3, bctt3, catt3;
X  REAL negate;
X
X  INEXACT REAL bvirt;
X  REAL avirt, bround, around;
X  INEXACT REAL c;
X  INEXACT REAL abig;
X  REAL ahi, alo, bhi, blo;
X  REAL err1, err2, err3;
X  INEXACT REAL _i, _j;
X  REAL _0;
X
X  adx = (REAL) (pa[0] - pd[0]);
X  bdx = (REAL) (pb[0] - pd[0]);
X  cdx = (REAL) (pc[0] - pd[0]);
X  ady = (REAL) (pa[1] - pd[1]);
X  bdy = (REAL) (pb[1] - pd[1]);
X  cdy = (REAL) (pc[1] - pd[1]);
X
X  Two_Product(bdx, cdy, bdxcdy1, bdxcdy0);
X  Two_Product(cdx, bdy, cdxbdy1, cdxbdy0);
X  Two_Two_Diff(bdxcdy1, bdxcdy0, cdxbdy1, cdxbdy0, bc3, bc[2], bc[1], bc[0]);
X  bc[3] = bc3;
X  axbclen = scale_expansion_zeroelim(4, bc, adx, axbc);
X  axxbclen = scale_expansion_zeroelim(axbclen, axbc, adx, axxbc);
X  aybclen = scale_expansion_zeroelim(4, bc, ady, aybc);
X  ayybclen = scale_expansion_zeroelim(aybclen, aybc, ady, ayybc);
X  alen = fast_expansion_sum_zeroelim(axxbclen, axxbc, ayybclen, ayybc, adet);
X
X  Two_Product(cdx, ady, cdxady1, cdxady0);
X  Two_Product(adx, cdy, adxcdy1, adxcdy0);
X  Two_Two_Diff(cdxady1, cdxady0, adxcdy1, adxcdy0, ca3, ca[2], ca[1], ca[0]);
X  ca[3] = ca3;
X  bxcalen = scale_expansion_zeroelim(4, ca, bdx, bxca);
X  bxxcalen = scale_expansion_zeroelim(bxcalen, bxca, bdx, bxxca);
X  bycalen = scale_expansion_zeroelim(4, ca, bdy, byca);
X  byycalen = scale_expansion_zeroelim(bycalen, byca, bdy, byyca);
X  blen = fast_expansion_sum_zeroelim(bxxcalen, bxxca, byycalen, byyca, bdet);
X
X  Two_Product(adx, bdy, adxbdy1, adxbdy0);
X  Two_Product(bdx, ady, bdxady1, bdxady0);
X  Two_Two_Diff(adxbdy1, adxbdy0, bdxady1, bdxady0, ab3, ab[2], ab[1], ab[0]);
X  ab[3] = ab3;
X  cxablen = scale_expansion_zeroelim(4, ab, cdx, cxab);
X  cxxablen = scale_expansion_zeroelim(cxablen, cxab, cdx, cxxab);
X  cyablen = scale_expansion_zeroelim(4, ab, cdy, cyab);
X  cyyablen = scale_expansion_zeroelim(cyablen, cyab, cdy, cyyab);
X  clen = fast_expansion_sum_zeroelim(cxxablen, cxxab, cyyablen, cyyab, cdet);
X
X  ablen = fast_expansion_sum_zeroelim(alen, adet, blen, bdet, abdet);
X  finlength = fast_expansion_sum_zeroelim(ablen, abdet, clen, cdet, fin1);
X
X  det = estimate(finlength, fin1);
X  errbound = iccerrboundB * permanent;
X  if ((det >= errbound) || (-det >= errbound)) {
X    return det;
X  }
X
X  Two_Diff_Tail(pa[0], pd[0], adx, adxtail);
X  Two_Diff_Tail(pa[1], pd[1], ady, adytail);
X  Two_Diff_Tail(pb[0], pd[0], bdx, bdxtail);
X  Two_Diff_Tail(pb[1], pd[1], bdy, bdytail);
X  Two_Diff_Tail(pc[0], pd[0], cdx, cdxtail);
X  Two_Diff_Tail(pc[1], pd[1], cdy, cdytail);
X  if ((adxtail == 0.0) && (bdxtail == 0.0) && (cdxtail == 0.0)
X      && (adytail == 0.0) && (bdytail == 0.0) && (cdytail == 0.0)) {
X    return det;
X  }
X
X  errbound = iccerrboundC * permanent + resulterrbound * Absolute(det);
X  det += ((adx * adx + ady * ady) * ((bdx * cdytail + cdy * bdxtail)
X                                     - (bdy * cdxtail + cdx * bdytail))
X          + 2.0 * (adx * adxtail + ady * adytail) * (bdx * cdy - bdy * cdx))
X       + ((bdx * bdx + bdy * bdy) * ((cdx * adytail + ady * cdxtail)
X                                     - (cdy * adxtail + adx * cdytail))
X          + 2.0 * (bdx * bdxtail + bdy * bdytail) * (cdx * ady - cdy * adx))
X       + ((cdx * cdx + cdy * cdy) * ((adx * bdytail + bdy * adxtail)
X                                     - (ady * bdxtail + bdx * adytail))
X          + 2.0 * (cdx * cdxtail + cdy * cdytail) * (adx * bdy - ady * bdx));
X  if ((det >= errbound) || (-det >= errbound)) {
X    return det;
X  }
X
X  finnow = fin1;
X  finother = fin2;
X
X  if ((bdxtail != 0.0) || (bdytail != 0.0)
X      || (cdxtail != 0.0) || (cdytail != 0.0)) {
X    Square(adx, adxadx1, adxadx0);
X    Square(ady, adyady1, adyady0);
X    Two_Two_Sum(adxadx1, adxadx0, adyady1, adyady0, aa3, aa[2], aa[1], aa[0]);
X    aa[3] = aa3;
X  }
X  if ((cdxtail != 0.0) || (cdytail != 0.0)
X      || (adxtail != 0.0) || (adytail != 0.0)) {
X    Square(bdx, bdxbdx1, bdxbdx0);
X    Square(bdy, bdybdy1, bdybdy0);
X    Two_Two_Sum(bdxbdx1, bdxbdx0, bdybdy1, bdybdy0, bb3, bb[2], bb[1], bb[0]);
X    bb[3] = bb3;
X  }
X  if ((adxtail != 0.0) || (adytail != 0.0)
X      || (bdxtail != 0.0) || (bdytail != 0.0)) {
X    Square(cdx, cdxcdx1, cdxcdx0);
X    Square(cdy, cdycdy1, cdycdy0);
X    Two_Two_Sum(cdxcdx1, cdxcdx0, cdycdy1, cdycdy0, cc3, cc[2], cc[1], cc[0]);
X    cc[3] = cc3;
X  }
X
X  if (adxtail != 0.0) {
X    axtbclen = scale_expansion_zeroelim(4, bc, adxtail, axtbc);
X    temp16alen = scale_expansion_zeroelim(axtbclen, axtbc, 2.0 * adx,
X                                          temp16a);
X
X    axtcclen = scale_expansion_zeroelim(4, cc, adxtail, axtcc);
X    temp16blen = scale_expansion_zeroelim(axtcclen, axtcc, bdy, temp16b);
X
X    axtbblen = scale_expansion_zeroelim(4, bb, adxtail, axtbb);
X    temp16clen = scale_expansion_zeroelim(axtbblen, axtbb, -cdy, temp16c);
X
X    temp32alen = fast_expansion_sum_zeroelim(temp16alen, temp16a,
X                                            temp16blen, temp16b, temp32a);
X    temp48len = fast_expansion_sum_zeroelim(temp16clen, temp16c,
X                                            temp32alen, temp32a, temp48);
X    finlength = fast_expansion_sum_zeroelim(finlength, finnow, temp48len,
X                                            temp48, finother);
X    finswap = finnow; finnow = finother; finother = finswap;
X  }
X  if (adytail != 0.0) {
X    aytbclen = scale_expansion_zeroelim(4, bc, adytail, aytbc);
X    temp16alen = scale_expansion_zeroelim(aytbclen, aytbc, 2.0 * ady,
X                                          temp16a);
X
X    aytbblen = scale_expansion_zeroelim(4, bb, adytail, aytbb);
X    temp16blen = scale_expansion_zeroelim(aytbblen, aytbb, cdx, temp16b);
X
X    aytcclen = scale_expansion_zeroelim(4, cc, adytail, aytcc);
X    temp16clen = scale_expansion_zeroelim(aytcclen, aytcc, -bdx, temp16c);
X
X    temp32alen = fast_expansion_sum_zeroelim(temp16alen, temp16a,
X                                            temp16blen, temp16b, temp32a);
X    temp48len = fast_expansion_sum_zeroelim(temp16clen, temp16c,
X                                            temp32alen, temp32a, temp48);
X    finlength = fast_expansion_sum_zeroelim(finlength, finnow, temp48len,
X                                            temp48, finother);
X    finswap = finnow; finnow = finother; finother = finswap;
X  }
X  if (bdxtail != 0.0) {
X    bxtcalen = scale_expansion_zeroelim(4, ca, bdxtail, bxtca);
X    temp16alen = scale_expansion_zeroelim(bxtcalen, bxtca, 2.0 * bdx,
X                                          temp16a);
X
X    bxtaalen = scale_expansion_zeroelim(4, aa, bdxtail, bxtaa);
X    temp16blen = scale_expansion_zeroelim(bxtaalen, bxtaa, cdy, temp16b);
X
X    bxtcclen = scale_expansion_zeroelim(4, cc, bdxtail, bxtcc);
X    temp16clen = scale_expansion_zeroelim(bxtcclen, bxtcc, -ady, temp16c);
X
X    temp32alen = fast_expansion_sum_zeroelim(temp16alen, temp16a,
X                                            temp16blen, temp16b, temp32a);
X    temp48len = fast_expansion_sum_zeroelim(temp16clen, temp16c,
X                                            temp32alen, temp32a, temp48);
X    finlength = fast_expansion_sum_zeroelim(finlength, finnow, temp48len,
X                                            temp48, finother);
X    finswap = finnow; finnow = finother; finother = finswap;
X  }
X  if (bdytail != 0.0) {
X    bytcalen = scale_expansion_zeroelim(4, ca, bdytail, bytca);
X    temp16alen = scale_expansion_zeroelim(bytcalen, bytca, 2.0 * bdy,
X                                          temp16a);
X
X    bytcclen = scale_expansion_zeroelim(4, cc, bdytail, bytcc);
X    temp16blen = scale_expansion_zeroelim(bytcclen, bytcc, adx, temp16b);
X
X    bytaalen = scale_expansion_zeroelim(4, aa, bdytail, bytaa);
X    temp16clen = scale_expansion_zeroelim(bytaalen, bytaa, -cdx, temp16c);
X
X    temp32alen = fast_expansion_sum_zeroelim(temp16alen, temp16a,
X                                            temp16blen, temp16b, temp32a);
X    temp48len = fast_expansion_sum_zeroelim(temp16clen, temp16c,
X                                            temp32alen, temp32a, temp48);
X    finlength = fast_expansion_sum_zeroelim(finlength, finnow, temp48len,
X                                            temp48, finother);
X    finswap = finnow; finnow = finother; finother = finswap;
X  }
X  if (cdxtail != 0.0) {
X    cxtablen = scale_expansion_zeroelim(4, ab, cdxtail, cxtab);
X    temp16alen = scale_expansion_zeroelim(cxtablen, cxtab, 2.0 * cdx,
X                                          temp16a);
X
X    cxtbblen = scale_expansion_zeroelim(4, bb, cdxtail, cxtbb);
X    temp16blen = scale_expansion_zeroelim(cxtbblen, cxtbb, ady, temp16b);
X
X    cxtaalen = scale_expansion_zeroelim(4, aa, cdxtail, cxtaa);
X    temp16clen = scale_expansion_zeroelim(cxtaalen, cxtaa, -bdy, temp16c);
X
X    temp32alen = fast_expansion_sum_zeroelim(temp16alen, temp16a,
X                                            temp16blen, temp16b, temp32a);
X    temp48len = fast_expansion_sum_zeroelim(temp16clen, temp16c,
X                                            temp32alen, temp32a, temp48);
X    finlength = fast_expansion_sum_zeroelim(finlength, finnow, temp48len,
X                                            temp48, finother);
X    finswap = finnow; finnow = finother; finother = finswap;
X  }
X  if (cdytail != 0.0) {
X    cytablen = scale_expansion_zeroelim(4, ab, cdytail, cytab);
X    temp16alen = scale_expansion_zeroelim(cytablen, cytab, 2.0 * cdy,
X                                          temp16a);
X
X    cytaalen = scale_expansion_zeroelim(4, aa, cdytail, cytaa);
X    temp16blen = scale_expansion_zeroelim(cytaalen, cytaa, bdx, temp16b);
X
X    cytbblen = scale_expansion_zeroelim(4, bb, cdytail, cytbb);
X    temp16clen = scale_expansion_zeroelim(cytbblen, cytbb, -adx, temp16c);
X
X    temp32alen = fast_expansion_sum_zeroelim(temp16alen, temp16a,
X                                            temp16blen, temp16b, temp32a);
X    temp48len = fast_expansion_sum_zeroelim(temp16clen, temp16c,
X                                            temp32alen, temp32a, temp48);
X    finlength = fast_expansion_sum_zeroelim(finlength, finnow, temp48len,
X                                            temp48, finother);
X    finswap = finnow; finnow = finother; finother = finswap;
X  }
X
X  if ((adxtail != 0.0) || (adytail != 0.0)) {
X    if ((bdxtail != 0.0) || (bdytail != 0.0)
X        || (cdxtail != 0.0) || (cdytail != 0.0)) {
X      Two_Product(bdxtail, cdy, ti1, ti0);
X      Two_Product(bdx, cdytail, tj1, tj0);
X      Two_Two_Sum(ti1, ti0, tj1, tj0, u3, u[2], u[1], u[0]);
X      u[3] = u3;
X      negate = -bdy;
X      Two_Product(cdxtail, negate, ti1, ti0);
X      negate = -bdytail;
X      Two_Product(cdx, negate, tj1, tj0);
X      Two_Two_Sum(ti1, ti0, tj1, tj0, v3, v[2], v[1], v[0]);
X      v[3] = v3;
X      bctlen = fast_expansion_sum_zeroelim(4, u, 4, v, bct);
X
X      Two_Product(bdxtail, cdytail, ti1, ti0);
X      Two_Product(cdxtail, bdytail, tj1, tj0);
X      Two_Two_Diff(ti1, ti0, tj1, tj0, bctt3, bctt[2], bctt[1], bctt[0]);
X      bctt[3] = bctt3;
X      bcttlen = 4;
X    } else {
X      bct[0] = 0.0;
X      bctlen = 1;
X      bctt[0] = 0.0;
X      bcttlen = 1;
X    }
X
X    if (adxtail != 0.0) {
X      temp16alen = scale_expansion_zeroelim(axtbclen, axtbc, adxtail, temp16a);
X      axtbctlen = scale_expansion_zeroelim(bctlen, bct, adxtail, axtbct);
X      temp32alen = scale_expansion_zeroelim(axtbctlen, axtbct, 2.0 * adx,
X                                            temp32a);
X      temp48len = fast_expansion_sum_zeroelim(temp16alen, temp16a,
X                                              temp32alen, temp32a, temp48);
X      finlength = fast_expansion_sum_zeroelim(finlength, finnow, temp48len,
X                                              temp48, finother);
X      finswap = finnow; finnow = finother; finother = finswap;
X      if (bdytail != 0.0) {
X        temp8len = scale_expansion_zeroelim(4, cc, adxtail, temp8);
X        temp16alen = scale_expansion_zeroelim(temp8len, temp8, bdytail,
X                                              temp16a);
X        finlength = fast_expansion_sum_zeroelim(finlength, finnow, temp16alen,
X                                                temp16a, finother);
X        finswap = finnow; finnow = finother; finother = finswap;
X      }
X      if (cdytail != 0.0) {
X        temp8len = scale_expansion_zeroelim(4, bb, -adxtail, temp8);
X        temp16alen = scale_expansion_zeroelim(temp8len, temp8, cdytail,
X                                              temp16a);
X        finlength = fast_expansion_sum_zeroelim(finlength, finnow, temp16alen,
X                                                temp16a, finother);
X        finswap = finnow; finnow = finother; finother = finswap;
X      }
X
X      temp32alen = scale_expansion_zeroelim(axtbctlen, axtbct, adxtail,
X                                            temp32a);
X      axtbcttlen = scale_expansion_zeroelim(bcttlen, bctt, adxtail, axtbctt);
X      temp16alen = scale_expansion_zeroelim(axtbcttlen, axtbctt, 2.0 * adx,
X                                            temp16a);
X      temp16blen = scale_expansion_zeroelim(axtbcttlen, axtbctt, adxtail,
X                                            temp16b);
X      temp32blen = fast_expansion_sum_zeroelim(temp16alen, temp16a,
X                                              temp16blen, temp16b, temp32b);
X      temp64len = fast_expansion_sum_zeroelim(temp32alen, temp32a,
X                                              temp32blen, temp32b, temp64);
X      finlength = fast_expansion_sum_zeroelim(finlength, finnow, temp64len,
X                                              temp64, finother);
X      finswap = finnow; finnow = finother; finother = finswap;
X    }
X    if (adytail != 0.0) {
X      temp16alen = scale_expansion_zeroelim(aytbclen, aytbc, adytail, temp16a);
X      aytbctlen = scale_expansion_zeroelim(bctlen, bct, adytail, aytbct);
X      temp32alen = scale_expansion_zeroelim(aytbctlen, aytbct, 2.0 * ady,
X                                            temp32a);
X      temp48len = fast_expansion_sum_zeroelim(temp16alen, temp16a,
X                                              temp32alen, temp32a, temp48);
X      finlength = fast_expansion_sum_zeroelim(finlength, finnow, temp48len,
X                                              temp48, finother);
X      finswap = finnow; finnow = finother; finother = finswap;
X
X
X      temp32alen = scale_expansion_zeroelim(aytbctlen, aytbct, adytail,
X                                            temp32a);
X      aytbcttlen = scale_expansion_zeroelim(bcttlen, bctt, adytail, aytbctt);
X      temp16alen = scale_expansion_zeroelim(aytbcttlen, aytbctt, 2.0 * ady,
X                                            temp16a);
X      temp16blen = scale_expansion_zeroelim(aytbcttlen, aytbctt, adytail,
X                                            temp16b);
X      temp32blen = fast_expansion_sum_zeroelim(temp16alen, temp16a,
X                                              temp16blen, temp16b, temp32b);
X      temp64len = fast_expansion_sum_zeroelim(temp32alen, temp32a,
X                                              temp32blen, temp32b, temp64);
X      finlength = fast_expansion_sum_zeroelim(finlength, finnow, temp64len,
X                                              temp64, finother);
X      finswap = finnow; finnow = finother; finother = finswap;
X    }
X  }
X  if ((bdxtail != 0.0) || (bdytail != 0.0)) {
X    if ((cdxtail != 0.0) || (cdytail != 0.0)
X        || (adxtail != 0.0) || (adytail != 0.0)) {
X      Two_Product(cdxtail, ady, ti1, ti0);
X      Two_Product(cdx, adytail, tj1, tj0);
X      Two_Two_Sum(ti1, ti0, tj1, tj0, u3, u[2], u[1], u[0]);
X      u[3] = u3;
X      negate = -cdy;
X      Two_Product(adxtail, negate, ti1, ti0);
X      negate = -cdytail;
X      Two_Product(adx, negate, tj1, tj0);
X      Two_Two_Sum(ti1, ti0, tj1, tj0, v3, v[2], v[1], v[0]);
X      v[3] = v3;
X      catlen = fast_expansion_sum_zeroelim(4, u, 4, v, cat);
X
X      Two_Product(cdxtail, adytail, ti1, ti0);
X      Two_Product(adxtail, cdytail, tj1, tj0);
X      Two_Two_Diff(ti1, ti0, tj1, tj0, catt3, catt[2], catt[1], catt[0]);
X      catt[3] = catt3;
X      cattlen = 4;
X    } else {
X      cat[0] = 0.0;
X      catlen = 1;
X      catt[0] = 0.0;
X      cattlen = 1;
X    }
X
X    if (bdxtail != 0.0) {
X      temp16alen = scale_expansion_zeroelim(bxtcalen, bxtca, bdxtail, temp16a);
X      bxtcatlen = scale_expansion_zeroelim(catlen, cat, bdxtail, bxtcat);
X      temp32alen = scale_expansion_zeroelim(bxtcatlen, bxtcat, 2.0 * bdx,
X                                            temp32a);
X      temp48len = fast_expansion_sum_zeroelim(temp16alen, temp16a,
X                                              temp32alen, temp32a, temp48);
X      finlength = fast_expansion_sum_zeroelim(finlength, finnow, temp48len,
X                                              temp48, finother);
X      finswap = finnow; finnow = finother; finother = finswap;
X      if (cdytail != 0.0) {
X        temp8len = scale_expansion_zeroelim(4, aa, bdxtail, temp8);
X        temp16alen = scale_expansion_zeroelim(temp8len, temp8, cdytail,
X                                              temp16a);
X        finlength = fast_expansion_sum_zeroelim(finlength, finnow, temp16alen,
X                                                temp16a, finother);
X        finswap = finnow; finnow = finother; finother = finswap;
X      }
X      if (adytail != 0.0) {
X        temp8len = scale_expansion_zeroelim(4, cc, -bdxtail, temp8);
X        temp16alen = scale_expansion_zeroelim(temp8len, temp8, adytail,
X                                              temp16a);
X        finlength = fast_expansion_sum_zeroelim(finlength, finnow, temp16alen,
X                                                temp16a, finother);
X        finswap = finnow; finnow = finother; finother = finswap;
X      }
X
X      temp32alen = scale_expansion_zeroelim(bxtcatlen, bxtcat, bdxtail,
X                                            temp32a);
X      bxtcattlen = scale_expansion_zeroelim(cattlen, catt, bdxtail, bxtcatt);
X      temp16alen = scale_expansion_zeroelim(bxtcattlen, bxtcatt, 2.0 * bdx,
X                                            temp16a);
X      temp16blen = scale_expansion_zeroelim(bxtcattlen, bxtcatt, bdxtail,
X                                            temp16b);
X      temp32blen = fast_expansion_sum_zeroelim(temp16alen, temp16a,
X                                              temp16blen, temp16b, temp32b);
X      temp64len = fast_expansion_sum_zeroelim(temp32alen, temp32a,
X                                              temp32blen, temp32b, temp64);
X      finlength = fast_expansion_sum_zeroelim(finlength, finnow, temp64len,
X                                              temp64, finother);
X      finswap = finnow; finnow = finother; finother = finswap;
X    }
X    if (bdytail != 0.0) {
X      temp16alen = scale_expansion_zeroelim(bytcalen, bytca, bdytail, temp16a);
X      bytcatlen = scale_expansion_zeroelim(catlen, cat, bdytail, bytcat);
X      temp32alen = scale_expansion_zeroelim(bytcatlen, bytcat, 2.0 * bdy,
X                                            temp32a);
X      temp48len = fast_expansion_sum_zeroelim(temp16alen, temp16a,
X                                              temp32alen, temp32a, temp48);
X      finlength = fast_expansion_sum_zeroelim(finlength, finnow, temp48len,
X                                              temp48, finother);
X      finswap = finnow; finnow = finother; finother = finswap;
X
X
X      temp32alen = scale_expansion_zeroelim(bytcatlen, bytcat, bdytail,
X                                            temp32a);
X      bytcattlen = scale_expansion_zeroelim(cattlen, catt, bdytail, bytcatt);
X      temp16alen = scale_expansion_zeroelim(bytcattlen, bytcatt, 2.0 * bdy,
X                                            temp16a);
X      temp16blen = scale_expansion_zeroelim(bytcattlen, bytcatt, bdytail,
X                                            temp16b);
X      temp32blen = fast_expansion_sum_zeroelim(temp16alen, temp16a,
X                                              temp16blen, temp16b, temp32b);
X      temp64len = fast_expansion_sum_zeroelim(temp32alen, temp32a,
X                                              temp32blen, temp32b, temp64);
X      finlength = fast_expansion_sum_zeroelim(finlength, finnow, temp64len,
X                                              temp64, finother);
X      finswap = finnow; finnow = finother; finother = finswap;
X    }
X  }
X  if ((cdxtail != 0.0) || (cdytail != 0.0)) {
X    if ((adxtail != 0.0) || (adytail != 0.0)
X        || (bdxtail != 0.0) || (bdytail != 0.0)) {
X      Two_Product(adxtail, bdy, ti1, ti0);
X      Two_Product(adx, bdytail, tj1, tj0);
X      Two_Two_Sum(ti1, ti0, tj1, tj0, u3, u[2], u[1], u[0]);
X      u[3] = u3;
X      negate = -ady;
X      Two_Product(bdxtail, negate, ti1, ti0);
X      negate = -adytail;
X      Two_Product(bdx, negate, tj1, tj0);
X      Two_Two_Sum(ti1, ti0, tj1, tj0, v3, v[2], v[1], v[0]);
X      v[3] = v3;
X      abtlen = fast_expansion_sum_zeroelim(4, u, 4, v, abt);
X
X      Two_Product(adxtail, bdytail, ti1, ti0);
X      Two_Product(bdxtail, adytail, tj1, tj0);
X      Two_Two_Diff(ti1, ti0, tj1, tj0, abtt3, abtt[2], abtt[1], abtt[0]);
X      abtt[3] = abtt3;
X      abttlen = 4;
X    } else {
X      abt[0] = 0.0;
X      abtlen = 1;
X      abtt[0] = 0.0;
X      abttlen = 1;
X    }
X
X    if (cdxtail != 0.0) {
X      temp16alen = scale_expansion_zeroelim(cxtablen, cxtab, cdxtail, temp16a);
X      cxtabtlen = scale_expansion_zeroelim(abtlen, abt, cdxtail, cxtabt);
X      temp32alen = scale_expansion_zeroelim(cxtabtlen, cxtabt, 2.0 * cdx,
X                                            temp32a);
X      temp48len = fast_expansion_sum_zeroelim(temp16alen, temp16a,
X                                              temp32alen, temp32a, temp48);
X      finlength = fast_expansion_sum_zeroelim(finlength, finnow, temp48len,
X                                              temp48, finother);
X      finswap = finnow; finnow = finother; finother = finswap;
X      if (adytail != 0.0) {
X        temp8len = scale_expansion_zeroelim(4, bb, cdxtail, temp8);
X        temp16alen = scale_expansion_zeroelim(temp8len, temp8, adytail,
X                                              temp16a);
X        finlength = fast_expansion_sum_zeroelim(finlength, finnow, temp16alen,
X                                                temp16a, finother);
X        finswap = finnow; finnow = finother; finother = finswap;
X      }
X      if (bdytail != 0.0) {
X        temp8len = scale_expansion_zeroelim(4, aa, -cdxtail, temp8);
X        temp16alen = scale_expansion_zeroelim(temp8len, temp8, bdytail,
X                                              temp16a);
X        finlength = fast_expansion_sum_zeroelim(finlength, finnow, temp16alen,
X                                                temp16a, finother);
X        finswap = finnow; finnow = finother; finother = finswap;
X      }
X
X      temp32alen = scale_expansion_zeroelim(cxtabtlen, cxtabt, cdxtail,
X                                            temp32a);
X      cxtabttlen = scale_expansion_zeroelim(abttlen, abtt, cdxtail, cxtabtt);
X      temp16alen = scale_expansion_zeroelim(cxtabttlen, cxtabtt, 2.0 * cdx,
X                                            temp16a);
X      temp16blen = scale_expansion_zeroelim(cxtabttlen, cxtabtt, cdxtail,
X                                            temp16b);
X      temp32blen = fast_expansion_sum_zeroelim(temp16alen, temp16a,
X                                              temp16blen, temp16b, temp32b);
X      temp64len = fast_expansion_sum_zeroelim(temp32alen, temp32a,
X                                              temp32blen, temp32b, temp64);
X      finlength = fast_expansion_sum_zeroelim(finlength, finnow, temp64len,
X                                              temp64, finother);
X      finswap = finnow; finnow = finother; finother = finswap;
X    }
X    if (cdytail != 0.0) {
X      temp16alen = scale_expansion_zeroelim(cytablen, cytab, cdytail, temp16a);
X      cytabtlen = scale_expansion_zeroelim(abtlen, abt, cdytail, cytabt);
X      temp32alen = scale_expansion_zeroelim(cytabtlen, cytabt, 2.0 * cdy,
X                                            temp32a);
X      temp48len = fast_expansion_sum_zeroelim(temp16alen, temp16a,
X                                              temp32alen, temp32a, temp48);
X      finlength = fast_expansion_sum_zeroelim(finlength, finnow, temp48len,
X                                              temp48, finother);
X      finswap = finnow; finnow = finother; finother = finswap;
X
X
X      temp32alen = scale_expansion_zeroelim(cytabtlen, cytabt, cdytail,
X                                            temp32a);
X      cytabttlen = scale_expansion_zeroelim(abttlen, abtt, cdytail, cytabtt);
X      temp16alen = scale_expansion_zeroelim(cytabttlen, cytabtt, 2.0 * cdy,
X                                            temp16a);
X      temp16blen = scale_expansion_zeroelim(cytabttlen, cytabtt, cdytail,
X                                            temp16b);
X      temp32blen = fast_expansion_sum_zeroelim(temp16alen, temp16a,
X                                              temp16blen, temp16b, temp32b);
X      temp64len = fast_expansion_sum_zeroelim(temp32alen, temp32a,
X                                              temp32blen, temp32b, temp64);
X      finlength = fast_expansion_sum_zeroelim(finlength, finnow, temp64len,
X                                              temp64, finother);
X      finswap = finnow; finnow = finother; finother = finswap;
X    }
X  }
X
X  return finnow[finlength - 1];
}
X
#ifdef ANSI_DECLARATORS
REAL incircle(struct mesh *m, struct behavior *b,
X              vertex pa, vertex pb, vertex pc, vertex pd)
#else /* not ANSI_DECLARATORS */
REAL incircle(m, b, pa, pb, pc, pd)
struct mesh *m;
struct behavior *b;
vertex pa;
vertex pb;
vertex pc;
vertex pd;
#endif /* not ANSI_DECLARATORS */
X
{
X  REAL adx, bdx, cdx, ady, bdy, cdy;
X  REAL bdxcdy, cdxbdy, cdxady, adxcdy, adxbdy, bdxady;
X  REAL alift, blift, clift;
X  REAL det;
X  REAL permanent, errbound;
X
X  m->incirclecount++;
X
X  adx = pa[0] - pd[0];
X  bdx = pb[0] - pd[0];
X  cdx = pc[0] - pd[0];
X  ady = pa[1] - pd[1];
X  bdy = pb[1] - pd[1];
X  cdy = pc[1] - pd[1];
X
X  bdxcdy = bdx * cdy;
X  cdxbdy = cdx * bdy;
X  alift = adx * adx + ady * ady;
X
X  cdxady = cdx * ady;
X  adxcdy = adx * cdy;
X  blift = bdx * bdx + bdy * bdy;
X
X  adxbdy = adx * bdy;
X  bdxady = bdx * ady;
X  clift = cdx * cdx + cdy * cdy;
X
X  det = alift * (bdxcdy - cdxbdy)
X      + blift * (cdxady - adxcdy)
X      + clift * (adxbdy - bdxady);
X
X  if (b->noexact) {
X    return det;
X  }
X
X  permanent = (Absolute(bdxcdy) + Absolute(cdxbdy)) * alift
X            + (Absolute(cdxady) + Absolute(adxcdy)) * blift
X            + (Absolute(adxbdy) + Absolute(bdxady)) * clift;
X  errbound = iccerrboundA * permanent;
X  if ((det > errbound) || (-det > errbound)) {
X    return det;
X  }
X
X  return incircleadapt(pa, pb, pc, pd, permanent);
}
X
/*****************************************************************************/
/*                                                                           */
/*  orient3d()   Return a positive value if the point pd lies below the      */
/*               plane passing through pa, pb, and pc; "below" is defined so */
/*               that pa, pb, and pc appear in counterclockwise order when   */
/*               viewed from above the plane.  Returns a negative value if   */
/*               pd lies above the plane.  Returns zero if the points are    */
/*               coplanar.  The result is also a rough approximation of six  */
/*               times the signed volume of the tetrahedron defined by the   */
/*               four points.                                                */
/*                                                                           */
/*  Uses exact arithmetic if necessary to ensure a correct answer.  The      */
/*  result returned is the determinant of a matrix.  This determinant is     */
/*  computed adaptively, in the sense that exact arithmetic is used only to  */
/*  the degree it is needed to ensure that the returned value has the        */
/*  correct sign.  Hence, this function is usually quite fast, but will run  */
/*  more slowly when the input points are coplanar or nearly so.             */
/*                                                                           */
/*  See my Robust Predicates paper for details.                              */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
REAL orient3dadapt(vertex pa, vertex pb, vertex pc, vertex pd,
X                   REAL aheight, REAL bheight, REAL cheight, REAL dheight,
X                   REAL permanent)
#else /* not ANSI_DECLARATORS */
REAL orient3dadapt(pa, pb, pc, pd,
X                   aheight, bheight, cheight, dheight, permanent)
vertex pa;
vertex pb;
vertex pc;
vertex pd;
REAL aheight;
REAL bheight;
REAL cheight;
REAL dheight;
REAL permanent;
#endif /* not ANSI_DECLARATORS */
X
{
X  INEXACT REAL adx, bdx, cdx, ady, bdy, cdy, adheight, bdheight, cdheight;
X  REAL det, errbound;
X
X  INEXACT REAL bdxcdy1, cdxbdy1, cdxady1, adxcdy1, adxbdy1, bdxady1;
X  REAL bdxcdy0, cdxbdy0, cdxady0, adxcdy0, adxbdy0, bdxady0;
X  REAL bc[4], ca[4], ab[4];
X  INEXACT REAL bc3, ca3, ab3;
X  REAL adet[8], bdet[8], cdet[8];
X  int alen, blen, clen;
X  REAL abdet[16];
X  int ablen;
X  REAL *finnow, *finother, *finswap;
X  REAL fin1[192], fin2[192];
X  int finlength;
X
X  REAL adxtail, bdxtail, cdxtail;
X  REAL adytail, bdytail, cdytail;
X  REAL adheighttail, bdheighttail, cdheighttail;
X  INEXACT REAL at_blarge, at_clarge;
X  INEXACT REAL bt_clarge, bt_alarge;
X  INEXACT REAL ct_alarge, ct_blarge;
X  REAL at_b[4], at_c[4], bt_c[4], bt_a[4], ct_a[4], ct_b[4];
X  int at_blen, at_clen, bt_clen, bt_alen, ct_alen, ct_blen;
X  INEXACT REAL bdxt_cdy1, cdxt_bdy1, cdxt_ady1;
X  INEXACT REAL adxt_cdy1, adxt_bdy1, bdxt_ady1;
X  REAL bdxt_cdy0, cdxt_bdy0, cdxt_ady0;
X  REAL adxt_cdy0, adxt_bdy0, bdxt_ady0;
X  INEXACT REAL bdyt_cdx1, cdyt_bdx1, cdyt_adx1;
X  INEXACT REAL adyt_cdx1, adyt_bdx1, bdyt_adx1;
X  REAL bdyt_cdx0, cdyt_bdx0, cdyt_adx0;
X  REAL adyt_cdx0, adyt_bdx0, bdyt_adx0;
X  REAL bct[8], cat[8], abt[8];
X  int bctlen, catlen, abtlen;
X  INEXACT REAL bdxt_cdyt1, cdxt_bdyt1, cdxt_adyt1;
X  INEXACT REAL adxt_cdyt1, adxt_bdyt1, bdxt_adyt1;
X  REAL bdxt_cdyt0, cdxt_bdyt0, cdxt_adyt0;
X  REAL adxt_cdyt0, adxt_bdyt0, bdxt_adyt0;
X  REAL u[4], v[12], w[16];
X  INEXACT REAL u3;
X  int vlength, wlength;
X  REAL negate;
X
X  INEXACT REAL bvirt;
X  REAL avirt, bround, around;
X  INEXACT REAL c;
X  INEXACT REAL abig;
X  REAL ahi, alo, bhi, blo;
X  REAL err1, err2, err3;
X  INEXACT REAL _i, _j, _k;
X  REAL _0;
X
X  adx = (REAL) (pa[0] - pd[0]);
X  bdx = (REAL) (pb[0] - pd[0]);
X  cdx = (REAL) (pc[0] - pd[0]);
X  ady = (REAL) (pa[1] - pd[1]);
X  bdy = (REAL) (pb[1] - pd[1]);
X  cdy = (REAL) (pc[1] - pd[1]);
X  adheight = (REAL) (aheight - dheight);
X  bdheight = (REAL) (bheight - dheight);
X  cdheight = (REAL) (cheight - dheight);
X
X  Two_Product(bdx, cdy, bdxcdy1, bdxcdy0);
X  Two_Product(cdx, bdy, cdxbdy1, cdxbdy0);
X  Two_Two_Diff(bdxcdy1, bdxcdy0, cdxbdy1, cdxbdy0, bc3, bc[2], bc[1], bc[0]);
X  bc[3] = bc3;
X  alen = scale_expansion_zeroelim(4, bc, adheight, adet);
X
X  Two_Product(cdx, ady, cdxady1, cdxady0);
X  Two_Product(adx, cdy, adxcdy1, adxcdy0);
X  Two_Two_Diff(cdxady1, cdxady0, adxcdy1, adxcdy0, ca3, ca[2], ca[1], ca[0]);
X  ca[3] = ca3;
X  blen = scale_expansion_zeroelim(4, ca, bdheight, bdet);
X
X  Two_Product(adx, bdy, adxbdy1, adxbdy0);
X  Two_Product(bdx, ady, bdxady1, bdxady0);
X  Two_Two_Diff(adxbdy1, adxbdy0, bdxady1, bdxady0, ab3, ab[2], ab[1], ab[0]);
X  ab[3] = ab3;
X  clen = scale_expansion_zeroelim(4, ab, cdheight, cdet);
X
X  ablen = fast_expansion_sum_zeroelim(alen, adet, blen, bdet, abdet);
X  finlength = fast_expansion_sum_zeroelim(ablen, abdet, clen, cdet, fin1);
X
X  det = estimate(finlength, fin1);
X  errbound = o3derrboundB * permanent;
X  if ((det >= errbound) || (-det >= errbound)) {
X    return det;
X  }
X
X  Two_Diff_Tail(pa[0], pd[0], adx, adxtail);
X  Two_Diff_Tail(pb[0], pd[0], bdx, bdxtail);
X  Two_Diff_Tail(pc[0], pd[0], cdx, cdxtail);
X  Two_Diff_Tail(pa[1], pd[1], ady, adytail);
X  Two_Diff_Tail(pb[1], pd[1], bdy, bdytail);
X  Two_Diff_Tail(pc[1], pd[1], cdy, cdytail);
X  Two_Diff_Tail(aheight, dheight, adheight, adheighttail);
X  Two_Diff_Tail(bheight, dheight, bdheight, bdheighttail);
X  Two_Diff_Tail(cheight, dheight, cdheight, cdheighttail);
X
X  if ((adxtail == 0.0) && (bdxtail == 0.0) && (cdxtail == 0.0) &&
X      (adytail == 0.0) && (bdytail == 0.0) && (cdytail == 0.0) &&
X      (adheighttail == 0.0) &&
X      (bdheighttail == 0.0) &&
X      (cdheighttail == 0.0)) {
X    return det;
X  }
X
X  errbound = o3derrboundC * permanent + resulterrbound * Absolute(det);
X  det += (adheight * ((bdx * cdytail + cdy * bdxtail) -
X                      (bdy * cdxtail + cdx * bdytail)) +
X          adheighttail * (bdx * cdy - bdy * cdx)) +
X         (bdheight * ((cdx * adytail + ady * cdxtail) -
X                      (cdy * adxtail + adx * cdytail)) +
X          bdheighttail * (cdx * ady - cdy * adx)) +
X         (cdheight * ((adx * bdytail + bdy * adxtail) -
X                      (ady * bdxtail + bdx * adytail)) +
X          cdheighttail * (adx * bdy - ady * bdx));
X  if ((det >= errbound) || (-det >= errbound)) {
X    return det;
X  }
X
X  finnow = fin1;
X  finother = fin2;
X
X  if (adxtail == 0.0) {
X    if (adytail == 0.0) {
X      at_b[0] = 0.0;
X      at_blen = 1;
X      at_c[0] = 0.0;
X      at_clen = 1;
X    } else {
X      negate = -adytail;
X      Two_Product(negate, bdx, at_blarge, at_b[0]);
X      at_b[1] = at_blarge;
X      at_blen = 2;
X      Two_Product(adytail, cdx, at_clarge, at_c[0]);
X      at_c[1] = at_clarge;
X      at_clen = 2;
X    }
X  } else {
X    if (adytail == 0.0) {
X      Two_Product(adxtail, bdy, at_blarge, at_b[0]);
X      at_b[1] = at_blarge;
X      at_blen = 2;
X      negate = -adxtail;
X      Two_Product(negate, cdy, at_clarge, at_c[0]);
X      at_c[1] = at_clarge;
X      at_clen = 2;
X    } else {
X      Two_Product(adxtail, bdy, adxt_bdy1, adxt_bdy0);
X      Two_Product(adytail, bdx, adyt_bdx1, adyt_bdx0);
X      Two_Two_Diff(adxt_bdy1, adxt_bdy0, adyt_bdx1, adyt_bdx0,
X                   at_blarge, at_b[2], at_b[1], at_b[0]);
X      at_b[3] = at_blarge;
X      at_blen = 4;
X      Two_Product(adytail, cdx, adyt_cdx1, adyt_cdx0);
X      Two_Product(adxtail, cdy, adxt_cdy1, adxt_cdy0);
X      Two_Two_Diff(adyt_cdx1, adyt_cdx0, adxt_cdy1, adxt_cdy0,
X                   at_clarge, at_c[2], at_c[1], at_c[0]);
X      at_c[3] = at_clarge;
X      at_clen = 4;
X    }
X  }
X  if (bdxtail == 0.0) {
X    if (bdytail == 0.0) {
X      bt_c[0] = 0.0;
X      bt_clen = 1;
X      bt_a[0] = 0.0;
X      bt_alen = 1;
X    } else {
X      negate = -bdytail;
X      Two_Product(negate, cdx, bt_clarge, bt_c[0]);
X      bt_c[1] = bt_clarge;
X      bt_clen = 2;
X      Two_Product(bdytail, adx, bt_alarge, bt_a[0]);
X      bt_a[1] = bt_alarge;
X      bt_alen = 2;
X    }
X  } else {
X    if (bdytail == 0.0) {
X      Two_Product(bdxtail, cdy, bt_clarge, bt_c[0]);
X      bt_c[1] = bt_clarge;
X      bt_clen = 2;
X      negate = -bdxtail;
X      Two_Product(negate, ady, bt_alarge, bt_a[0]);
X      bt_a[1] = bt_alarge;
X      bt_alen = 2;
X    } else {
X      Two_Product(bdxtail, cdy, bdxt_cdy1, bdxt_cdy0);
X      Two_Product(bdytail, cdx, bdyt_cdx1, bdyt_cdx0);
X      Two_Two_Diff(bdxt_cdy1, bdxt_cdy0, bdyt_cdx1, bdyt_cdx0,
X                   bt_clarge, bt_c[2], bt_c[1], bt_c[0]);
X      bt_c[3] = bt_clarge;
X      bt_clen = 4;
X      Two_Product(bdytail, adx, bdyt_adx1, bdyt_adx0);
X      Two_Product(bdxtail, ady, bdxt_ady1, bdxt_ady0);
X      Two_Two_Diff(bdyt_adx1, bdyt_adx0, bdxt_ady1, bdxt_ady0,
X                  bt_alarge, bt_a[2], bt_a[1], bt_a[0]);
X      bt_a[3] = bt_alarge;
X      bt_alen = 4;
X    }
X  }
X  if (cdxtail == 0.0) {
X    if (cdytail == 0.0) {
X      ct_a[0] = 0.0;
X      ct_alen = 1;
X      ct_b[0] = 0.0;
X      ct_blen = 1;
X    } else {
X      negate = -cdytail;
X      Two_Product(negate, adx, ct_alarge, ct_a[0]);
X      ct_a[1] = ct_alarge;
X      ct_alen = 2;
X      Two_Product(cdytail, bdx, ct_blarge, ct_b[0]);
X      ct_b[1] = ct_blarge;
X      ct_blen = 2;
X    }
X  } else {
X    if (cdytail == 0.0) {
X      Two_Product(cdxtail, ady, ct_alarge, ct_a[0]);
X      ct_a[1] = ct_alarge;
X      ct_alen = 2;
X      negate = -cdxtail;
X      Two_Product(negate, bdy, ct_blarge, ct_b[0]);
X      ct_b[1] = ct_blarge;
X      ct_blen = 2;
X    } else {
X      Two_Product(cdxtail, ady, cdxt_ady1, cdxt_ady0);
X      Two_Product(cdytail, adx, cdyt_adx1, cdyt_adx0);
X      Two_Two_Diff(cdxt_ady1, cdxt_ady0, cdyt_adx1, cdyt_adx0,
X                   ct_alarge, ct_a[2], ct_a[1], ct_a[0]);
X      ct_a[3] = ct_alarge;
X      ct_alen = 4;
X      Two_Product(cdytail, bdx, cdyt_bdx1, cdyt_bdx0);
X      Two_Product(cdxtail, bdy, cdxt_bdy1, cdxt_bdy0);
X      Two_Two_Diff(cdyt_bdx1, cdyt_bdx0, cdxt_bdy1, cdxt_bdy0,
X                   ct_blarge, ct_b[2], ct_b[1], ct_b[0]);
X      ct_b[3] = ct_blarge;
X      ct_blen = 4;
X    }
X  }
X
X  bctlen = fast_expansion_sum_zeroelim(bt_clen, bt_c, ct_blen, ct_b, bct);
X  wlength = scale_expansion_zeroelim(bctlen, bct, adheight, w);
X  finlength = fast_expansion_sum_zeroelim(finlength, finnow, wlength, w,
X                                          finother);
X  finswap = finnow; finnow = finother; finother = finswap;
X
X  catlen = fast_expansion_sum_zeroelim(ct_alen, ct_a, at_clen, at_c, cat);
X  wlength = scale_expansion_zeroelim(catlen, cat, bdheight, w);
X  finlength = fast_expansion_sum_zeroelim(finlength, finnow, wlength, w,
X                                          finother);
X  finswap = finnow; finnow = finother; finother = finswap;
X
X  abtlen = fast_expansion_sum_zeroelim(at_blen, at_b, bt_alen, bt_a, abt);
X  wlength = scale_expansion_zeroelim(abtlen, abt, cdheight, w);
X  finlength = fast_expansion_sum_zeroelim(finlength, finnow, wlength, w,
X                                          finother);
X  finswap = finnow; finnow = finother; finother = finswap;
X
X  if (adheighttail != 0.0) {
X    vlength = scale_expansion_zeroelim(4, bc, adheighttail, v);
X    finlength = fast_expansion_sum_zeroelim(finlength, finnow, vlength, v,
X                                            finother);
X    finswap = finnow; finnow = finother; finother = finswap;
X  }
X  if (bdheighttail != 0.0) {
X    vlength = scale_expansion_zeroelim(4, ca, bdheighttail, v);
X    finlength = fast_expansion_sum_zeroelim(finlength, finnow, vlength, v,
X                                            finother);
X    finswap = finnow; finnow = finother; finother = finswap;
X  }
X  if (cdheighttail != 0.0) {
X    vlength = scale_expansion_zeroelim(4, ab, cdheighttail, v);
X    finlength = fast_expansion_sum_zeroelim(finlength, finnow, vlength, v,
X                                            finother);
X    finswap = finnow; finnow = finother; finother = finswap;
X  }
X
X  if (adxtail != 0.0) {
X    if (bdytail != 0.0) {
X      Two_Product(adxtail, bdytail, adxt_bdyt1, adxt_bdyt0);
X      Two_One_Product(adxt_bdyt1, adxt_bdyt0, cdheight, u3, u[2], u[1], u[0]);
X      u[3] = u3;
X      finlength = fast_expansion_sum_zeroelim(finlength, finnow, 4, u,
X                                              finother);
X      finswap = finnow; finnow = finother; finother = finswap;
X      if (cdheighttail != 0.0) {
X        Two_One_Product(adxt_bdyt1, adxt_bdyt0, cdheighttail,
X                        u3, u[2], u[1], u[0]);
X        u[3] = u3;
X        finlength = fast_expansion_sum_zeroelim(finlength, finnow, 4, u,
X                                                finother);
X        finswap = finnow; finnow = finother; finother = finswap;
X      }
X    }
X    if (cdytail != 0.0) {
X      negate = -adxtail;
X      Two_Product(negate, cdytail, adxt_cdyt1, adxt_cdyt0);
X      Two_One_Product(adxt_cdyt1, adxt_cdyt0, bdheight, u3, u[2], u[1], u[0]);
X      u[3] = u3;
X      finlength = fast_expansion_sum_zeroelim(finlength, finnow, 4, u,
X                                              finother);
X      finswap = finnow; finnow = finother; finother = finswap;
X      if (bdheighttail != 0.0) {
X        Two_One_Product(adxt_cdyt1, adxt_cdyt0, bdheighttail,
X                        u3, u[2], u[1], u[0]);
X        u[3] = u3;
X        finlength = fast_expansion_sum_zeroelim(finlength, finnow, 4, u,
X                                                finother);
X        finswap = finnow; finnow = finother; finother = finswap;
X      }
X    }
X  }
X  if (bdxtail != 0.0) {
X    if (cdytail != 0.0) {
X      Two_Product(bdxtail, cdytail, bdxt_cdyt1, bdxt_cdyt0);
X      Two_One_Product(bdxt_cdyt1, bdxt_cdyt0, adheight, u3, u[2], u[1], u[0]);
X      u[3] = u3;
X      finlength = fast_expansion_sum_zeroelim(finlength, finnow, 4, u,
X                                              finother);
X      finswap = finnow; finnow = finother; finother = finswap;
X      if (adheighttail != 0.0) {
X        Two_One_Product(bdxt_cdyt1, bdxt_cdyt0, adheighttail,
X                        u3, u[2], u[1], u[0]);
X        u[3] = u3;
X        finlength = fast_expansion_sum_zeroelim(finlength, finnow, 4, u,
X                                                finother);
X        finswap = finnow; finnow = finother; finother = finswap;
X      }
X    }
X    if (adytail != 0.0) {
X      negate = -bdxtail;
X      Two_Product(negate, adytail, bdxt_adyt1, bdxt_adyt0);
X      Two_One_Product(bdxt_adyt1, bdxt_adyt0, cdheight, u3, u[2], u[1], u[0]);
X      u[3] = u3;
X      finlength = fast_expansion_sum_zeroelim(finlength, finnow, 4, u,
X                                              finother);
X      finswap = finnow; finnow = finother; finother = finswap;
X      if (cdheighttail != 0.0) {
X        Two_One_Product(bdxt_adyt1, bdxt_adyt0, cdheighttail,
X                        u3, u[2], u[1], u[0]);
X        u[3] = u3;
X        finlength = fast_expansion_sum_zeroelim(finlength, finnow, 4, u,
X                                                finother);
X        finswap = finnow; finnow = finother; finother = finswap;
X      }
X    }
X  }
X  if (cdxtail != 0.0) {
X    if (adytail != 0.0) {
X      Two_Product(cdxtail, adytail, cdxt_adyt1, cdxt_adyt0);
X      Two_One_Product(cdxt_adyt1, cdxt_adyt0, bdheight, u3, u[2], u[1], u[0]);
X      u[3] = u3;
X      finlength = fast_expansion_sum_zeroelim(finlength, finnow, 4, u,
X                                              finother);
X      finswap = finnow; finnow = finother; finother = finswap;
X      if (bdheighttail != 0.0) {
X        Two_One_Product(cdxt_adyt1, cdxt_adyt0, bdheighttail,
X                        u3, u[2], u[1], u[0]);
X        u[3] = u3;
X        finlength = fast_expansion_sum_zeroelim(finlength, finnow, 4, u,
X                                                finother);
X        finswap = finnow; finnow = finother; finother = finswap;
X      }
X    }
X    if (bdytail != 0.0) {
X      negate = -cdxtail;
X      Two_Product(negate, bdytail, cdxt_bdyt1, cdxt_bdyt0);
X      Two_One_Product(cdxt_bdyt1, cdxt_bdyt0, adheight, u3, u[2], u[1], u[0]);
X      u[3] = u3;
X      finlength = fast_expansion_sum_zeroelim(finlength, finnow, 4, u,
X                                              finother);
X      finswap = finnow; finnow = finother; finother = finswap;
X      if (adheighttail != 0.0) {
X        Two_One_Product(cdxt_bdyt1, cdxt_bdyt0, adheighttail,
X                        u3, u[2], u[1], u[0]);
X        u[3] = u3;
X        finlength = fast_expansion_sum_zeroelim(finlength, finnow, 4, u,
X                                                finother);
X        finswap = finnow; finnow = finother; finother = finswap;
X      }
X    }
X  }
X
X  if (adheighttail != 0.0) {
X    wlength = scale_expansion_zeroelim(bctlen, bct, adheighttail, w);
X    finlength = fast_expansion_sum_zeroelim(finlength, finnow, wlength, w,
X                                            finother);
X    finswap = finnow; finnow = finother; finother = finswap;
X  }
X  if (bdheighttail != 0.0) {
X    wlength = scale_expansion_zeroelim(catlen, cat, bdheighttail, w);
X    finlength = fast_expansion_sum_zeroelim(finlength, finnow, wlength, w,
X                                            finother);
X    finswap = finnow; finnow = finother; finother = finswap;
X  }
X  if (cdheighttail != 0.0) {
X    wlength = scale_expansion_zeroelim(abtlen, abt, cdheighttail, w);
X    finlength = fast_expansion_sum_zeroelim(finlength, finnow, wlength, w,
X                                            finother);
X    finswap = finnow; finnow = finother; finother = finswap;
X  }
X
X  return finnow[finlength - 1];
}
X
#ifdef ANSI_DECLARATORS
REAL orient3d(struct mesh *m, struct behavior *b,
X              vertex pa, vertex pb, vertex pc, vertex pd,
X              REAL aheight, REAL bheight, REAL cheight, REAL dheight)
#else /* not ANSI_DECLARATORS */
REAL orient3d(m, b, pa, pb, pc, pd, aheight, bheight, cheight, dheight)
struct mesh *m;
struct behavior *b;
vertex pa;
vertex pb;
vertex pc;
vertex pd;
REAL aheight;
REAL bheight;
REAL cheight;
REAL dheight;
#endif /* not ANSI_DECLARATORS */
X
{
X  REAL adx, bdx, cdx, ady, bdy, cdy, adheight, bdheight, cdheight;
X  REAL bdxcdy, cdxbdy, cdxady, adxcdy, adxbdy, bdxady;
X  REAL det;
X  REAL permanent, errbound;
X
X  m->orient3dcount++;
X
X  adx = pa[0] - pd[0];
X  bdx = pb[0] - pd[0];
X  cdx = pc[0] - pd[0];
X  ady = pa[1] - pd[1];
X  bdy = pb[1] - pd[1];
X  cdy = pc[1] - pd[1];
X  adheight = aheight - dheight;
X  bdheight = bheight - dheight;
X  cdheight = cheight - dheight;
X
X  bdxcdy = bdx * cdy;
X  cdxbdy = cdx * bdy;
X
X  cdxady = cdx * ady;
X  adxcdy = adx * cdy;
X
X  adxbdy = adx * bdy;
X  bdxady = bdx * ady;
X
X  det = adheight * (bdxcdy - cdxbdy) 
X      + bdheight * (cdxady - adxcdy)
X      + cdheight * (adxbdy - bdxady);
X
X  if (b->noexact) {
X    return det;
X  }
X
X  permanent = (Absolute(bdxcdy) + Absolute(cdxbdy)) * Absolute(adheight)
X            + (Absolute(cdxady) + Absolute(adxcdy)) * Absolute(bdheight)
X            + (Absolute(adxbdy) + Absolute(bdxady)) * Absolute(cdheight);
X  errbound = o3derrboundA * permanent;
X  if ((det > errbound) || (-det > errbound)) {
X    return det;
X  }
X
X  return orient3dadapt(pa, pb, pc, pd, aheight, bheight, cheight, dheight,
X                       permanent);
}
X
/*****************************************************************************/
/*                                                                           */
/*  nonregular()   Return a positive value if the point pd is incompatible   */
/*                 with the circle or plane passing through pa, pb, and pc   */
/*                 (meaning that pd is inside the circle or below the        */
/*                 plane); a negative value if it is compatible; and zero if */
/*                 the four points are cocircular/coplanar.  The points pa,  */
/*                 pb, and pc must be in counterclockwise order, or the sign */
/*                 of the result will be reversed.                           */
/*                                                                           */
/*  If the -w switch is used, the points are lifted onto the parabolic       */
/*  lifting map, then they are dropped according to their weights, then the  */
/*  3D orientation test is applied.  If the -W switch is used, the points'   */
/*  heights are already provided, so the 3D orientation test is applied      */
/*  directly.  If neither switch is used, the incircle test is applied.      */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
REAL nonregular(struct mesh *m, struct behavior *b,
X                vertex pa, vertex pb, vertex pc, vertex pd)
#else /* not ANSI_DECLARATORS */
REAL nonregular(m, b, pa, pb, pc, pd)
struct mesh *m;
struct behavior *b;
vertex pa;
vertex pb;
vertex pc;
vertex pd;
#endif /* not ANSI_DECLARATORS */
X
{
X  if (b->weighted == 0) {
X    return incircle(m, b, pa, pb, pc, pd);
X  } else if (b->weighted == 1) {
X    return orient3d(m, b, pa, pb, pc, pd,
X                    pa[0] * pa[0] + pa[1] * pa[1] - pa[2],
X                    pb[0] * pb[0] + pb[1] * pb[1] - pb[2],
X                    pc[0] * pc[0] + pc[1] * pc[1] - pc[2],
X                    pd[0] * pd[0] + pd[1] * pd[1] - pd[2]);
X  } else {
X    return orient3d(m, b, pa, pb, pc, pd, pa[2], pb[2], pc[2], pd[2]);
X  }
}
X
/*****************************************************************************/
/*                                                                           */
/*  findcircumcenter()   Find the circumcenter of a triangle.                */
/*                                                                           */
/*  The result is returned both in terms of x-y coordinates and xi-eta       */
/*  (barycentric) coordinates.  The xi-eta coordinate system is defined in   */
/*  terms of the triangle:  the origin of the triangle is the origin of the  */
/*  coordinate system; the destination of the triangle is one unit along the */
/*  xi axis; and the apex of the triangle is one unit along the eta axis.    */
/*  This procedure also returns the square of the length of the triangle's   */
/*  shortest edge.                                                           */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
void findcircumcenter(struct mesh *m, struct behavior *b,
X                      vertex torg, vertex tdest, vertex tapex,
X                      vertex circumcenter, REAL *xi, REAL *eta, int offcenter)
#else /* not ANSI_DECLARATORS */
void findcircumcenter(m, b, torg, tdest, tapex, circumcenter, xi, eta,
X                      offcenter)
struct mesh *m;
struct behavior *b;
vertex torg;
vertex tdest;
vertex tapex;
vertex circumcenter;
REAL *xi;
REAL *eta;
int offcenter;
#endif /* not ANSI_DECLARATORS */
X
{
X  REAL xdo, ydo, xao, yao;
X  REAL dodist, aodist, dadist;
X  REAL denominator;
X  REAL dx, dy, dxoff, dyoff;
X
X  m->circumcentercount++;
X
X  /* Compute the circumcenter of the triangle. */
X  xdo = tdest[0] - torg[0];
X  ydo = tdest[1] - torg[1];
X  xao = tapex[0] - torg[0];
X  yao = tapex[1] - torg[1];
X  dodist = xdo * xdo + ydo * ydo;
X  aodist = xao * xao + yao * yao;
X  dadist = (tdest[0] - tapex[0]) * (tdest[0] - tapex[0]) +
X           (tdest[1] - tapex[1]) * (tdest[1] - tapex[1]);
X  if (b->noexact) {
X    denominator = 0.5 / (xdo * yao - xao * ydo);
X  } else {
X    /* Use the counterclockwise() routine to ensure a positive (and */
X    /*   reasonably accurate) result, avoiding any possibility of   */
X    /*   division by zero.                                          */
X    denominator = 0.5 / counterclockwise(m, b, tdest, tapex, torg);
X    /* Don't count the above as an orientation test. */
X    m->counterclockcount--;
X  }
X  dx = (yao * dodist - ydo * aodist) * denominator;
X  dy = (xdo * aodist - xao * dodist) * denominator;
X
X  /* Find the (squared) length of the triangle's shortest edge.  This   */
X  /*   serves as a conservative estimate of the insertion radius of the */
X  /*   circumcenter's parent.  The estimate is used to ensure that      */
X  /*   the algorithm terminates even if very small angles appear in     */
X  /*   the input PSLG.                                                  */
X  if ((dodist < aodist) && (dodist < dadist)) {
X    if (offcenter && (b->offconstant > 0.0)) {
X      /* Find the position of the off-center, as described by Alper Ungor. */
X      dxoff = 0.5 * xdo - b->offconstant * ydo;
X      dyoff = 0.5 * ydo + b->offconstant * xdo;
X      /* If the off-center is closer to the origin than the */
X      /*   circumcenter, use the off-center instead.        */
X      if (dxoff * dxoff + dyoff * dyoff < dx * dx + dy * dy) {
X        dx = dxoff;
X        dy = dyoff;
X      }
X    }
X  } else if (aodist < dadist) {
X    if (offcenter && (b->offconstant > 0.0)) {
X      dxoff = 0.5 * xao + b->offconstant * yao;
X      dyoff = 0.5 * yao - b->offconstant * xao;
X      /* If the off-center is closer to the origin than the */
X      /*   circumcenter, use the off-center instead.        */
X      if (dxoff * dxoff + dyoff * dyoff < dx * dx + dy * dy) {
X        dx = dxoff;
X        dy = dyoff;
X      }
X    }
X  } else {
X    if (offcenter && (b->offconstant > 0.0)) {
X      dxoff = 0.5 * (tapex[0] - tdest[0]) -
X              b->offconstant * (tapex[1] - tdest[1]);
X      dyoff = 0.5 * (tapex[1] - tdest[1]) +
X              b->offconstant * (tapex[0] - tdest[0]);
X      /* If the off-center is closer to the destination than the */
X      /*   circumcenter, use the off-center instead.             */
X      if (dxoff * dxoff + dyoff * dyoff <
X          (dx - xdo) * (dx - xdo) + (dy - ydo) * (dy - ydo)) {
X        dx = xdo + dxoff;
X        dy = ydo + dyoff;
X      }
X    }
X  }
X
X  circumcenter[0] = torg[0] + dx;
X  circumcenter[1] = torg[1] + dy;
X
X  /* To interpolate vertex attributes for the new vertex inserted at */
X  /*   the circumcenter, define a coordinate system with a xi-axis,  */
X  /*   directed from the triangle's origin to its destination, and   */
X  /*   an eta-axis, directed from its origin to its apex.            */
X  /*   Calculate the xi and eta coordinates of the circumcenter.     */
X  *xi = (yao * dx - xao * dy) * (2.0 * denominator);
X  *eta = (xdo * dy - ydo * dx) * (2.0 * denominator);
}
X
/**                                                                         **/
/**                                                                         **/
/********* Geometric primitives end here                             *********/
X
/*****************************************************************************/
/*                                                                           */
/*  triangleinit()   Initialize some variables.                              */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
void triangleinit(struct mesh *m)
#else /* not ANSI_DECLARATORS */
void triangleinit(m)
struct mesh *m;
#endif /* not ANSI_DECLARATORS */
X
{
X  poolzero(&m->vertices);
X  poolzero(&m->triangles);
X  poolzero(&m->subsegs);
X  poolzero(&m->viri);
X  poolzero(&m->badsubsegs);
X  poolzero(&m->badtriangles);
X  poolzero(&m->flipstackers);
X  poolzero(&m->splaynodes);
X
X  m->recenttri.tri = (triangle *) NULL; /* No triangle has been visited yet. */
X  m->undeads = 0;                       /* No eliminated input vertices yet. */
X  m->samples = 1;         /* Point location should take at least one sample. */
X  m->checksegments = 0;   /* There are no segments in the triangulation yet. */
X  m->checkquality = 0;     /* The quality triangulation stage has not begun. */
X  m->incirclecount = m->counterclockcount = m->orient3dcount = 0;
X  m->hyperbolacount = m->circletopcount = m->circumcentercount = 0;
X  randomseed = 1;
X
X  exactinit();                     /* Initialize exact arithmetic constants. */
}
X
/*****************************************************************************/
/*                                                                           */
/*  randomnation()   Generate a random number between 0 and `choices' - 1.   */
/*                                                                           */
/*  This is a simple linear congruential random number generator.  Hence, it */
/*  is a bad random number generator, but good enough for most randomized    */
/*  geometric algorithms.                                                    */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
unsigned long randomnation(unsigned int choices)
#else /* not ANSI_DECLARATORS */
unsigned long randomnation(choices)
unsigned int choices;
#endif /* not ANSI_DECLARATORS */
X
{
X  randomseed = (randomseed * 1366l + 150889l) % 714025l;
X  return randomseed / (714025l / choices + 1);
}
X
/********* Mesh quality testing routines begin here                  *********/
/**                                                                         **/
/**                                                                         **/
X
/*****************************************************************************/
/*                                                                           */
/*  checkmesh()   Test the mesh for topological consistency.                 */
/*                                                                           */
/*****************************************************************************/
X
#ifndef REDUCED
X
#ifdef ANSI_DECLARATORS
void checkmesh(struct mesh *m, struct behavior *b)
#else /* not ANSI_DECLARATORS */
void checkmesh(m, b)
struct mesh *m;
struct behavior *b;
#endif /* not ANSI_DECLARATORS */
X
{
X  struct otri triangleloop;
X  struct otri oppotri, oppooppotri;
X  vertex triorg, tridest, triapex;
X  vertex oppoorg, oppodest;
X  int horrors;
X  int saveexact;
X  triangle ptr;                         /* Temporary variable used by sym(). */
X
X  /* Temporarily turn on exact arithmetic if it's off. */
X  saveexact = b->noexact;
X  b->noexact = 0;
X  if (!b->quiet) {
X    printf("  Checking consistency of mesh...\n");
X  }
X  horrors = 0;
X  /* Run through the list of triangles, checking each one. */
X  traversalinit(&m->triangles);
X  triangleloop.tri = triangletraverse(m);
X  while (triangleloop.tri != (triangle *) NULL) {
X    /* Check all three edges of the triangle. */
X    for (triangleloop.orient = 0; triangleloop.orient < 3;
X         triangleloop.orient++) {
X      org(triangleloop, triorg);
X      dest(triangleloop, tridest);
X      if (triangleloop.orient == 0) {       /* Only test for inversion once. */
X        /* Test if the triangle is flat or inverted. */
X        apex(triangleloop, triapex);
X        if (counterclockwise(m, b, triorg, tridest, triapex) <= 0.0) {
X          printf("  !! !! Inverted ");
X          printtriangle(m, b, &triangleloop);
X          horrors++;
X        }
X      }
X      /* Find the neighboring triangle on this edge. */
X      sym(triangleloop, oppotri);
X      if (oppotri.tri != m->dummytri) {
X        /* Check that the triangle's neighbor knows it's a neighbor. */
X        sym(oppotri, oppooppotri);
X        if ((triangleloop.tri != oppooppotri.tri)
X            || (triangleloop.orient != oppooppotri.orient)) {
X          printf("  !! !! Asymmetric triangle-triangle bond:\n");
X          if (triangleloop.tri == oppooppotri.tri) {
X            printf("   (Right triangle, wrong orientation)\n");
X          }
X          printf("    First ");
X          printtriangle(m, b, &triangleloop);
X          printf("    Second (nonreciprocating) ");
X          printtriangle(m, b, &oppotri);
X          horrors++;
X        }
X        /* Check that both triangles agree on the identities */
X        /*   of their shared vertices.                       */
X        org(oppotri, oppoorg);
X        dest(oppotri, oppodest);
X        if ((triorg != oppodest) || (tridest != oppoorg)) {
X          printf("  !! !! Mismatched edge coordinates between two triangles:\n"
X                 );
X          printf("    First mismatched ");
X          printtriangle(m, b, &triangleloop);
X          printf("    Second mismatched ");
X          printtriangle(m, b, &oppotri);
X          horrors++;
X        }
X      }
X    }
X    triangleloop.tri = triangletraverse(m);
X  }
X  if (horrors == 0) {
X    if (!b->quiet) {
X      printf("  In my studied opinion, the mesh appears to be consistent.\n");
X    }
X  } else if (horrors == 1) {
X    printf("  !! !! !! !! Precisely one festering wound discovered.\n");
X  } else {
X    printf("  !! !! !! !! %d abominations witnessed.\n", horrors);
X  }
X  /* Restore the status of exact arithmetic. */
X  b->noexact = saveexact;
}
X
#endif /* not REDUCED */
X
/*****************************************************************************/
/*                                                                           */
/*  checkdelaunay()   Ensure that the mesh is (constrained) Delaunay.        */
/*                                                                           */
/*****************************************************************************/
X
#ifndef REDUCED
X
#ifdef ANSI_DECLARATORS
void checkdelaunay(struct mesh *m, struct behavior *b)
#else /* not ANSI_DECLARATORS */
void checkdelaunay(m, b)
struct mesh *m;
struct behavior *b;
#endif /* not ANSI_DECLARATORS */
X
{
X  struct otri triangleloop;
X  struct otri oppotri;
X  struct osub opposubseg;
X  vertex triorg, tridest, triapex;
X  vertex oppoapex;
X  int shouldbedelaunay;
X  int horrors;
X  int saveexact;
X  triangle ptr;                         /* Temporary variable used by sym(). */
X  subseg sptr;                      /* Temporary variable used by tspivot(). */
X
X  /* Temporarily turn on exact arithmetic if it's off. */
X  saveexact = b->noexact;
X  b->noexact = 0;
X  if (!b->quiet) {
X    printf("  Checking Delaunay property of mesh...\n");
X  }
X  horrors = 0;
X  /* Run through the list of triangles, checking each one. */
X  traversalinit(&m->triangles);
X  triangleloop.tri = triangletraverse(m);
X  while (triangleloop.tri != (triangle *) NULL) {
X    /* Check all three edges of the triangle. */
X    for (triangleloop.orient = 0; triangleloop.orient < 3;
X         triangleloop.orient++) {
X      org(triangleloop, triorg);
X      dest(triangleloop, tridest);
X      apex(triangleloop, triapex);
X      sym(triangleloop, oppotri);
X      apex(oppotri, oppoapex);
X      /* Only test that the edge is locally Delaunay if there is an   */
X      /*   adjoining triangle whose pointer is larger (to ensure that */
X      /*   each pair isn't tested twice).                             */
X      shouldbedelaunay = (oppotri.tri != m->dummytri) &&
X            !deadtri(oppotri.tri) && (triangleloop.tri < oppotri.tri) &&
X            (triorg != m->infvertex1) && (triorg != m->infvertex2) &&
X            (triorg != m->infvertex3) &&
X            (tridest != m->infvertex1) && (tridest != m->infvertex2) &&
X            (tridest != m->infvertex3) &&
X            (triapex != m->infvertex1) && (triapex != m->infvertex2) &&
X            (triapex != m->infvertex3) &&
X            (oppoapex != m->infvertex1) && (oppoapex != m->infvertex2) &&
X            (oppoapex != m->infvertex3);
X      if (m->checksegments && shouldbedelaunay) {
X        /* If a subsegment separates the triangles, then the edge is */
X        /*   constrained, so no local Delaunay test should be done.  */
X        tspivot(triangleloop, opposubseg);
X        if (opposubseg.ss != m->dummysub){
X          shouldbedelaunay = 0;
X        }
X      }
X      if (shouldbedelaunay) {
X        if (nonregular(m, b, triorg, tridest, triapex, oppoapex) > 0.0) {
X          if (!b->weighted) {
X            printf("  !! !! Non-Delaunay pair of triangles:\n");
X            printf("    First non-Delaunay ");
X            printtriangle(m, b, &triangleloop);
X            printf("    Second non-Delaunay ");
X          } else {
X            printf("  !! !! Non-regular pair of triangles:\n");
X            printf("    First non-regular ");
X            printtriangle(m, b, &triangleloop);
X            printf("    Second non-regular ");
X          }
X          printtriangle(m, b, &oppotri);
X          horrors++;
X        }
X      }
X    }
X    triangleloop.tri = triangletraverse(m);
X  }
X  if (horrors == 0) {
X    if (!b->quiet) {
X      printf(
X  "  By virtue of my perceptive intelligence, I declare the mesh Delaunay.\n");
X    }
X  } else if (horrors == 1) {
X    printf(
X         "  !! !! !! !! Precisely one terrifying transgression identified.\n");
X  } else {
X    printf("  !! !! !! !! %d obscenities viewed with horror.\n", horrors);
X  }
X  /* Restore the status of exact arithmetic. */
X  b->noexact = saveexact;
}
X
#endif /* not REDUCED */
X
/*****************************************************************************/
/*                                                                           */
/*  enqueuebadtriang()   Add a bad triangle data structure to the end of a   */
/*                       queue.                                              */
/*                                                                           */
/*  The queue is actually a set of 4096 queues.  I use multiple queues to    */
/*  give priority to smaller angles.  I originally implemented a heap, but   */
/*  the queues are faster by a larger margin than I'd suspected.             */
/*                                                                           */
/*****************************************************************************/
X
#ifndef CDT_ONLY
X
#ifdef ANSI_DECLARATORS
void enqueuebadtriang(struct mesh *m, struct behavior *b,
X                      struct badtriang *badtri)
#else /* not ANSI_DECLARATORS */
void enqueuebadtriang(m, b, badtri)
struct mesh *m;
struct behavior *b;
struct badtriang *badtri;
#endif /* not ANSI_DECLARATORS */
X
{
X  REAL length, multiplier;
X  int exponent, expincrement;
X  int queuenumber;
X  int posexponent;
X  int i;
X
X  if (b->verbose > 2) {
X    printf("  Queueing bad triangle:\n");
X    printf("    (%.12g, %.12g) (%.12g, %.12g) (%.12g, %.12g)\n",
X           badtri->triangorg[0], badtri->triangorg[1],
X           badtri->triangdest[0], badtri->triangdest[1],
X           badtri->triangapex[0], badtri->triangapex[1]);
X  }
X
X  /* Determine the appropriate queue to put the bad triangle into.    */
X  /*   Recall that the key is the square of its shortest edge length. */
X  if (badtri->key >= 1.0) {
X    length = badtri->key;
X    posexponent = 1;
X  } else {
X    /* `badtri->key' is 2.0 to a negative exponent, so we'll record that */
X    /*   fact and use the reciprocal of `badtri->key', which is > 1.0.   */
X    length = 1.0 / badtri->key;
X    posexponent = 0;
X  }
X  /* `length' is approximately 2.0 to what exponent?  The following code */
X  /*   determines the answer in time logarithmic in the exponent.        */
X  exponent = 0;
X  while (length > 2.0) {
X    /* Find an approximation by repeated squaring of two. */
X    expincrement = 1;
X    multiplier = 0.5;
X    while (length * multiplier * multiplier > 1.0) {
X      expincrement *= 2;
X      multiplier *= multiplier;
X    }
X    /* Reduce the value of `length', then iterate if necessary. */
X    exponent += expincrement;
X    length *= multiplier;
X  }
X  /* `length' is approximately squareroot(2.0) to what exponent? */
X  exponent = 2.0 * exponent + (length > SQUAREROOTTWO);
X  /* `exponent' is now in the range 0...2047 for IEEE double precision.   */
X  /*   Choose a queue in the range 0...4095.  The shortest edges have the */
X  /*   highest priority (queue 4095).                                     */
X  if (posexponent) {
X    queuenumber = 2047 - exponent;
X  } else {
X    queuenumber = 2048 + exponent;
X  }
X
X  /* Are we inserting into an empty queue? */
X  if (m->queuefront[queuenumber] == (struct badtriang *) NULL) {
X    /* Yes, we are inserting into an empty queue.     */
X    /*   Will this become the highest-priority queue? */
X    if (queuenumber > m->firstnonemptyq) {
X      /* Yes, this is the highest-priority queue. */
X      m->nextnonemptyq[queuenumber] = m->firstnonemptyq;
X      m->firstnonemptyq = queuenumber;
X    } else {
X      /* No, this is not the highest-priority queue. */
X      /*   Find the queue with next higher priority. */
X      i = queuenumber + 1;
X      while (m->queuefront[i] == (struct badtriang *) NULL) {
X        i++;
X      }
X      /* Mark the newly nonempty queue as following a higher-priority queue. */
X      m->nextnonemptyq[queuenumber] = m->nextnonemptyq[i];
X      m->nextnonemptyq[i] = queuenumber;
X    }
X    /* Put the bad triangle at the beginning of the (empty) queue. */
X    m->queuefront[queuenumber] = badtri;
X  } else {
X    /* Add the bad triangle to the end of an already nonempty queue. */
X    m->queuetail[queuenumber]->nexttriang = badtri;
X  }
X  /* Maintain a pointer to the last triangle of the queue. */
X  m->queuetail[queuenumber] = badtri;
X  /* Newly enqueued bad triangle has no successor in the queue. */
X  badtri->nexttriang = (struct badtriang *) NULL;
}
X
#endif /* not CDT_ONLY */
X
/*****************************************************************************/
/*                                                                           */
/*  enqueuebadtri()   Add a bad triangle to the end of a queue.              */
/*                                                                           */
/*  Allocates a badtriang data structure for the triangle, then passes it to */
/*  enqueuebadtriang().                                                      */
/*                                                                           */
/*****************************************************************************/
X
#ifndef CDT_ONLY
X
#ifdef ANSI_DECLARATORS
void enqueuebadtri(struct mesh *m, struct behavior *b, struct otri *enqtri,
X                   REAL minedge, vertex enqapex, vertex enqorg, vertex enqdest)
#else /* not ANSI_DECLARATORS */
void enqueuebadtri(m, b, enqtri, minedge, enqapex, enqorg, enqdest)
struct mesh *m;
struct behavior *b;
struct otri *enqtri;
REAL minedge;
vertex enqapex;
vertex enqorg;
vertex enqdest;
#endif /* not ANSI_DECLARATORS */
X
{
X  struct badtriang *newbad;
X
X  /* Allocate space for the bad triangle. */
X  newbad = (struct badtriang *) poolalloc(&m->badtriangles);
X  newbad->poortri = encode(*enqtri);
X  newbad->key = minedge;
X  newbad->triangapex = enqapex;
X  newbad->triangorg = enqorg;
X  newbad->triangdest = enqdest;
X  enqueuebadtriang(m, b, newbad);
}
X
#endif /* not CDT_ONLY */
X
/*****************************************************************************/
/*                                                                           */
/*  dequeuebadtriang()   Remove a triangle from the front of the queue.      */
/*                                                                           */
/*****************************************************************************/
X
#ifndef CDT_ONLY
X
#ifdef ANSI_DECLARATORS
struct badtriang *dequeuebadtriang(struct mesh *m)
#else /* not ANSI_DECLARATORS */
struct badtriang *dequeuebadtriang(m)
struct mesh *m;
#endif /* not ANSI_DECLARATORS */
X
{
X  struct badtriang *result;
X
X  /* If no queues are nonempty, return NULL. */
X  if (m->firstnonemptyq < 0) {
X    return (struct badtriang *) NULL;
X  }
X  /* Find the first triangle of the highest-priority queue. */
X  result = m->queuefront[m->firstnonemptyq];
X  /* Remove the triangle from the queue. */
X  m->queuefront[m->firstnonemptyq] = result->nexttriang;
X  /* If this queue is now empty, note the new highest-priority */
X  /*   nonempty queue.                                         */
X  if (result == m->queuetail[m->firstnonemptyq]) {
X    m->firstnonemptyq = m->nextnonemptyq[m->firstnonemptyq];
X  }
X  return result;
}
X
#endif /* not CDT_ONLY */
X
/*****************************************************************************/
/*                                                                           */
/*  checkseg4encroach()   Check a subsegment to see if it is encroached; add */
/*                        it to the list if it is.                           */
/*                                                                           */
/*  A subsegment is encroached if there is a vertex in its diametral lens.   */
/*  For Ruppert's algorithm (-D switch), the "diametral lens" is the         */
/*  diametral circle.  For Chew's algorithm (default), the diametral lens is */
/*  just big enough to enclose two isosceles triangles whose bases are the   */
/*  subsegment.  Each of the two isosceles triangles has two angles equal    */
/*  to `b->minangle'.                                                        */
/*                                                                           */
/*  Chew's algorithm does not require diametral lenses at all--but they save */
/*  time.  Any vertex inside a subsegment's diametral lens implies that the  */
/*  triangle adjoining the subsegment will be too skinny, so it's only a     */
/*  matter of time before the encroaching vertex is deleted by Chew's        */
/*  algorithm.  It's faster to simply not insert the doomed vertex in the    */
/*  first place, which is why I use diametral lenses with Chew's algorithm.  */
/*                                                                           */
/*  Returns a nonzero value if the subsegment is encroached.                 */
/*                                                                           */
/*****************************************************************************/
X
#ifndef CDT_ONLY
X
#ifdef ANSI_DECLARATORS
int checkseg4encroach(struct mesh *m, struct behavior *b,
X                      struct osub *testsubseg)
#else /* not ANSI_DECLARATORS */
int checkseg4encroach(m, b, testsubseg)
struct mesh *m;
struct behavior *b;
struct osub *testsubseg;
#endif /* not ANSI_DECLARATORS */
X
{
X  struct otri neighbortri;
X  struct osub testsym;
X  struct badsubseg *encroachedseg;
X  REAL dotproduct;
X  int encroached;
X  int sides;
X  vertex eorg, edest, eapex;
X  triangle ptr;                     /* Temporary variable used by stpivot(). */
X
X  encroached = 0;
X  sides = 0;
X
X  sorg(*testsubseg, eorg);
X  sdest(*testsubseg, edest);
X  /* Check one neighbor of the subsegment. */
X  stpivot(*testsubseg, neighbortri);
X  /* Does the neighbor exist, or is this a boundary edge? */
X  if (neighbortri.tri != m->dummytri) {
X    sides++;
X    /* Find a vertex opposite this subsegment. */
X    apex(neighbortri, eapex);
X    /* Check whether the apex is in the diametral lens of the subsegment */
X    /*   (the diametral circle if `conformdel' is set).  A dot product   */
X    /*   of two sides of the triangle is used to check whether the angle */
X    /*   at the apex is greater than (180 - 2 `minangle') degrees (for   */
X    /*   lenses; 90 degrees for diametral circles).                      */
X    dotproduct = (eorg[0] - eapex[0]) * (edest[0] - eapex[0]) +
X                 (eorg[1] - eapex[1]) * (edest[1] - eapex[1]);
X    if (dotproduct < 0.0) {
X      if (b->conformdel ||
X          (dotproduct * dotproduct >=
X           (2.0 * b->goodangle - 1.0) * (2.0 * b->goodangle - 1.0) *
X           ((eorg[0] - eapex[0]) * (eorg[0] - eapex[0]) +
X            (eorg[1] - eapex[1]) * (eorg[1] - eapex[1])) *
X           ((edest[0] - eapex[0]) * (edest[0] - eapex[0]) +
X            (edest[1] - eapex[1]) * (edest[1] - eapex[1])))) {
X        encroached = 1;
X      }
X    }
X  }
X  /* Check the other neighbor of the subsegment. */
X  ssym(*testsubseg, testsym);
X  stpivot(testsym, neighbortri);
X  /* Does the neighbor exist, or is this a boundary edge? */
X  if (neighbortri.tri != m->dummytri) {
X    sides++;
X    /* Find the other vertex opposite this subsegment. */
X    apex(neighbortri, eapex);
X    /* Check whether the apex is in the diametral lens of the subsegment */
X    /*   (or the diametral circle, if `conformdel' is set).              */
X    dotproduct = (eorg[0] - eapex[0]) * (edest[0] - eapex[0]) +
X                 (eorg[1] - eapex[1]) * (edest[1] - eapex[1]);
X    if (dotproduct < 0.0) {
X      if (b->conformdel ||
X          (dotproduct * dotproduct >=
X           (2.0 * b->goodangle - 1.0) * (2.0 * b->goodangle - 1.0) *
X           ((eorg[0] - eapex[0]) * (eorg[0] - eapex[0]) +
X            (eorg[1] - eapex[1]) * (eorg[1] - eapex[1])) *
X           ((edest[0] - eapex[0]) * (edest[0] - eapex[0]) +
X            (edest[1] - eapex[1]) * (edest[1] - eapex[1])))) {
X        encroached += 2;
X      }
X    }
X  }
X
X  if (encroached && (!b->nobisect || ((b->nobisect == 1) && (sides == 2)))) {
X    if (b->verbose > 2) {
X      printf(
X        "  Queueing encroached subsegment (%.12g, %.12g) (%.12g, %.12g).\n",
X        eorg[0], eorg[1], edest[0], edest[1]);
X    }
X    /* Add the subsegment to the list of encroached subsegments. */
X    /*   Be sure to get the orientation right.                   */
X    encroachedseg = (struct badsubseg *) poolalloc(&m->badsubsegs);
X    if (encroached == 1) {
X      encroachedseg->encsubseg = sencode(*testsubseg);
X      encroachedseg->subsegorg = eorg;
X      encroachedseg->subsegdest = edest;
X    } else {
X      encroachedseg->encsubseg = sencode(testsym);
X      encroachedseg->subsegorg = edest;
X      encroachedseg->subsegdest = eorg;
X    }
X  }
X
X  return encroached;
}
X
#endif /* not CDT_ONLY */
X
/*****************************************************************************/
/*                                                                           */
/*  testtriangle()   Test a triangle for quality and size.                   */
/*                                                                           */
/*  Tests a triangle to see if it satisfies the minimum angle condition and  */
/*  the maximum area condition.  Triangles that aren't up to spec are added  */
/*  to the bad triangle queue.                                               */
/*                                                                           */
/*****************************************************************************/
X
#ifndef CDT_ONLY
X
#ifdef ANSI_DECLARATORS
void testtriangle(struct mesh *m, struct behavior *b, struct otri *testtri)
#else /* not ANSI_DECLARATORS */
void testtriangle(m, b, testtri)
struct mesh *m;
struct behavior *b;
struct otri *testtri;
#endif /* not ANSI_DECLARATORS */
X
{
X  struct otri tri1, tri2;
X  struct osub testsub;
X  vertex torg, tdest, tapex;
X  vertex base1, base2;
X  vertex org1, dest1, org2, dest2;
X  vertex joinvertex;
X  REAL dxod, dyod, dxda, dyda, dxao, dyao;
X  REAL dxod2, dyod2, dxda2, dyda2, dxao2, dyao2;
X  REAL apexlen, orglen, destlen, minedge;
X  REAL angle;
X  REAL area;
X  REAL dist1, dist2;
X  subseg sptr;                      /* Temporary variable used by tspivot(). */
X  triangle ptr;           /* Temporary variable used by oprev() and dnext(). */
X
X  org(*testtri, torg);
X  dest(*testtri, tdest);
X  apex(*testtri, tapex);
X  dxod = torg[0] - tdest[0];
X  dyod = torg[1] - tdest[1];
X  dxda = tdest[0] - tapex[0];
X  dyda = tdest[1] - tapex[1];
X  dxao = tapex[0] - torg[0];
X  dyao = tapex[1] - torg[1];
X  dxod2 = dxod * dxod;
X  dyod2 = dyod * dyod;
X  dxda2 = dxda * dxda;
X  dyda2 = dyda * dyda;
X  dxao2 = dxao * dxao;
X  dyao2 = dyao * dyao;
X  /* Find the lengths of the triangle's three edges. */
X  apexlen = dxod2 + dyod2;
X  orglen = dxda2 + dyda2;
X  destlen = dxao2 + dyao2;
X
X  if ((apexlen < orglen) && (apexlen < destlen)) {
X    /* The edge opposite the apex is shortest. */
X    minedge = apexlen;
X    /* Find the square of the cosine of the angle at the apex. */
X    angle = dxda * dxao + dyda * dyao;
X    angle = angle * angle / (orglen * destlen);
X    base1 = torg;
X    base2 = tdest;
X    otricopy(*testtri, tri1);
X  } else if (orglen < destlen) {
X    /* The edge opposite the origin is shortest. */
X    minedge = orglen;
X    /* Find the square of the cosine of the angle at the origin. */
X    angle = dxod * dxao + dyod * dyao;
X    angle = angle * angle / (apexlen * destlen);
X    base1 = tdest;
X    base2 = tapex;
X    lnext(*testtri, tri1);
X  } else {
X    /* The edge opposite the destination is shortest. */
X    minedge = destlen;
X    /* Find the square of the cosine of the angle at the destination. */
X    angle = dxod * dxda + dyod * dyda;
X    angle = angle * angle / (apexlen * orglen);
X    base1 = tapex;
X    base2 = torg;
X    lprev(*testtri, tri1);
X  }
X
X  if (b->vararea || b->fixedarea || b->usertest) {
X    /* Check whether the area is larger than permitted. */
X    area = 0.5 * (dxod * dyda - dyod * dxda);
X    if (b->fixedarea && (area > b->maxarea)) {
X      /* Add this triangle to the list of bad triangles. */
X      enqueuebadtri(m, b, testtri, minedge, tapex, torg, tdest);
X      return;
X    }
X
X    /* Nonpositive area constraints are treated as unconstrained. */
X    if ((b->vararea) && (area > areabound(*testtri)) &&
X        (areabound(*testtri) > 0.0)) {
X      /* Add this triangle to the list of bad triangles. */
X      enqueuebadtri(m, b, testtri, minedge, tapex, torg, tdest);
X      return;
X    }
X
X    if (b->usertest) {
X      /* Check whether the user thinks this triangle is too large. */
X      if (triunsuitable(torg, tdest, tapex, area)) {
X        enqueuebadtri(m, b, testtri, minedge, tapex, torg, tdest);
X        return;
X      }
X    }
X  }
X
X  /* Check whether the angle is smaller than permitted. */
X  if (angle > b->goodangle) {
X    /* Use the rules of Miller, Pav, and Walkington to decide that certain */
X    /*   triangles should not be split, even if they have bad angles.      */
X    /*   A skinny triangle is not split if its shortest edge subtends a    */
X    /*   small input angle, and both endpoints of the edge lie on a        */
X    /*   concentric circular shell.  For convenience, I make a small       */
X    /*   adjustment to that rule:  I check if the endpoints of the edge    */
X    /*   both lie in segment interiors, equidistant from the apex where    */
X    /*   the two segments meet.                                            */
X    /* First, check if both points lie in segment interiors.               */
X    if ((vertextype(base1) == SEGMENTVERTEX) &&
X        (vertextype(base2) == SEGMENTVERTEX)) {
X      /* Check if both points lie in a common segment.  If they do, the */
X      /*   skinny triangle is enqueued to be split as usual.            */
X      tspivot(tri1, testsub);
X      if (testsub.ss == m->dummysub) {
X        /* No common segment.  Find a subsegment that contains `torg'. */
X        otricopy(tri1, tri2);
X        do {
X          oprevself(tri1);
X          tspivot(tri1, testsub);
X        } while (testsub.ss == m->dummysub);
X        /* Find the endpoints of the containing segment. */
X        segorg(testsub, org1);
X        segdest(testsub, dest1);
X        /* Find a subsegment that contains `tdest'. */
X        do {
X          dnextself(tri2);
X          tspivot(tri2, testsub);
X        } while (testsub.ss == m->dummysub);
X        /* Find the endpoints of the containing segment. */
X        segorg(testsub, org2);
X        segdest(testsub, dest2);
X        /* Check if the two containing segments have an endpoint in common. */
X        joinvertex = (vertex) NULL;
X        if ((dest1[0] == org2[0]) && (dest1[1] == org2[1])) {
X          joinvertex = dest1;
X        } else if ((org1[0] == dest2[0]) && (org1[1] == dest2[1])) {
X          joinvertex = org1;
X        }
X        if (joinvertex != (vertex) NULL) {
X          /* Compute the distance from the common endpoint (of the two  */
X          /*   segments) to each of the endpoints of the shortest edge. */
X          dist1 = ((base1[0] - joinvertex[0]) * (base1[0] - joinvertex[0]) +
X                   (base1[1] - joinvertex[1]) * (base1[1] - joinvertex[1]));
X          dist2 = ((base2[0] - joinvertex[0]) * (base2[0] - joinvertex[0]) +
X                   (base2[1] - joinvertex[1]) * (base2[1] - joinvertex[1]));
X          /* If the two distances are equal, don't split the triangle. */
X          if ((dist1 < 1.001 * dist2) && (dist1 > 0.999 * dist2)) {
X            /* Return now to avoid enqueueing the bad triangle. */
X            return;
X          }
X        }
X      }
X    }
X
X    /* Add this triangle to the list of bad triangles. */
X    enqueuebadtri(m, b, testtri, minedge, tapex, torg, tdest);
X  }
}
X
#endif /* not CDT_ONLY */
X
/**                                                                         **/
/**                                                                         **/
/********* Mesh quality testing routines end here                    *********/
X
/********* Point location routines begin here                        *********/
/**                                                                         **/
/**                                                                         **/
X
/*****************************************************************************/
/*                                                                           */
/*  makevertexmap()   Construct a mapping from vertices to triangles to      */
/*                    improve the speed of point location for segment        */
/*                    insertion.                                             */
/*                                                                           */
/*  Traverses all the triangles, and provides each corner of each triangle   */
/*  with a pointer to that triangle.  Of course, pointers will be            */
/*  overwritten by other pointers because (almost) each vertex is a corner   */
/*  of several triangles, but in the end every vertex will point to some     */
/*  triangle that contains it.                                               */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
void makevertexmap(struct mesh *m, struct behavior *b)
#else /* not ANSI_DECLARATORS */
void makevertexmap(m, b)
struct mesh *m;
struct behavior *b;
#endif /* not ANSI_DECLARATORS */
X
{
X  struct otri triangleloop;
X  vertex triorg;
X
X  if (b->verbose) {
X    printf("    Constructing mapping from vertices to triangles.\n");
X  }
X  traversalinit(&m->triangles);
X  triangleloop.tri = triangletraverse(m);
X  while (triangleloop.tri != (triangle *) NULL) {
X    /* Check all three vertices of the triangle. */
X    for (triangleloop.orient = 0; triangleloop.orient < 3;
X         triangleloop.orient++) {
X      org(triangleloop, triorg);
X      setvertex2tri(triorg, encode(triangleloop));
X    }
X    triangleloop.tri = triangletraverse(m);
X  }
}
X
/*****************************************************************************/
/*                                                                           */
/*  preciselocate()   Find a triangle or edge containing a given point.      */
/*                                                                           */
/*  Begins its search from `searchtri'.  It is important that `searchtri'    */
/*  be a handle with the property that `searchpoint' is strictly to the left */
/*  of the edge denoted by `searchtri', or is collinear with that edge and   */
/*  does not intersect that edge.  (In particular, `searchpoint' should not  */
/*  be the origin or destination of that edge.)                              */
/*                                                                           */
/*  These conditions are imposed because preciselocate() is normally used in */
/*  one of two situations:                                                   */
/*                                                                           */
/*  (1)  To try to find the location to insert a new point.  Normally, we    */
/*       know an edge that the point is strictly to the left of.  In the     */
/*       incremental Delaunay algorithm, that edge is a bounding box edge.   */
/*       In Ruppert's Delaunay refinement algorithm for quality meshing,     */
/*       that edge is the shortest edge of the triangle whose circumcenter   */
/*       is being inserted.                                                  */
/*                                                                           */
/*  (2)  To try to find an existing point.  In this case, any edge on the    */
/*       convex hull is a good starting edge.  You must screen out the       */
/*       possibility that the vertex sought is an endpoint of the starting   */
/*       edge before you call preciselocate().                               */
/*                                                                           */
/*  On completion, `searchtri' is a triangle that contains `searchpoint'.    */
/*                                                                           */
/*  This implementation differs from that given by Guibas and Stolfi.  It    */
/*  walks from triangle to triangle, crossing an edge only if `searchpoint'  */
/*  is on the other side of the line containing that edge.  After entering   */
/*  a triangle, there are two edges by which one can leave that triangle.    */
/*  If both edges are valid (`searchpoint' is on the other side of both      */
/*  edges), one of the two is chosen by drawing a line perpendicular to      */
/*  the entry edge (whose endpoints are `forg' and `fdest') passing through  */
/*  `fapex'.  Depending on which side of this perpendicular `searchpoint'    */
/*  falls on, an exit edge is chosen.                                        */
/*                                                                           */
/*  This implementation is empirically faster than the Guibas and Stolfi     */
/*  point location routine (which I originally used), which tends to spiral  */
/*  in toward its target.                                                    */
/*                                                                           */
/*  Returns ONVERTEX if the point lies on an existing vertex.  `searchtri'   */
/*  is a handle whose origin is the existing vertex.                         */
/*                                                                           */
/*  Returns ONEDGE if the point lies on a mesh edge.  `searchtri' is a       */
/*  handle whose primary edge is the edge on which the point lies.           */
/*                                                                           */
/*  Returns INTRIANGLE if the point lies strictly within a triangle.         */
/*  `searchtri' is a handle on the triangle that contains the point.         */
/*                                                                           */
/*  Returns OUTSIDE if the point lies outside the mesh.  `searchtri' is a    */
/*  handle whose primary edge the point is to the right of.  This might      */
/*  occur when the circumcenter of a triangle falls just slightly outside    */
/*  the mesh due to floating-point roundoff error.  It also occurs when      */
/*  seeking a hole or region point that a foolish user has placed outside    */
/*  the mesh.                                                                */
/*                                                                           */
/*  If `stopatsubsegment' is nonzero, the search will stop if it tries to    */
/*  walk through a subsegment, and will return OUTSIDE.                      */
/*                                                                           */
/*  WARNING:  This routine is designed for convex triangulations, and will   */
/*  not generally work after the holes and concavities have been carved.     */
/*  However, it can still be used to find the circumcenter of a triangle, as */
/*  long as the search is begun from the triangle in question.               */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
enum locateresult preciselocate(struct mesh *m, struct behavior *b,
X                                vertex searchpoint, struct otri *searchtri,
X                                int stopatsubsegment)
#else /* not ANSI_DECLARATORS */
enum locateresult preciselocate(m, b, searchpoint, searchtri, stopatsubsegment)
struct mesh *m;
struct behavior *b;
vertex searchpoint;
struct otri *searchtri;
int stopatsubsegment;
#endif /* not ANSI_DECLARATORS */
X
{
X  struct otri backtracktri;
X  struct osub checkedge;
X  vertex forg, fdest, fapex;
X  REAL orgorient, destorient;
X  int moveleft;
X  triangle ptr;                         /* Temporary variable used by sym(). */
X  subseg sptr;                      /* Temporary variable used by tspivot(). */
X
X  if (b->verbose > 2) {
X    printf("  Searching for point (%.12g, %.12g).\n",
X           searchpoint[0], searchpoint[1]);
X  }
X  /* Where are we? */
X  org(*searchtri, forg);
X  dest(*searchtri, fdest);
X  apex(*searchtri, fapex);
X  while (1) {
X    if (b->verbose > 2) {
X      printf("    At (%.12g, %.12g) (%.12g, %.12g) (%.12g, %.12g)\n",
X             forg[0], forg[1], fdest[0], fdest[1], fapex[0], fapex[1]);
X    }
X    /* Check whether the apex is the point we seek. */
X    if ((fapex[0] == searchpoint[0]) && (fapex[1] == searchpoint[1])) {
X      lprevself(*searchtri);
X      return ONVERTEX;
X    }
X    /* Does the point lie on the other side of the line defined by the */
X    /*   triangle edge opposite the triangle's destination?            */
X    destorient = counterclockwise(m, b, forg, fapex, searchpoint);
X    /* Does the point lie on the other side of the line defined by the */
X    /*   triangle edge opposite the triangle's origin?                 */
X    orgorient = counterclockwise(m, b, fapex, fdest, searchpoint);
X    if (destorient > 0.0) {
X      if (orgorient > 0.0) {
X        /* Move left if the inner product of (fapex - searchpoint) and  */
X        /*   (fdest - forg) is positive.  This is equivalent to drawing */
X        /*   a line perpendicular to the line (forg, fdest) and passing */
X        /*   through `fapex', and determining which side of this line   */
X        /*   `searchpoint' falls on.                                    */
X        moveleft = (fapex[0] - searchpoint[0]) * (fdest[0] - forg[0]) +
X                   (fapex[1] - searchpoint[1]) * (fdest[1] - forg[1]) > 0.0;
X      } else {
X        moveleft = 1;
X      }
X    } else {
X      if (orgorient > 0.0) {
X        moveleft = 0;
X      } else {
X        /* The point we seek must be on the boundary of or inside this */
X        /*   triangle.                                                 */
X        if (destorient == 0.0) {
X          lprevself(*searchtri);
X          return ONEDGE;
X        }
X        if (orgorient == 0.0) {
X          lnextself(*searchtri);
X          return ONEDGE;
X        }
X        return INTRIANGLE;
X      }
X    }
X
X    /* Move to another triangle.  Leave a trace `backtracktri' in case */
X    /*   floating-point roundoff or some such bogey causes us to walk  */
X    /*   off a boundary of the triangulation.                          */
X    if (moveleft) {
X      lprev(*searchtri, backtracktri);
X      fdest = fapex;
X    } else {
X      lnext(*searchtri, backtracktri);
X      forg = fapex;
X    }
X    sym(backtracktri, *searchtri);
X
X    if (m->checksegments && stopatsubsegment) {
X      /* Check for walking through a subsegment. */
X      tspivot(backtracktri, checkedge);
X      if (checkedge.ss != m->dummysub) {
X        /* Go back to the last triangle. */
X        otricopy(backtracktri, *searchtri);
X        return OUTSIDE;
X      }
X    }
X    /* Check for walking right out of the triangulation. */
X    if (searchtri->tri == m->dummytri) {
X      /* Go back to the last triangle. */
X      otricopy(backtracktri, *searchtri);
X      return OUTSIDE;
X    }
X
X    apex(*searchtri, fapex);
X  }
}
X
/*****************************************************************************/
/*                                                                           */
/*  locate()   Find a triangle or edge containing a given point.             */
/*                                                                           */
/*  Searching begins from one of:  the input `searchtri', a recently         */
/*  encountered triangle `recenttri', or from a triangle chosen from a       */
/*  random sample.  The choice is made by determining which triangle's       */
/*  origin is closest to the point we are searching for.  Normally,          */
/*  `searchtri' should be a handle on the convex hull of the triangulation.  */
/*                                                                           */
/*  Details on the random sampling method can be found in the Mucke, Saias,  */
/*  and Zhu paper cited in the header of this code.                          */
/*                                                                           */
/*  On completion, `searchtri' is a triangle that contains `searchpoint'.    */
/*                                                                           */
/*  Returns ONVERTEX if the point lies on an existing vertex.  `searchtri'   */
/*  is a handle whose origin is the existing vertex.                         */
/*                                                                           */
/*  Returns ONEDGE if the point lies on a mesh edge.  `searchtri' is a       */
/*  handle whose primary edge is the edge on which the point lies.           */
/*                                                                           */
/*  Returns INTRIANGLE if the point lies strictly within a triangle.         */
/*  `searchtri' is a handle on the triangle that contains the point.         */
/*                                                                           */
/*  Returns OUTSIDE if the point lies outside the mesh.  `searchtri' is a    */
/*  handle whose primary edge the point is to the right of.  This might      */
/*  occur when the circumcenter of a triangle falls just slightly outside    */
/*  the mesh due to floating-point roundoff error.  It also occurs when      */
/*  seeking a hole or region point that a foolish user has placed outside    */
/*  the mesh.                                                                */
/*                                                                           */
/*  WARNING:  This routine is designed for convex triangulations, and will   */
/*  not generally work after the holes and concavities have been carved.     */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
enum locateresult locate(struct mesh *m, struct behavior *b,
X                         vertex searchpoint, struct otri *searchtri)
#else /* not ANSI_DECLARATORS */
enum locateresult locate(m, b, searchpoint, searchtri)
struct mesh *m;
struct behavior *b;
vertex searchpoint;
struct otri *searchtri;
#endif /* not ANSI_DECLARATORS */
X
{
X  VOID **sampleblock;
X  char *firsttri;
X  struct otri sampletri;
X  vertex torg, tdest;
X  unsigned long alignptr;
X  REAL searchdist, dist;
X  REAL ahead;
X  long samplesperblock, totalsamplesleft, samplesleft;
X  long population, totalpopulation;
X  triangle ptr;                         /* Temporary variable used by sym(). */
X
X  if (b->verbose > 2) {
X    printf("  Randomly sampling for a triangle near point (%.12g, %.12g).\n",
X           searchpoint[0], searchpoint[1]);
X  }
X  /* Record the distance from the suggested starting triangle to the */
X  /*   point we seek.                                                */
X  org(*searchtri, torg);
X  searchdist = (searchpoint[0] - torg[0]) * (searchpoint[0] - torg[0]) +
X               (searchpoint[1] - torg[1]) * (searchpoint[1] - torg[1]);
X  if (b->verbose > 2) {
X    printf("    Boundary triangle has origin (%.12g, %.12g).\n",
X           torg[0], torg[1]);
X  }
X
X  /* If a recently encountered triangle has been recorded and has not been */
X  /*   deallocated, test it as a good starting point.                      */
X  if (m->recenttri.tri != (triangle *) NULL) {
X    if (!deadtri(m->recenttri.tri)) {
X      org(m->recenttri, torg);
X      if ((torg[0] == searchpoint[0]) && (torg[1] == searchpoint[1])) {
X        otricopy(m->recenttri, *searchtri);
X        return ONVERTEX;
X      }
X      dist = (searchpoint[0] - torg[0]) * (searchpoint[0] - torg[0]) +
X             (searchpoint[1] - torg[1]) * (searchpoint[1] - torg[1]);
X      if (dist < searchdist) {
X        otricopy(m->recenttri, *searchtri);
X        searchdist = dist;
X        if (b->verbose > 2) {
X          printf("    Choosing recent triangle with origin (%.12g, %.12g).\n",
X                 torg[0], torg[1]);
X        }
X      }
X    }
X  }
X
X  /* The number of random samples taken is proportional to the cube root of */
X  /*   the number of triangles in the mesh.  The next bit of code assumes   */
X  /*   that the number of triangles increases monotonically (or at least    */
X  /*   doesn't decrease enough to matter).                                  */
X  while (SAMPLEFACTOR * m->samples * m->samples * m->samples <
X         m->triangles.items) {
X    m->samples++;
X  }
X
X  /* We'll draw ceiling(samples * TRIPERBLOCK / maxitems) random samples  */
X  /*   from each block of triangles (except the first)--until we meet the */
X  /*   sample quota.  The ceiling means that blocks at the end might be   */
X  /*   neglected, but I don't care.                                       */
X  samplesperblock = (m->samples * TRIPERBLOCK - 1) / m->triangles.maxitems + 1;
X  /* We'll draw ceiling(samples * itemsfirstblock / maxitems) random samples */
X  /*   from the first block of triangles.                                    */
X  samplesleft = (m->samples * m->triangles.itemsfirstblock - 1) /
X                m->triangles.maxitems + 1;
X  totalsamplesleft = m->samples;
X  population = m->triangles.itemsfirstblock;
X  totalpopulation = m->triangles.maxitems;
X  sampleblock = m->triangles.firstblock;
X  sampletri.orient = 0;
X  while (totalsamplesleft > 0) {
X    /* If we're in the last block, `population' needs to be corrected. */
X    if (population > totalpopulation) {
X      population = totalpopulation;
X    }
X    /* Find a pointer to the first triangle in the block. */
X    alignptr = (unsigned long) (sampleblock + 1);
X    firsttri = (char *) (alignptr +
X                         (unsigned long) m->triangles.alignbytes -
X                         (alignptr %
X                          (unsigned long) m->triangles.alignbytes));
X
X    /* Choose `samplesleft' randomly sampled triangles in this block. */
X    do {
X      sampletri.tri = (triangle *) (firsttri +
X                                    (randomnation((unsigned int) population) *
X                                     m->triangles.itembytes));
X      if (!deadtri(sampletri.tri)) {
X        org(sampletri, torg);
X        dist = (searchpoint[0] - torg[0]) * (searchpoint[0] - torg[0]) +
X               (searchpoint[1] - torg[1]) * (searchpoint[1] - torg[1]);
X        if (dist < searchdist) {
X          otricopy(sampletri, *searchtri);
X          searchdist = dist;
X          if (b->verbose > 2) {
X            printf("    Choosing triangle with origin (%.12g, %.12g).\n",
X                   torg[0], torg[1]);
X          }
X        }
X      }
X
X      samplesleft--;
X      totalsamplesleft--;
X    } while ((samplesleft > 0) && (totalsamplesleft > 0));
X
X    if (totalsamplesleft > 0) {
X      sampleblock = (VOID **) *sampleblock;
X      samplesleft = samplesperblock;
X      totalpopulation -= population;
X      population = TRIPERBLOCK;
X    }
X  }
X
X  /* Where are we? */
X  org(*searchtri, torg);
X  dest(*searchtri, tdest);
X  /* Check the starting triangle's vertices. */
X  if ((torg[0] == searchpoint[0]) && (torg[1] == searchpoint[1])) {
X    return ONVERTEX;
X  }
X  if ((tdest[0] == searchpoint[0]) && (tdest[1] == searchpoint[1])) {
X    lnextself(*searchtri);
X    return ONVERTEX;
X  }
X  /* Orient `searchtri' to fit the preconditions of calling preciselocate(). */
X  ahead = counterclockwise(m, b, torg, tdest, searchpoint);
X  if (ahead < 0.0) {
X    /* Turn around so that `searchpoint' is to the left of the */
X    /*   edge specified by `searchtri'.                        */
X    symself(*searchtri);
X  } else if (ahead == 0.0) {
X    /* Check if `searchpoint' is between `torg' and `tdest'. */
X    if (((torg[0] < searchpoint[0]) == (searchpoint[0] < tdest[0])) &&
X        ((torg[1] < searchpoint[1]) == (searchpoint[1] < tdest[1]))) {
X      return ONEDGE;
X    }
X  }
X  return preciselocate(m, b, searchpoint, searchtri, 0);
}
X
/**                                                                         **/
/**                                                                         **/
/********* Point location routines end here                          *********/
X
/********* Mesh transformation routines begin here                   *********/
/**                                                                         **/
/**                                                                         **/
X
/*****************************************************************************/
/*                                                                           */
/*  insertsubseg()   Create a new subsegment and insert it between two       */
/*                   triangles.                                              */
/*                                                                           */
/*  The new subsegment is inserted at the edge described by the handle       */
/*  `tri'.  Its vertices are properly initialized.  The marker `subsegmark'  */
/*  is applied to the subsegment and, if appropriate, its vertices.          */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
void insertsubseg(struct mesh *m, struct behavior *b, struct otri *tri,
X                  int subsegmark)
#else /* not ANSI_DECLARATORS */
void insertsubseg(m, b, tri, subsegmark)
struct mesh *m;
struct behavior *b;
struct otri *tri;             /* Edge at which to insert the new subsegment. */
int subsegmark;                            /* Marker for the new subsegment. */
#endif /* not ANSI_DECLARATORS */
X
{
X  struct otri oppotri;
X  struct osub newsubseg;
X  vertex triorg, tridest;
X  triangle ptr;                         /* Temporary variable used by sym(). */
X  subseg sptr;                      /* Temporary variable used by tspivot(). */
X
X  org(*tri, triorg);
X  dest(*tri, tridest);
X  /* Mark vertices if possible. */
X  if (vertexmark(triorg) == 0) {
X    setvertexmark(triorg, subsegmark);
X  }
X  if (vertexmark(tridest) == 0) {
X    setvertexmark(tridest, subsegmark);
X  }
X  /* Check if there's already a subsegment here. */
X  tspivot(*tri, newsubseg);
X  if (newsubseg.ss == m->dummysub) {
X    /* Make new subsegment and initialize its vertices. */
X    makesubseg(m, &newsubseg);
X    setsorg(newsubseg, tridest);
X    setsdest(newsubseg, triorg);
X    setsegorg(newsubseg, tridest);
X    setsegdest(newsubseg, triorg);
X    /* Bond new subsegment to the two triangles it is sandwiched between. */
X    /*   Note that the facing triangle `oppotri' might be equal to        */
X    /*   `dummytri' (outer space), but the new subsegment is bonded to it */
X    /*   all the same.                                                    */
X    tsbond(*tri, newsubseg);
X    sym(*tri, oppotri);
X    ssymself(newsubseg);
X    tsbond(oppotri, newsubseg);
X    setmark(newsubseg, subsegmark);
X    if (b->verbose > 2) {
X      printf("  Inserting new ");
X      printsubseg(m, b, &newsubseg);
X    }
X  } else {
X    if (mark(newsubseg) == 0) {
X      setmark(newsubseg, subsegmark);
X    }
X  }
}
X
/*****************************************************************************/
/*                                                                           */
/*  Terminology                                                              */
/*                                                                           */
/*  A "local transformation" replaces a small set of triangles with another  */
/*  set of triangles.  This may or may not involve inserting or deleting a   */
/*  vertex.                                                                  */
/*                                                                           */
/*  The term "casing" is used to describe the set of triangles that are      */
/*  attached to the triangles being transformed, but are not transformed     */
/*  themselves.  Think of the casing as a fixed hollow structure inside      */
/*  which all the action happens.  A "casing" is only defined relative to    */
/*  a single transformation; each occurrence of a transformation will        */
/*  involve a different casing.                                              */
/*                                                                           */
/*****************************************************************************/
X
/*****************************************************************************/
/*                                                                           */
/*  flip()   Transform two triangles to two different triangles by flipping  */
/*           an edge counterclockwise within a quadrilateral.                */
/*                                                                           */
/*  Imagine the original triangles, abc and bad, oriented so that the        */
/*  shared edge ab lies in a horizontal plane, with the vertex b on the left */
/*  and the vertex a on the right.  The vertex c lies below the edge, and    */
/*  the vertex d lies above the edge.  The `flipedge' handle holds the edge  */
/*  ab of triangle abc, and is directed left, from vertex a to vertex b.     */
/*                                                                           */
/*  The triangles abc and bad are deleted and replaced by the triangles cdb  */
/*  and dca.  The triangles that represent abc and bad are NOT deallocated;  */
/*  they are reused for dca and cdb, respectively.  Hence, any handles that  */
/*  may have held the original triangles are still valid, although not       */
/*  directed as they were before.                                            */
/*                                                                           */
/*  Upon completion of this routine, the `flipedge' handle holds the edge    */
/*  dc of triangle dca, and is directed down, from vertex d to vertex c.     */
/*  (Hence, the two triangles have rotated counterclockwise.)                */
/*                                                                           */
/*  WARNING:  This transformation is geometrically valid only if the         */
/*  quadrilateral adbc is convex.  Furthermore, this transformation is       */
/*  valid only if there is not a subsegment between the triangles abc and    */
/*  bad.  This routine does not check either of these preconditions, and     */
/*  it is the responsibility of the calling routine to ensure that they are  */
/*  met.  If they are not, the streets shall be filled with wailing and      */
/*  gnashing of teeth.                                                       */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
void flip(struct mesh *m, struct behavior *b, struct otri *flipedge)
#else /* not ANSI_DECLARATORS */
void flip(m, b, flipedge)
struct mesh *m;
struct behavior *b;
struct otri *flipedge;                    /* Handle for the triangle abc. */
#endif /* not ANSI_DECLARATORS */
X
{
X  struct otri botleft, botright;
X  struct otri topleft, topright;
X  struct otri top;
X  struct otri botlcasing, botrcasing;
X  struct otri toplcasing, toprcasing;
X  struct osub botlsubseg, botrsubseg;
X  struct osub toplsubseg, toprsubseg;
X  vertex leftvertex, rightvertex, botvertex;
X  vertex farvertex;
X  triangle ptr;                         /* Temporary variable used by sym(). */
X  subseg sptr;                      /* Temporary variable used by tspivot(). */
X
X  /* Identify the vertices of the quadrilateral. */
X  org(*flipedge, rightvertex);
X  dest(*flipedge, leftvertex);
X  apex(*flipedge, botvertex);
X  sym(*flipedge, top);
#ifdef SELF_CHECK
X  if (top.tri == m->dummytri) {
X    printf("Internal error in flip():  Attempt to flip on boundary.\n");
X    lnextself(*flipedge);
X    return;
X  }
X  if (m->checksegments) {
X    tspivot(*flipedge, toplsubseg);
X    if (toplsubseg.ss != m->dummysub) {
X      printf("Internal error in flip():  Attempt to flip a segment.\n");
X      lnextself(*flipedge);
X      return;
X    }
X  }
#endif /* SELF_CHECK */
X  apex(top, farvertex);
X
X  /* Identify the casing of the quadrilateral. */
X  lprev(top, topleft);
X  sym(topleft, toplcasing);
X  lnext(top, topright);
X  sym(topright, toprcasing);
X  lnext(*flipedge, botleft);
X  sym(botleft, botlcasing);
X  lprev(*flipedge, botright);
X  sym(botright, botrcasing);
X  /* Rotate the quadrilateral one-quarter turn counterclockwise. */
X  bond(topleft, botlcasing);
X  bond(botleft, botrcasing);
X  bond(botright, toprcasing);
X  bond(topright, toplcasing);
X
X  if (m->checksegments) {
X    /* Check for subsegments and rebond them to the quadrilateral. */
X    tspivot(topleft, toplsubseg);
X    tspivot(botleft, botlsubseg);
X    tspivot(botright, botrsubseg);
X    tspivot(topright, toprsubseg);
X    if (toplsubseg.ss == m->dummysub) {
X      tsdissolve(topright);
X    } else {
X      tsbond(topright, toplsubseg);
X    }
X    if (botlsubseg.ss == m->dummysub) {
X      tsdissolve(topleft);
X    } else {
X      tsbond(topleft, botlsubseg);
X    }
X    if (botrsubseg.ss == m->dummysub) {
X      tsdissolve(botleft);
X    } else {
X      tsbond(botleft, botrsubseg);
X    }
X    if (toprsubseg.ss == m->dummysub) {
X      tsdissolve(botright);
X    } else {
X      tsbond(botright, toprsubseg);
X    }
X  }
X
X  /* New vertex assignments for the rotated quadrilateral. */
X  setorg(*flipedge, farvertex);
X  setdest(*flipedge, botvertex);
X  setapex(*flipedge, rightvertex);
X  setorg(top, botvertex);
X  setdest(top, farvertex);
X  setapex(top, leftvertex);
X  if (b->verbose > 2) {
X    printf("  Edge flip results in left ");
X    printtriangle(m, b, &top);
X    printf("  and right ");
X    printtriangle(m, b, flipedge);
X  }
}
X
/*****************************************************************************/
/*                                                                           */
/*  unflip()   Transform two triangles to two different triangles by         */
/*             flipping an edge clockwise within a quadrilateral.  Reverses  */
/*             the flip() operation so that the data structures representing */
/*             the triangles are back where they were before the flip().     */
/*                                                                           */
/*  Imagine the original triangles, abc and bad, oriented so that the        */
/*  shared edge ab lies in a horizontal plane, with the vertex b on the left */
/*  and the vertex a on the right.  The vertex c lies below the edge, and    */
/*  the vertex d lies above the edge.  The `flipedge' handle holds the edge  */
/*  ab of triangle abc, and is directed left, from vertex a to vertex b.     */
/*                                                                           */
/*  The triangles abc and bad are deleted and replaced by the triangles cdb  */
/*  and dca.  The triangles that represent abc and bad are NOT deallocated;  */
/*  they are reused for cdb and dca, respectively.  Hence, any handles that  */
/*  may have held the original triangles are still valid, although not       */
/*  directed as they were before.                                            */
/*                                                                           */
/*  Upon completion of this routine, the `flipedge' handle holds the edge    */
/*  cd of triangle cdb, and is directed up, from vertex c to vertex d.       */
/*  (Hence, the two triangles have rotated clockwise.)                       */
/*                                                                           */
/*  WARNING:  This transformation is geometrically valid only if the         */
/*  quadrilateral adbc is convex.  Furthermore, this transformation is       */
/*  valid only if there is not a subsegment between the triangles abc and    */
/*  bad.  This routine does not check either of these preconditions, and     */
/*  it is the responsibility of the calling routine to ensure that they are  */
/*  met.  If they are not, the streets shall be filled with wailing and      */
/*  gnashing of teeth.                                                       */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
void unflip(struct mesh *m, struct behavior *b, struct otri *flipedge)
#else /* not ANSI_DECLARATORS */
void unflip(m, b, flipedge)
struct mesh *m;
struct behavior *b;
struct otri *flipedge;                    /* Handle for the triangle abc. */
#endif /* not ANSI_DECLARATORS */
X
{
X  struct otri botleft, botright;
X  struct otri topleft, topright;
X  struct otri top;
X  struct otri botlcasing, botrcasing;
X  struct otri toplcasing, toprcasing;
X  struct osub botlsubseg, botrsubseg;
X  struct osub toplsubseg, toprsubseg;
X  vertex leftvertex, rightvertex, botvertex;
X  vertex farvertex;
X  triangle ptr;                         /* Temporary variable used by sym(). */
X  subseg sptr;                      /* Temporary variable used by tspivot(). */
X
X  /* Identify the vertices of the quadrilateral. */
X  org(*flipedge, rightvertex);
X  dest(*flipedge, leftvertex);
X  apex(*flipedge, botvertex);
X  sym(*flipedge, top);
#ifdef SELF_CHECK
X  if (top.tri == m->dummytri) {
X    printf("Internal error in unflip():  Attempt to flip on boundary.\n");
X    lnextself(*flipedge);
X    return;
X  }
X  if (m->checksegments) {
X    tspivot(*flipedge, toplsubseg);
X    if (toplsubseg.ss != m->dummysub) {
X      printf("Internal error in unflip():  Attempt to flip a subsegment.\n");
X      lnextself(*flipedge);
X      return;
X    }
X  }
#endif /* SELF_CHECK */
X  apex(top, farvertex);
X
X  /* Identify the casing of the quadrilateral. */
X  lprev(top, topleft);
X  sym(topleft, toplcasing);
X  lnext(top, topright);
X  sym(topright, toprcasing);
X  lnext(*flipedge, botleft);
X  sym(botleft, botlcasing);
X  lprev(*flipedge, botright);
X  sym(botright, botrcasing);
X  /* Rotate the quadrilateral one-quarter turn clockwise. */
X  bond(topleft, toprcasing);
X  bond(botleft, toplcasing);
X  bond(botright, botlcasing);
X  bond(topright, botrcasing);
X
X  if (m->checksegments) {
X    /* Check for subsegments and rebond them to the quadrilateral. */
X    tspivot(topleft, toplsubseg);
X    tspivot(botleft, botlsubseg);
X    tspivot(botright, botrsubseg);
X    tspivot(topright, toprsubseg);
X    if (toplsubseg.ss == m->dummysub) {
X      tsdissolve(botleft);
X    } else {
X      tsbond(botleft, toplsubseg);
X    }
X    if (botlsubseg.ss == m->dummysub) {
X      tsdissolve(botright);
X    } else {
X      tsbond(botright, botlsubseg);
X    }
X    if (botrsubseg.ss == m->dummysub) {
X      tsdissolve(topright);
X    } else {
X      tsbond(topright, botrsubseg);
X    }
X    if (toprsubseg.ss == m->dummysub) {
X      tsdissolve(topleft);
X    } else {
X      tsbond(topleft, toprsubseg);
X    }
X  }
X
X  /* New vertex assignments for the rotated quadrilateral. */
X  setorg(*flipedge, botvertex);
X  setdest(*flipedge, farvertex);
X  setapex(*flipedge, leftvertex);
X  setorg(top, farvertex);
X  setdest(top, botvertex);
X  setapex(top, rightvertex);
X  if (b->verbose > 2) {
X    printf("  Edge unflip results in left ");
X    printtriangle(m, b, flipedge);
X    printf("  and right ");
X    printtriangle(m, b, &top);
X  }
}
X
/*****************************************************************************/
/*                                                                           */
/*  insertvertex()   Insert a vertex into a Delaunay triangulation,          */
/*                   performing flips as necessary to maintain the Delaunay  */
/*                   property.                                               */
/*                                                                           */
/*  The point `insertvertex' is located.  If `searchtri.tri' is not NULL,    */
/*  the search for the containing triangle begins from `searchtri'.  If      */
/*  `searchtri.tri' is NULL, a full point location procedure is called.      */
/*  If `insertvertex' is found inside a triangle, the triangle is split into */
/*  three; if `insertvertex' lies on an edge, the edge is split in two,      */
/*  thereby splitting the two adjacent triangles into four.  Edge flips are  */
/*  used to restore the Delaunay property.  If `insertvertex' lies on an     */
/*  existing vertex, no action is taken, and the value DUPLICATEVERTEX is    */
/*  returned.  On return, `searchtri' is set to a handle whose origin is the */
/*  existing vertex.                                                         */
/*                                                                           */
/*  Normally, the parameter `splitseg' is set to NULL, implying that no      */
/*  subsegment should be split.  In this case, if `insertvertex' is found to */
/*  lie on a segment, no action is taken, and the value VIOLATINGVERTEX is   */
/*  returned.  On return, `searchtri' is set to a handle whose primary edge  */
/*  is the violated subsegment.                                              */
/*                                                                           */
/*  If the calling routine wishes to split a subsegment by inserting a       */
/*  vertex in it, the parameter `splitseg' should be that subsegment.  In    */
/*  this case, `searchtri' MUST be the triangle handle reached by pivoting   */
/*  from that subsegment; no point location is done.                         */
/*                                                                           */
/*  `segmentflaws' and `triflaws' are flags that indicate whether or not     */
/*  there should be checks for the creation of encroached subsegments or bad */
/*  quality triangles.  If a newly inserted vertex encroaches upon           */
/*  subsegments, these subsegments are added to the list of subsegments to   */
/*  be split if `segmentflaws' is set.  If bad triangles are created, these  */
/*  are added to the queue if `triflaws' is set.                             */
/*                                                                           */
/*  If a duplicate vertex or violated segment does not prevent the vertex    */
/*  from being inserted, the return value will be ENCROACHINGVERTEX if the   */
/*  vertex encroaches upon a subsegment (and checking is enabled), or        */
/*  SUCCESSFULVERTEX otherwise.  In either case, `searchtri' is set to a     */
/*  handle whose origin is the newly inserted vertex.                        */
/*                                                                           */
/*  insertvertex() does not use flip() for reasons of speed; some            */
/*  information can be reused from edge flip to edge flip, like the          */
/*  locations of subsegments.                                                */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
enum insertvertexresult insertvertex(struct mesh *m, struct behavior *b,
X                                     vertex newvertex, struct otri *searchtri,
X                                     struct osub *splitseg,
X                                     int segmentflaws, int triflaws)
#else /* not ANSI_DECLARATORS */
enum insertvertexresult insertvertex(m, b, newvertex, searchtri, splitseg,
X                                     segmentflaws, triflaws)
struct mesh *m;
struct behavior *b;
vertex newvertex;
struct otri *searchtri;
struct osub *splitseg;
int segmentflaws;
int triflaws;
#endif /* not ANSI_DECLARATORS */
X
{
X  struct otri horiz;
X  struct otri top;
X  struct otri botleft, botright;
X  struct otri topleft, topright;
X  struct otri newbotleft, newbotright;
X  struct otri newtopright;
X  struct otri botlcasing, botrcasing;
X  struct otri toplcasing, toprcasing;
X  struct otri testtri;
X  struct osub botlsubseg, botrsubseg;
X  struct osub toplsubseg, toprsubseg;
X  struct osub brokensubseg;
X  struct osub checksubseg;
X  struct osub rightsubseg;
X  struct osub newsubseg;
X  struct badsubseg *encroached;
X  struct flipstacker *newflip;
X  vertex first;
X  vertex leftvertex, rightvertex, botvertex, topvertex, farvertex;
X  vertex segmentorg, segmentdest;
X  REAL attrib;
X  REAL area;
X  enum insertvertexresult success;
X  enum locateresult intersect;
X  int doflip;
X  int mirrorflag;
X  int enq;
X  int i;
X  triangle ptr;                         /* Temporary variable used by sym(). */
X  subseg sptr;         /* Temporary variable used by spivot() and tspivot(). */
X
X  if (b->verbose > 1) {
X    printf("  Inserting (%.12g, %.12g).\n", newvertex[0], newvertex[1]);
X  }
X
X  if (splitseg == (struct osub *) NULL) {
X    /* Find the location of the vertex to be inserted.  Check if a good */
X    /*   starting triangle has already been provided by the caller.     */
X    if (searchtri->tri == m->dummytri) {
X      /* Find a boundary triangle. */
X      horiz.tri = m->dummytri;
X      horiz.orient = 0;
X      symself(horiz);
X      /* Search for a triangle containing `newvertex'. */
X      intersect = locate(m, b, newvertex, &horiz);
X    } else {
X      /* Start searching from the triangle provided by the caller. */
X      otricopy(*searchtri, horiz);
X      intersect = preciselocate(m, b, newvertex, &horiz, 1);
X    }
X  } else {
X    /* The calling routine provides the subsegment in which */
X    /*   the vertex is inserted.                             */
X    otricopy(*searchtri, horiz);
X    intersect = ONEDGE;
X  }
X
X  if (intersect == ONVERTEX) {
X    /* There's already a vertex there.  Return in `searchtri' a triangle */
X    /*   whose origin is the existing vertex.                            */
X    otricopy(horiz, *searchtri);
X    otricopy(horiz, m->recenttri);
X    return DUPLICATEVERTEX;
X  }
X  if ((intersect == ONEDGE) || (intersect == OUTSIDE)) {
X    /* The vertex falls on an edge or boundary. */
X    if (m->checksegments && (splitseg == (struct osub *) NULL)) {
X      /* Check whether the vertex falls on a subsegment. */
X      tspivot(horiz, brokensubseg);
X      if (brokensubseg.ss != m->dummysub) {
X        /* The vertex falls on a subsegment, and hence will not be inserted. */
X        if (segmentflaws) {
X          enq = b->nobisect != 2;
X          if (enq && (b->nobisect == 1)) {
X            /* This subsegment may be split only if it is an */
X            /*   internal boundary.                          */
X            sym(horiz, testtri);
X            enq = testtri.tri != m->dummytri;
X          }
X          if (enq) {
X            /* Add the subsegment to the list of encroached subsegments. */
X            encroached = (struct badsubseg *) poolalloc(&m->badsubsegs);
X            encroached->encsubseg = sencode(brokensubseg);
X            sorg(brokensubseg, encroached->subsegorg);
X            sdest(brokensubseg, encroached->subsegdest);
X            if (b->verbose > 2) {
X              printf(
X          "  Queueing encroached subsegment (%.12g, %.12g) (%.12g, %.12g).\n",
X                     encroached->subsegorg[0], encroached->subsegorg[1],
X                     encroached->subsegdest[0], encroached->subsegdest[1]);
X            }
X          }
X        }
X        /* Return a handle whose primary edge contains the vertex, */
X        /*   which has not been inserted.                          */
X        otricopy(horiz, *searchtri);
X        otricopy(horiz, m->recenttri);
X        return VIOLATINGVERTEX;
X      }
X    }
X
X    /* Insert the vertex on an edge, dividing one triangle into two (if */
X    /*   the edge lies on a boundary) or two triangles into four.       */
X    lprev(horiz, botright);
X    sym(botright, botrcasing);
X    sym(horiz, topright);
X    /* Is there a second triangle?  (Or does this edge lie on a boundary?) */
X    mirrorflag = topright.tri != m->dummytri;
X    if (mirrorflag) {
X      lnextself(topright);
X      sym(topright, toprcasing);
X      maketriangle(m, b, &newtopright);
X    } else {
X      /* Splitting a boundary edge increases the number of boundary edges. */
X      m->hullsize++;
X    }
X    maketriangle(m, b, &newbotright);
X
X    /* Set the vertices of changed and new triangles. */
X    org(horiz, rightvertex);
X    dest(horiz, leftvertex);
X    apex(horiz, botvertex);
X    setorg(newbotright, botvertex);
X    setdest(newbotright, rightvertex);
X    setapex(newbotright, newvertex);
X    setorg(horiz, newvertex);
X    for (i = 0; i < m->eextras; i++) {
X      /* Set the element attributes of a new triangle. */
X      setelemattribute(newbotright, i, elemattribute(botright, i));
X    }
X    if (b->vararea) {
X      /* Set the area constraint of a new triangle. */
X      setareabound(newbotright, areabound(botright));
X    }
X    if (mirrorflag) {
X      dest(topright, topvertex);
X      setorg(newtopright, rightvertex);
X      setdest(newtopright, topvertex);
X      setapex(newtopright, newvertex);
X      setorg(topright, newvertex);
X      for (i = 0; i < m->eextras; i++) {
X        /* Set the element attributes of another new triangle. */
X        setelemattribute(newtopright, i, elemattribute(topright, i));
X      }
X      if (b->vararea) {
X        /* Set the area constraint of another new triangle. */
X        setareabound(newtopright, areabound(topright));
X      }
X    }
X
X    /* There may be subsegments that need to be bonded */
X    /*   to the new triangle(s).                       */
X    if (m->checksegments) {
X      tspivot(botright, botrsubseg);
X      if (botrsubseg.ss != m->dummysub) {
X        tsdissolve(botright);
X        tsbond(newbotright, botrsubseg);
X      }
X      if (mirrorflag) {
X        tspivot(topright, toprsubseg);
X        if (toprsubseg.ss != m->dummysub) {
X          tsdissolve(topright);
X          tsbond(newtopright, toprsubseg);
X        }
X      }
X    }
X
X    /* Bond the new triangle(s) to the surrounding triangles. */
X    bond(newbotright, botrcasing);
X    lprevself(newbotright);
X    bond(newbotright, botright);
X    lprevself(newbotright);
X    if (mirrorflag) {
X      bond(newtopright, toprcasing);
X      lnextself(newtopright);
X      bond(newtopright, topright);
X      lnextself(newtopright);
X      bond(newtopright, newbotright);
X    }
X
X    if (splitseg != (struct osub *) NULL) {
X      /* Split the subsegment into two. */
X      setsdest(*splitseg, newvertex);
X      segorg(*splitseg, segmentorg);
X      segdest(*splitseg, segmentdest);
X      ssymself(*splitseg);
X      spivot(*splitseg, rightsubseg);
X      insertsubseg(m, b, &newbotright, mark(*splitseg));
X      tspivot(newbotright, newsubseg);
X      setsegorg(newsubseg, segmentorg);
X      setsegdest(newsubseg, segmentdest);
X      sbond(*splitseg, newsubseg);
X      ssymself(newsubseg);
X      sbond(newsubseg, rightsubseg);
X      ssymself(*splitseg);
X      /* Transfer the subsegment's boundary marker to the vertex */
X      /*   if required.                                          */
X      if (vertexmark(newvertex) == 0) {
X        setvertexmark(newvertex, mark(*splitseg));
X      }
X    }
X
X    if (m->checkquality) {
X      poolrestart(&m->flipstackers);
X      m->lastflip = (struct flipstacker *) poolalloc(&m->flipstackers);
X      m->lastflip->flippedtri = encode(horiz);
X      m->lastflip->prevflip = (struct flipstacker *) &insertvertex;
X    }
X
#ifdef SELF_CHECK
X    if (counterclockwise(m, b, rightvertex, leftvertex, botvertex) < 0.0) {
X      printf("Internal error in insertvertex():\n");
X      printf(
X            "  Clockwise triangle prior to edge vertex insertion (bottom).\n");
X    }
X    if (mirrorflag) {
X      if (counterclockwise(m, b, leftvertex, rightvertex, topvertex) < 0.0) {
X        printf("Internal error in insertvertex():\n");
X        printf("  Clockwise triangle prior to edge vertex insertion (top).\n");
X      }
X      if (counterclockwise(m, b, rightvertex, topvertex, newvertex) < 0.0) {
X        printf("Internal error in insertvertex():\n");
X        printf(
X            "  Clockwise triangle after edge vertex insertion (top right).\n");
X      }
X      if (counterclockwise(m, b, topvertex, leftvertex, newvertex) < 0.0) {
X        printf("Internal error in insertvertex():\n");
X        printf(
X            "  Clockwise triangle after edge vertex insertion (top left).\n");
X      }
X    }
X    if (counterclockwise(m, b, leftvertex, botvertex, newvertex) < 0.0) {
X      printf("Internal error in insertvertex():\n");
X      printf(
X          "  Clockwise triangle after edge vertex insertion (bottom left).\n");
X    }
X    if (counterclockwise(m, b, botvertex, rightvertex, newvertex) < 0.0) {
X      printf("Internal error in insertvertex():\n");
X      printf(
X        "  Clockwise triangle after edge vertex insertion (bottom right).\n");
X    }
#endif /* SELF_CHECK */
X    if (b->verbose > 2) {
X      printf("  Updating bottom left ");
X      printtriangle(m, b, &botright);
X      if (mirrorflag) {
X        printf("  Updating top left ");
X        printtriangle(m, b, &topright);
X        printf("  Creating top right ");
X        printtriangle(m, b, &newtopright);
X      }
X      printf("  Creating bottom right ");
X      printtriangle(m, b, &newbotright);
X    }
X
X    /* Position `horiz' on the first edge to check for */
X    /*   the Delaunay property.                        */
X    lnextself(horiz);
X  } else {
X    /* Insert the vertex in a triangle, splitting it into three. */
X    lnext(horiz, botleft);
X    lprev(horiz, botright);
X    sym(botleft, botlcasing);
X    sym(botright, botrcasing);
X    maketriangle(m, b, &newbotleft);
X    maketriangle(m, b, &newbotright);
X
X    /* Set the vertices of changed and new triangles. */
X    org(horiz, rightvertex);
X    dest(horiz, leftvertex);
X    apex(horiz, botvertex);
X    setorg(newbotleft, leftvertex);
X    setdest(newbotleft, botvertex);
X    setapex(newbotleft, newvertex);
X    setorg(newbotright, botvertex);
X    setdest(newbotright, rightvertex);
X    setapex(newbotright, newvertex);
X    setapex(horiz, newvertex);
X    for (i = 0; i < m->eextras; i++) {
X      /* Set the element attributes of the new triangles. */
X      attrib = elemattribute(horiz, i);
X      setelemattribute(newbotleft, i, attrib);
X      setelemattribute(newbotright, i, attrib);
X    }
X    if (b->vararea) {
X      /* Set the area constraint of the new triangles. */
X      area = areabound(horiz);
X      setareabound(newbotleft, area);
X      setareabound(newbotright, area);
X    }
X
X    /* There may be subsegments that need to be bonded */
X    /*   to the new triangles.                         */
X    if (m->checksegments) {
X      tspivot(botleft, botlsubseg);
X      if (botlsubseg.ss != m->dummysub) {
X        tsdissolve(botleft);
X        tsbond(newbotleft, botlsubseg);
X      }
X      tspivot(botright, botrsubseg);
X      if (botrsubseg.ss != m->dummysub) {
X        tsdissolve(botright);
X        tsbond(newbotright, botrsubseg);
X      }
X    }
X
X    /* Bond the new triangles to the surrounding triangles. */
X    bond(newbotleft, botlcasing);
X    bond(newbotright, botrcasing);
X    lnextself(newbotleft);
X    lprevself(newbotright);
X    bond(newbotleft, newbotright);
X    lnextself(newbotleft);
X    bond(botleft, newbotleft);
X    lprevself(newbotright);
X    bond(botright, newbotright);
X
X    if (m->checkquality) {
X      poolrestart(&m->flipstackers);
X      m->lastflip = (struct flipstacker *) poolalloc(&m->flipstackers);
X      m->lastflip->flippedtri = encode(horiz);
X      m->lastflip->prevflip = (struct flipstacker *) NULL;
X    }
X
#ifdef SELF_CHECK
X    if (counterclockwise(m, b, rightvertex, leftvertex, botvertex) < 0.0) {
X      printf("Internal error in insertvertex():\n");
X      printf("  Clockwise triangle prior to vertex insertion.\n");
X    }
X    if (counterclockwise(m, b, rightvertex, leftvertex, newvertex) < 0.0) {
X      printf("Internal error in insertvertex():\n");
X      printf("  Clockwise triangle after vertex insertion (top).\n");
X    }
X    if (counterclockwise(m, b, leftvertex, botvertex, newvertex) < 0.0) {
X      printf("Internal error in insertvertex():\n");
X      printf("  Clockwise triangle after vertex insertion (left).\n");
X    }
X    if (counterclockwise(m, b, botvertex, rightvertex, newvertex) < 0.0) {
X      printf("Internal error in insertvertex():\n");
X      printf("  Clockwise triangle after vertex insertion (right).\n");
X    }
#endif /* SELF_CHECK */
X    if (b->verbose > 2) {
X      printf("  Updating top ");
X      printtriangle(m, b, &horiz);
X      printf("  Creating left ");
X      printtriangle(m, b, &newbotleft);
X      printf("  Creating right ");
X      printtriangle(m, b, &newbotright);
X    }
X  }
X
X  /* The insertion is successful by default, unless an encroached */
X  /*   subsegment is found.                                       */
X  success = SUCCESSFULVERTEX;
X  /* Circle around the newly inserted vertex, checking each edge opposite */
X  /*   it for the Delaunay property.  Non-Delaunay edges are flipped.     */
X  /*   `horiz' is always the edge being checked.  `first' marks where to  */
X  /*   stop circling.                                                     */
X  org(horiz, first);
X  rightvertex = first;
X  dest(horiz, leftvertex);
X  /* Circle until finished. */
X  while (1) {
X    /* By default, the edge will be flipped. */
X    doflip = 1;
X
X    if (m->checksegments) {
X      /* Check for a subsegment, which cannot be flipped. */
X      tspivot(horiz, checksubseg);
X      if (checksubseg.ss != m->dummysub) {
X        /* The edge is a subsegment and cannot be flipped. */
X        doflip = 0;
#ifndef CDT_ONLY
X        if (segmentflaws) {
X          /* Does the new vertex encroach upon this subsegment? */
X          if (checkseg4encroach(m, b, &checksubseg)) {
X            success = ENCROACHINGVERTEX;
X          }
X        }
#endif /* not CDT_ONLY */
X      }
X    }
X
X    if (doflip) {
X      /* Check if the edge is a boundary edge. */
X      sym(horiz, top);
X      if (top.tri == m->dummytri) {
X        /* The edge is a boundary edge and cannot be flipped. */
X        doflip = 0;
X      } else {
X        /* Find the vertex on the other side of the edge. */
X        apex(top, farvertex);
X        /* In the incremental Delaunay triangulation algorithm, any of      */
X        /*   `leftvertex', `rightvertex', and `farvertex' could be vertices */
X        /*   of the triangular bounding box.  These vertices must be        */
X        /*   treated as if they are infinitely distant, even though their   */
X        /*   "coordinates" are not.                                         */
X        if ((leftvertex == m->infvertex1) || (leftvertex == m->infvertex2) ||
X            (leftvertex == m->infvertex3)) {
X          /* `leftvertex' is infinitely distant.  Check the convexity of  */
X          /*   the boundary of the triangulation.  'farvertex' might be   */
X          /*   infinite as well, but trust me, this same condition should */
X          /*   be applied.                                                */
X          doflip = counterclockwise(m, b, newvertex, rightvertex, farvertex)
X                   > 0.0;
X        } else if ((rightvertex == m->infvertex1) ||
X                   (rightvertex == m->infvertex2) ||
X                   (rightvertex == m->infvertex3)) {
X          /* `rightvertex' is infinitely distant.  Check the convexity of */
X          /*   the boundary of the triangulation.  'farvertex' might be   */
X          /*   infinite as well, but trust me, this same condition should */
X          /*   be applied.                                                */
X          doflip = counterclockwise(m, b, farvertex, leftvertex, newvertex)
X                   > 0.0;
X        } else if ((farvertex == m->infvertex1) ||
X                   (farvertex == m->infvertex2) ||
X                   (farvertex == m->infvertex3)) {
X          /* `farvertex' is infinitely distant and cannot be inside */
X          /*   the circumcircle of the triangle `horiz'.            */
X          doflip = 0;
X        } else {
X          /* Test whether the edge is locally Delaunay. */
X          doflip = incircle(m, b, leftvertex, newvertex, rightvertex,
X                            farvertex) > 0.0;
X        }
X        if (doflip) {
X          /* We made it!  Flip the edge `horiz' by rotating its containing */
X          /*   quadrilateral (the two triangles adjacent to `horiz').      */
X          /* Identify the casing of the quadrilateral. */
X          lprev(top, topleft);
X          sym(topleft, toplcasing);
X          lnext(top, topright);
X          sym(topright, toprcasing);
X          lnext(horiz, botleft);
X          sym(botleft, botlcasing);
X          lprev(horiz, botright);
X          sym(botright, botrcasing);
X          /* Rotate the quadrilateral one-quarter turn counterclockwise. */
X          bond(topleft, botlcasing);
X          bond(botleft, botrcasing);
X          bond(botright, toprcasing);
X          bond(topright, toplcasing);
X          if (m->checksegments) {
X            /* Check for subsegments and rebond them to the quadrilateral. */
X            tspivot(topleft, toplsubseg);
X            tspivot(botleft, botlsubseg);
X            tspivot(botright, botrsubseg);
X            tspivot(topright, toprsubseg);
X            if (toplsubseg.ss == m->dummysub) {
X              tsdissolve(topright);
X            } else {
X              tsbond(topright, toplsubseg);
X            }
X            if (botlsubseg.ss == m->dummysub) {
X              tsdissolve(topleft);
X            } else {
X              tsbond(topleft, botlsubseg);
X            }
X            if (botrsubseg.ss == m->dummysub) {
X              tsdissolve(botleft);
X            } else {
X              tsbond(botleft, botrsubseg);
X            }
X            if (toprsubseg.ss == m->dummysub) {
X              tsdissolve(botright);
X            } else {
X              tsbond(botright, toprsubseg);
X            }
X          }
X          /* New vertex assignments for the rotated quadrilateral. */
X          setorg(horiz, farvertex);
X          setdest(horiz, newvertex);
X          setapex(horiz, rightvertex);
X          setorg(top, newvertex);
X          setdest(top, farvertex);
X          setapex(top, leftvertex);
X          for (i = 0; i < m->eextras; i++) {
X            /* Take the average of the two triangles' attributes. */
X            attrib = 0.5 * (elemattribute(top, i) + elemattribute(horiz, i));
X            setelemattribute(top, i, attrib);
X            setelemattribute(horiz, i, attrib);
X          }
X          if (b->vararea) {
X            if ((areabound(top) <= 0.0) || (areabound(horiz) <= 0.0)) {
X              area = -1.0;
X            } else {
X              /* Take the average of the two triangles' area constraints.    */
X              /*   This prevents small area constraints from migrating a     */
X              /*   long, long way from their original location due to flips. */
X              area = 0.5 * (areabound(top) + areabound(horiz));
X            }
X            setareabound(top, area);
X            setareabound(horiz, area);
X          }
X
X          if (m->checkquality) {
X            newflip = (struct flipstacker *) poolalloc(&m->flipstackers);
X            newflip->flippedtri = encode(horiz);
X            newflip->prevflip = m->lastflip;
X            m->lastflip = newflip;
X          }
X
#ifdef SELF_CHECK
X          if (newvertex != (vertex) NULL) {
X            if (counterclockwise(m, b, leftvertex, newvertex, rightvertex) <
X                0.0) {
X              printf("Internal error in insertvertex():\n");
X              printf("  Clockwise triangle prior to edge flip (bottom).\n");
X            }
X            /* The following test has been removed because constrainededge() */
X            /*   sometimes generates inverted triangles that insertvertex()  */
X            /*   removes.                                                    */
/*
X            if (counterclockwise(m, b, rightvertex, farvertex, leftvertex) <
X                0.0) {
X              printf("Internal error in insertvertex():\n");
X              printf("  Clockwise triangle prior to edge flip (top).\n");
X            }
*/
X            if (counterclockwise(m, b, farvertex, leftvertex, newvertex) <
X                0.0) {
X              printf("Internal error in insertvertex():\n");
X              printf("  Clockwise triangle after edge flip (left).\n");
X            }
X            if (counterclockwise(m, b, newvertex, rightvertex, farvertex) <
X                0.0) {
X              printf("Internal error in insertvertex():\n");
X              printf("  Clockwise triangle after edge flip (right).\n");
X            }
X          }
#endif /* SELF_CHECK */
X          if (b->verbose > 2) {
X            printf("  Edge flip results in left ");
X            lnextself(topleft);
X            printtriangle(m, b, &topleft);
X            printf("  and right ");
X            printtriangle(m, b, &horiz);
X          }
X          /* On the next iterations, consider the two edges that were  */
X          /*   exposed (this is, are now visible to the newly inserted */
X          /*   vertex) by the edge flip.                               */
X          lprevself(horiz);
X          leftvertex = farvertex;
X        }
X      }
X    }
X    if (!doflip) {
X      /* The handle `horiz' is accepted as locally Delaunay. */
#ifndef CDT_ONLY
X      if (triflaws) {
X        /* Check the triangle `horiz' for quality. */
X        testtriangle(m, b, &horiz);
X      }
#endif /* not CDT_ONLY */
X      /* Look for the next edge around the newly inserted vertex. */
X      lnextself(horiz);
X      sym(horiz, testtri);
X      /* Check for finishing a complete revolution about the new vertex, or */
X      /*   falling outside  of the triangulation.  The latter will happen   */
X      /*   when a vertex is inserted at a boundary.                         */
X      if ((leftvertex == first) || (testtri.tri == m->dummytri)) {
X        /* We're done.  Return a triangle whose origin is the new vertex. */
X        lnext(horiz, *searchtri);
X        lnext(horiz, m->recenttri);
X        return success;
X      }
X      /* Finish finding the next edge around the newly inserted vertex. */
X      lnext(testtri, horiz);
X      rightvertex = leftvertex;
X      dest(horiz, leftvertex);
X    }
X  }
}
X
/*****************************************************************************/
/*                                                                           */
/*  triangulatepolygon()   Find the Delaunay triangulation of a polygon that */
/*                         has a certain "nice" shape.  This includes the    */
/*                         polygons that result from deletion of a vertex or */
/*                         insertion of a segment.                           */
/*                                                                           */
/*  This is a conceptually difficult routine.  The starting assumption is    */
/*  that we have a polygon with n sides.  n - 1 of these sides are currently */
/*  represented as edges in the mesh.  One side, called the "base", need not */
/*  be.                                                                      */
/*                                                                           */
/*  Inside the polygon is a structure I call a "fan", consisting of n - 1    */
/*  triangles that share a common origin.  For each of these triangles, the  */
/*  edge opposite the origin is one of the sides of the polygon.  The        */
/*  primary edge of each triangle is the edge directed from the origin to    */
/*  the destination; note that this is not the same edge that is a side of   */
/*  the polygon.  `firstedge' is the primary edge of the first triangle.     */
/*  From there, the triangles follow in counterclockwise order about the     */
/*  polygon, until `lastedge', the primary edge of the last triangle.        */
/*  `firstedge' and `lastedge' are probably connected to other triangles     */
/*  beyond the extremes of the fan, but their identity is not important, as  */
/*  long as the fan remains connected to them.                               */
/*                                                                           */
/*  Imagine the polygon oriented so that its base is at the bottom.  This    */
/*  puts `firstedge' on the far right, and `lastedge' on the far left.       */
/*  The right vertex of the base is the destination of `firstedge', and the  */
/*  left vertex of the base is the apex of `lastedge'.                       */
/*                                                                           */
/*  The challenge now is to find the right sequence of edge flips to         */
/*  transform the fan into a Delaunay triangulation of the polygon.  Each    */
/*  edge flip effectively removes one triangle from the fan, committing it   */
/*  to the polygon.  The resulting polygon has one fewer edge.  If `doflip'  */
/*  is set, the final flip will be performed, resulting in a fan of one      */
/*  (useless?) triangle.  If `doflip' is not set, the final flip is not      */
/*  performed, resulting in a fan of two triangles, and an unfinished        */
/*  triangular polygon that is not yet filled out with a single triangle.    */
/*  On completion of the routine, `lastedge' is the last remaining triangle, */
/*  or the leftmost of the last two.                                         */
/*                                                                           */
/*  Although the flips are performed in the order described above, the       */
/*  decisions about what flips to perform are made in precisely the reverse  */
/*  order.  The recursive triangulatepolygon() procedure makes a decision,   */
/*  uses up to two recursive calls to triangulate the "subproblems"          */
/*  (polygons with fewer edges), and then performs an edge flip.             */
/*                                                                           */
/*  The "decision" it makes is which vertex of the polygon should be         */
/*  connected to the base.  This decision is made by testing every possible  */
/*  vertex.  Once the best vertex is found, the two edges that connect this  */
/*  vertex to the base become the bases for two smaller polygons.  These     */
/*  are triangulated recursively.  Unfortunately, this approach can take     */
/*  O(n^2) time not only in the worst case, but in many common cases.  It's  */
/*  rarely a big deal for vertex deletion, where n is rarely larger than     */
/*  ten, but it could be a big deal for segment insertion, especially if     */
/*  there's a lot of long segments that each cut many triangles.  I ought to */
/*  code a faster algorithm some day.                                        */
/*                                                                           */
/*  The `edgecount' parameter is the number of sides of the polygon,         */
/*  including its base.  `triflaws' is a flag that determines whether the    */
/*  new triangles should be tested for quality, and enqueued if they are     */
/*  bad.                                                                     */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
void triangulatepolygon(struct mesh *m, struct behavior *b,
X                        struct otri *firstedge, struct otri *lastedge,
X                        int edgecount, int doflip, int triflaws)
#else /* not ANSI_DECLARATORS */
void triangulatepolygon(m, b, firstedge, lastedge, edgecount, doflip, triflaws)
struct mesh *m;
struct behavior *b;
struct otri *firstedge;
struct otri *lastedge;
int edgecount;
int doflip;
int triflaws;
#endif /* not ANSI_DECLARATORS */
X
{
X  struct otri testtri;
X  struct otri besttri;
X  struct otri tempedge;
X  vertex leftbasevertex, rightbasevertex;
X  vertex testvertex;
X  vertex bestvertex;
X  int bestnumber;
X  int i;
X  triangle ptr;   /* Temporary variable used by sym(), onext(), and oprev(). */
X
X  /* Identify the base vertices. */
X  apex(*lastedge, leftbasevertex);
X  dest(*firstedge, rightbasevertex);
X  if (b->verbose > 2) {
X    printf("  Triangulating interior polygon at edge\n");
X    printf("    (%.12g, %.12g) (%.12g, %.12g)\n", leftbasevertex[0],
X           leftbasevertex[1], rightbasevertex[0], rightbasevertex[1]);
X  }
X  /* Find the best vertex to connect the base to. */
X  onext(*firstedge, besttri);
X  dest(besttri, bestvertex);
X  otricopy(besttri, testtri);
X  bestnumber = 1;
X  for (i = 2; i <= edgecount - 2; i++) {
X    onextself(testtri);
X    dest(testtri, testvertex);
X    /* Is this a better vertex? */
X    if (incircle(m, b, leftbasevertex, rightbasevertex, bestvertex,
X                 testvertex) > 0.0) {
X      otricopy(testtri, besttri);
X      bestvertex = testvertex;
X      bestnumber = i;
X    }
X  }
X  if (b->verbose > 2) {
X    printf("    Connecting edge to (%.12g, %.12g)\n", bestvertex[0],
X           bestvertex[1]);
X  }
X  if (bestnumber > 1) {
X    /* Recursively triangulate the smaller polygon on the right. */
X    oprev(besttri, tempedge);
X    triangulatepolygon(m, b, firstedge, &tempedge, bestnumber + 1, 1,
X                       triflaws);
X  }
X  if (bestnumber < edgecount - 2) {
X    /* Recursively triangulate the smaller polygon on the left. */
X    sym(besttri, tempedge);
X    triangulatepolygon(m, b, &besttri, lastedge, edgecount - bestnumber, 1,
X                       triflaws);
X    /* Find `besttri' again; it may have been lost to edge flips. */
X    sym(tempedge, besttri);
X  }
X  if (doflip) {
X    /* Do one final edge flip. */
X    flip(m, b, &besttri);
#ifndef CDT_ONLY
X    if (triflaws) {
X      /* Check the quality of the newly committed triangle. */
X      sym(besttri, testtri);
X      testtriangle(m, b, &testtri);
X    }
#endif /* not CDT_ONLY */
X  }
X  /* Return the base triangle. */
X  otricopy(besttri, *lastedge);
}
X
/*****************************************************************************/
/*                                                                           */
/*  deletevertex()   Delete a vertex from a Delaunay triangulation, ensuring */
/*                   that the triangulation remains Delaunay.                */
/*                                                                           */
/*  The origin of `deltri' is deleted.  The union of the triangles adjacent  */
/*  to this vertex is a polygon, for which the Delaunay triangulation is     */
/*  found.  Two triangles are removed from the mesh.                         */
/*                                                                           */
/*  Only interior vertices that do not lie on segments or boundaries may be  */
/*  deleted.                                                                 */
/*                                                                           */
/*****************************************************************************/
X
#ifndef CDT_ONLY
X
#ifdef ANSI_DECLARATORS
void deletevertex(struct mesh *m, struct behavior *b, struct otri *deltri)
#else /* not ANSI_DECLARATORS */
void deletevertex(m, b, deltri)
struct mesh *m;
struct behavior *b;
struct otri *deltri;
#endif /* not ANSI_DECLARATORS */
X
{
X  struct otri countingtri;
X  struct otri firstedge, lastedge;
X  struct otri deltriright;
X  struct otri lefttri, righttri;
X  struct otri leftcasing, rightcasing;
X  struct osub leftsubseg, rightsubseg;
X  vertex delvertex;
X  vertex neworg;
X  int edgecount;
X  triangle ptr;   /* Temporary variable used by sym(), onext(), and oprev(). */
X  subseg sptr;                      /* Temporary variable used by tspivot(). */
X
X  org(*deltri, delvertex);
X  if (b->verbose > 1) {
X    printf("  Deleting (%.12g, %.12g).\n", delvertex[0], delvertex[1]);
X  }
X  vertexdealloc(m, delvertex);
X
X  /* Count the degree of the vertex being deleted. */
X  onext(*deltri, countingtri);
X  edgecount = 1;
X  while (!otriequal(*deltri, countingtri)) {
#ifdef SELF_CHECK
X    if (countingtri.tri == m->dummytri) {
X      printf("Internal error in deletevertex():\n");
X      printf("  Attempt to delete boundary vertex.\n");
X      internalerror();
X    }
#endif /* SELF_CHECK */
X    edgecount++;
X    onextself(countingtri);
X  }
X
#ifdef SELF_CHECK
X  if (edgecount < 3) {
X    printf("Internal error in deletevertex():\n  Vertex has degree %d.\n",
X           edgecount);
X    internalerror();
X  }
#endif /* SELF_CHECK */
X  if (edgecount > 3) {
X    /* Triangulate the polygon defined by the union of all triangles */
X    /*   adjacent to the vertex being deleted.  Check the quality of */
X    /*   the resulting triangles.                                    */
X    onext(*deltri, firstedge);
X    oprev(*deltri, lastedge);
X    triangulatepolygon(m, b, &firstedge, &lastedge, edgecount, 0,
X                       !b->nobisect);
X  }
X  /* Splice out two triangles. */
X  lprev(*deltri, deltriright);
X  dnext(*deltri, lefttri);
X  sym(lefttri, leftcasing);
X  oprev(deltriright, righttri);
X  sym(righttri, rightcasing);
X  bond(*deltri, leftcasing);
X  bond(deltriright, rightcasing);
X  tspivot(lefttri, leftsubseg);
X  if (leftsubseg.ss != m->dummysub) {
X    tsbond(*deltri, leftsubseg);
X  }
X  tspivot(righttri, rightsubseg);
X  if (rightsubseg.ss != m->dummysub) {
X    tsbond(deltriright, rightsubseg);
X  }
X
X  /* Set the new origin of `deltri' and check its quality. */
X  org(lefttri, neworg);
X  setorg(*deltri, neworg);
X  if (!b->nobisect) {
X    testtriangle(m, b, deltri);
X  }
X
X  /* Delete the two spliced-out triangles. */
X  triangledealloc(m, lefttri.tri);
X  triangledealloc(m, righttri.tri);
}
X
#endif /* not CDT_ONLY */
X
/*****************************************************************************/
/*                                                                           */
/*  undovertex()   Undo the most recent vertex insertion.                    */
/*                                                                           */
/*  Walks through the list of transformations (flips and a vertex insertion) */
/*  in the reverse of the order in which they were done, and undoes them.    */
/*  The inserted vertex is removed from the triangulation and deallocated.   */
/*  Two triangles (possibly just one) are also deallocated.                  */
/*                                                                           */
/*****************************************************************************/
X
#ifndef CDT_ONLY
X
#ifdef ANSI_DECLARATORS
void undovertex(struct mesh *m, struct behavior *b)
#else /* not ANSI_DECLARATORS */
void undovertex(m, b)
struct mesh *m;
struct behavior *b;
#endif /* not ANSI_DECLARATORS */
X
{
X  struct otri fliptri;
X  struct otri botleft, botright, topright;
X  struct otri botlcasing, botrcasing, toprcasing;
X  struct otri gluetri;
X  struct osub botlsubseg, botrsubseg, toprsubseg;
X  vertex botvertex, rightvertex;
X  triangle ptr;                         /* Temporary variable used by sym(). */
X  subseg sptr;                      /* Temporary variable used by tspivot(). */
X
X  /* Walk through the list of transformations (flips and a vertex insertion) */
X  /*   in the reverse of the order in which they were done, and undo them.   */
X  while (m->lastflip != (struct flipstacker *) NULL) {
X    /* Find a triangle involved in the last unreversed transformation. */
X    decode(m->lastflip->flippedtri, fliptri);
X
X    /* We are reversing one of three transformations:  a trisection of one */
X    /*   triangle into three (by inserting a vertex in the triangle), a    */
X    /*   bisection of two triangles into four (by inserting a vertex in an */
X    /*   edge), or an edge flip.                                           */
X    if (m->lastflip->prevflip == (struct flipstacker *) NULL) {
X      /* Restore a triangle that was split into three triangles, */
X      /*   so it is again one triangle.                          */
X      dprev(fliptri, botleft);
X      lnextself(botleft);
X      onext(fliptri, botright);
X      lprevself(botright);
X      sym(botleft, botlcasing);
X      sym(botright, botrcasing);
X      dest(botleft, botvertex);
X
X      setapex(fliptri, botvertex);
X      lnextself(fliptri);
X      bond(fliptri, botlcasing);
X      tspivot(botleft, botlsubseg);
X      tsbond(fliptri, botlsubseg);
X      lnextself(fliptri);
X      bond(fliptri, botrcasing);
X      tspivot(botright, botrsubseg);
X      tsbond(fliptri, botrsubseg);
X
X      /* Delete the two spliced-out triangles. */
X      triangledealloc(m, botleft.tri);
X      triangledealloc(m, botright.tri);
X    } else if (m->lastflip->prevflip == (struct flipstacker *) &insertvertex) {
X      /* Restore two triangles that were split into four triangles, */
X      /*   so they are again two triangles.                         */
X      lprev(fliptri, gluetri);
X      sym(gluetri, botright);
X      lnextself(botright);
X      sym(botright, botrcasing);
X      dest(botright, rightvertex);
X
X      setorg(fliptri, rightvertex);
X      bond(gluetri, botrcasing);
X      tspivot(botright, botrsubseg);
X      tsbond(gluetri, botrsubseg);
X
X      /* Delete the spliced-out triangle. */
X      triangledealloc(m, botright.tri);
X
X      sym(fliptri, gluetri);
X      if (gluetri.tri != m->dummytri) {
X        lnextself(gluetri);
X        dnext(gluetri, topright);
X        sym(topright, toprcasing);
X
X        setorg(gluetri, rightvertex);
X        bond(gluetri, toprcasing);
X        tspivot(topright, toprsubseg);
X        tsbond(gluetri, toprsubseg);
X
X        /* Delete the spliced-out triangle. */
X        triangledealloc(m, topright.tri);
X      }
X
X      /* This is the end of the list, sneakily encoded. */
X      m->lastflip->prevflip = (struct flipstacker *) NULL;
X    } else {
X      /* Undo an edge flip. */
X      unflip(m, b, &fliptri);
X    }
X
X    /* Go on and process the next transformation. */
X    m->lastflip = m->lastflip->prevflip;
X  }
}
X
#endif /* not CDT_ONLY */
X
/**                                                                         **/
/**                                                                         **/
/********* Mesh transformation routines end here                     *********/
X
/********* Divide-and-conquer Delaunay triangulation begins here     *********/
/**                                                                         **/
/**                                                                         **/
X
/*****************************************************************************/
/*                                                                           */
/*  The divide-and-conquer bounding box                                      */
/*                                                                           */
/*  I originally implemented the divide-and-conquer and incremental Delaunay */
/*  triangulations using the edge-based data structure presented by Guibas   */
/*  and Stolfi.  Switching to a triangle-based data structure doubled the    */
/*  speed.  However, I had to think of a few extra tricks to maintain the    */
/*  elegance of the original algorithms.                                     */
/*                                                                           */
/*  The "bounding box" used by my variant of the divide-and-conquer          */
/*  algorithm uses one triangle for each edge of the convex hull of the      */
/*  triangulation.  These bounding triangles all share a common apical       */
/*  vertex, which is represented by NULL and which represents nothing.       */
/*  The bounding triangles are linked in a circular fan about this NULL      */
/*  vertex, and the edges on the convex hull of the triangulation appear     */
/*  opposite the NULL vertex.  You might find it easiest to imagine that     */
/*  the NULL vertex is a point in 3D space behind the center of the          */
/*  triangulation, and that the bounding triangles form a sort of cone.      */
/*                                                                           */
/*  This bounding box makes it easy to represent degenerate cases.  For      */
/*  instance, the triangulation of two vertices is a single edge.  This edge */
/*  is represented by two bounding box triangles, one on each "side" of the  */
/*  edge.  These triangles are also linked together in a fan about the NULL  */
/*  vertex.                                                                  */
/*                                                                           */
/*  The bounding box also makes it easy to traverse the convex hull, as the  */
/*  divide-and-conquer algorithm needs to do.                                */
/*                                                                           */
/*****************************************************************************/
X
/*****************************************************************************/
/*                                                                           */
/*  vertexsort()   Sort an array of vertices by x-coordinate, using the      */
/*                 y-coordinate as a secondary key.                          */
/*                                                                           */
/*  Uses quicksort.  Randomized O(n log n) time.  No, I did not make any of  */
/*  the usual quicksort mistakes.                                            */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
void vertexsort(vertex *sortarray, int arraysize)
#else /* not ANSI_DECLARATORS */
void vertexsort(sortarray, arraysize)
vertex *sortarray;
int arraysize;
#endif /* not ANSI_DECLARATORS */
X
{
X  int left, right;
X  int pivot;
X  REAL pivotx, pivoty;
X  vertex temp;
X
X  if (arraysize == 2) {
X    /* Recursive base case. */
X    if ((sortarray[0][0] > sortarray[1][0]) ||
X        ((sortarray[0][0] == sortarray[1][0]) &&
X         (sortarray[0][1] > sortarray[1][1]))) {
X      temp = sortarray[1];
X      sortarray[1] = sortarray[0];
X      sortarray[0] = temp;
X    }
X    return;
X  }
X  /* Choose a random pivot to split the array. */
X  pivot = (int) randomnation((unsigned int) arraysize);
X  pivotx = sortarray[pivot][0];
X  pivoty = sortarray[pivot][1];
X  /* Split the array. */
X  left = -1;
X  right = arraysize;
X  while (left < right) {
X    /* Search for a vertex whose x-coordinate is too large for the left. */
X    do {
X      left++;
X    } while ((left <= right) && ((sortarray[left][0] < pivotx) ||
X                                 ((sortarray[left][0] == pivotx) &&
X                                  (sortarray[left][1] < pivoty))));
X    /* Search for a vertex whose x-coordinate is too small for the right. */
X    do {
X      right--;
X    } while ((left <= right) && ((sortarray[right][0] > pivotx) ||
X                                 ((sortarray[right][0] == pivotx) &&
X                                  (sortarray[right][1] > pivoty))));
X    if (left < right) {
X      /* Swap the left and right vertices. */
X      temp = sortarray[left];
X      sortarray[left] = sortarray[right];
X      sortarray[right] = temp;
X    }
X  }
X  if (left > 1) {
X    /* Recursively sort the left subset. */
X    vertexsort(sortarray, left);
X  }
X  if (right < arraysize - 2) {
X    /* Recursively sort the right subset. */
X    vertexsort(&sortarray[right + 1], arraysize - right - 1);
X  }
}
X
/*****************************************************************************/
/*                                                                           */
/*  vertexmedian()   An order statistic algorithm, almost.  Shuffles an      */
/*                   array of vertices so that the first `median' vertices   */
/*                   occur lexicographically before the remaining vertices.  */
/*                                                                           */
/*  Uses the x-coordinate as the primary key if axis == 0; the y-coordinate  */
/*  if axis == 1.  Very similar to the vertexsort() procedure, but runs in   */
/*  randomized linear time.                                                  */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
void vertexmedian(vertex *sortarray, int arraysize, int median, int axis)
#else /* not ANSI_DECLARATORS */
void vertexmedian(sortarray, arraysize, median, axis)
vertex *sortarray;
int arraysize;
int median;
int axis;
#endif /* not ANSI_DECLARATORS */
X
{
X  int left, right;
X  int pivot;
X  REAL pivot1, pivot2;
X  vertex temp;
X
X  if (arraysize == 2) {
X    /* Recursive base case. */
X    if ((sortarray[0][axis] > sortarray[1][axis]) ||
X        ((sortarray[0][axis] == sortarray[1][axis]) &&
X         (sortarray[0][1 - axis] > sortarray[1][1 - axis]))) {
X      temp = sortarray[1];
X      sortarray[1] = sortarray[0];
X      sortarray[0] = temp;
X    }
X    return;
X  }
X  /* Choose a random pivot to split the array. */
X  pivot = (int) randomnation((unsigned int) arraysize);
X  pivot1 = sortarray[pivot][axis];
X  pivot2 = sortarray[pivot][1 - axis];
X  /* Split the array. */
X  left = -1;
X  right = arraysize;
X  while (left < right) {
X    /* Search for a vertex whose x-coordinate is too large for the left. */
X    do {
X      left++;
X    } while ((left <= right) && ((sortarray[left][axis] < pivot1) ||
X                                 ((sortarray[left][axis] == pivot1) &&
X                                  (sortarray[left][1 - axis] < pivot2))));
X    /* Search for a vertex whose x-coordinate is too small for the right. */
X    do {
X      right--;
X    } while ((left <= right) && ((sortarray[right][axis] > pivot1) ||
X                                 ((sortarray[right][axis] == pivot1) &&
X                                  (sortarray[right][1 - axis] > pivot2))));
X    if (left < right) {
X      /* Swap the left and right vertices. */
X      temp = sortarray[left];
X      sortarray[left] = sortarray[right];
X      sortarray[right] = temp;
X    }
X  }
X  /* Unlike in vertexsort(), at most one of the following */
X  /*   conditionals is true.                             */
X  if (left > median) {
X    /* Recursively shuffle the left subset. */
X    vertexmedian(sortarray, left, median, axis);
X  }
X  if (right < median - 1) {
X    /* Recursively shuffle the right subset. */
X    vertexmedian(&sortarray[right + 1], arraysize - right - 1,
X                 median - right - 1, axis);
X  }
}
X
/*****************************************************************************/
/*                                                                           */
/*  alternateaxes()   Sorts the vertices as appropriate for the divide-and-  */
/*                    conquer algorithm with alternating cuts.               */
/*                                                                           */
/*  Partitions by x-coordinate if axis == 0; by y-coordinate if axis == 1.   */
/*  For the base case, subsets containing only two or three vertices are     */
/*  always sorted by x-coordinate.                                           */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
void alternateaxes(vertex *sortarray, int arraysize, int axis)
#else /* not ANSI_DECLARATORS */
void alternateaxes(sortarray, arraysize, axis)
vertex *sortarray;
int arraysize;
int axis;
#endif /* not ANSI_DECLARATORS */
X
{
X  int divider;
X
X  divider = arraysize >> 1;
X  if (arraysize <= 3) {
X    /* Recursive base case:  subsets of two or three vertices will be    */
X    /*   handled specially, and should always be sorted by x-coordinate. */
X    axis = 0;
X  }
X  /* Partition with a horizontal or vertical cut. */
X  vertexmedian(sortarray, arraysize, divider, axis);
X  /* Recursively partition the subsets with a cross cut. */
X  if (arraysize - divider >= 2) {
X    if (divider >= 2) {
X      alternateaxes(sortarray, divider, 1 - axis);
X    }
X    alternateaxes(&sortarray[divider], arraysize - divider, 1 - axis);
X  }
}
X
/*****************************************************************************/
/*                                                                           */
/*  mergehulls()   Merge two adjacent Delaunay triangulations into a         */
/*                 single Delaunay triangulation.                            */
/*                                                                           */
/*  This is similar to the algorithm given by Guibas and Stolfi, but uses    */
/*  a triangle-based, rather than edge-based, data structure.                */
/*                                                                           */
/*  The algorithm walks up the gap between the two triangulations, knitting  */
/*  them together.  As they are merged, some of their bounding triangles     */
/*  are converted into real triangles of the triangulation.  The procedure   */
/*  pulls each hull's bounding triangles apart, then knits them together     */
/*  like the teeth of two gears.  The Delaunay property determines, at each  */
/*  step, whether the next "tooth" is a bounding triangle of the left hull   */
/*  or the right.  When a bounding triangle becomes real, its apex is        */
/*  changed from NULL to a real vertex.                                      */
/*                                                                           */
/*  Only two new triangles need to be allocated.  These become new bounding  */
/*  triangles at the top and bottom of the seam.  They are used to connect   */
/*  the remaining bounding triangles (those that have not been converted     */
/*  into real triangles) into a single fan.                                  */
/*                                                                           */
/*  On entry, `farleft' and `innerleft' are bounding triangles of the left   */
/*  triangulation.  The origin of `farleft' is the leftmost vertex, and      */
/*  the destination of `innerleft' is the rightmost vertex of the            */
/*  triangulation.  Similarly, `innerright' and `farright' are bounding      */
/*  triangles of the right triangulation.  The origin of `innerright' and    */
/*  destination of `farright' are the leftmost and rightmost vertices.       */
/*                                                                           */
/*  On completion, the origin of `farleft' is the leftmost vertex of the     */
/*  merged triangulation, and the destination of `farright' is the rightmost */
/*  vertex.                                                                  */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
void mergehulls(struct mesh *m, struct behavior *b, struct otri *farleft,
X                struct otri *innerleft, struct otri *innerright,
X                struct otri *farright, int axis)
#else /* not ANSI_DECLARATORS */
void mergehulls(m, b, farleft, innerleft, innerright, farright, axis)
struct mesh *m;
struct behavior *b;
struct otri *farleft;
struct otri *innerleft;
struct otri *innerright;
struct otri *farright;
int axis;
#endif /* not ANSI_DECLARATORS */
X
{
X  struct otri leftcand, rightcand;
X  struct otri baseedge;
X  struct otri nextedge;
X  struct otri sidecasing, topcasing, outercasing;
X  struct otri checkedge;
X  vertex innerleftdest;
X  vertex innerrightorg;
X  vertex innerleftapex, innerrightapex;
X  vertex farleftpt, farrightpt;
X  vertex farleftapex, farrightapex;
X  vertex lowerleft, lowerright;
X  vertex upperleft, upperright;
X  vertex nextapex;
X  vertex checkvertex;
X  int changemade;
X  int badedge;
X  int leftfinished, rightfinished;
X  triangle ptr;                         /* Temporary variable used by sym(). */
X
X  dest(*innerleft, innerleftdest);
X  apex(*innerleft, innerleftapex);
X  org(*innerright, innerrightorg);
X  apex(*innerright, innerrightapex);
X  /* Special treatment for horizontal cuts. */
X  if (b->dwyer && (axis == 1)) {
X    org(*farleft, farleftpt);
X    apex(*farleft, farleftapex);
X    dest(*farright, farrightpt);
X    apex(*farright, farrightapex);
X    /* The pointers to the extremal vertices are shifted to point to the */
X    /*   topmost and bottommost vertex of each hull, rather than the     */
X    /*   leftmost and rightmost vertices.                                */
X    while (farleftapex[1] < farleftpt[1]) {
X      lnextself(*farleft);
X      symself(*farleft);
X      farleftpt = farleftapex;
X      apex(*farleft, farleftapex);
X    }
X    sym(*innerleft, checkedge);
X    apex(checkedge, checkvertex);
X    while (checkvertex[1] > innerleftdest[1]) {
X      lnext(checkedge, *innerleft);
X      innerleftapex = innerleftdest;
X      innerleftdest = checkvertex;
X      sym(*innerleft, checkedge);
X      apex(checkedge, checkvertex);
X    }
X    while (innerrightapex[1] < innerrightorg[1]) {
X      lnextself(*innerright);
X      symself(*innerright);
X      innerrightorg = innerrightapex;
X      apex(*innerright, innerrightapex);
X    }
X    sym(*farright, checkedge);
X    apex(checkedge, checkvertex);
X    while (checkvertex[1] > farrightpt[1]) {
X      lnext(checkedge, *farright);
X      farrightapex = farrightpt;
X      farrightpt = checkvertex;
X      sym(*farright, checkedge);
X      apex(checkedge, checkvertex);
X    }
X  }
X  /* Find a line tangent to and below both hulls. */
X  do {
X    changemade = 0;
X    /* Make innerleftdest the "bottommost" vertex of the left hull. */
X    if (counterclockwise(m, b, innerleftdest, innerleftapex, innerrightorg) >
X        0.0) {
X      lprevself(*innerleft);
X      symself(*innerleft);
X      innerleftdest = innerleftapex;
X      apex(*innerleft, innerleftapex);
X      changemade = 1;
X    }
X    /* Make innerrightorg the "bottommost" vertex of the right hull. */
X    if (counterclockwise(m, b, innerrightapex, innerrightorg, innerleftdest) >
X        0.0) {
X      lnextself(*innerright);
X      symself(*innerright);
X      innerrightorg = innerrightapex;
X      apex(*innerright, innerrightapex);
X      changemade = 1;
X    }
X  } while (changemade);
X  /* Find the two candidates to be the next "gear tooth." */
X  sym(*innerleft, leftcand);
X  sym(*innerright, rightcand);
X  /* Create the bottom new bounding triangle. */
X  maketriangle(m, b, &baseedge);
X  /* Connect it to the bounding boxes of the left and right triangulations. */
X  bond(baseedge, *innerleft);
X  lnextself(baseedge);
X  bond(baseedge, *innerright);
X  lnextself(baseedge);
X  setorg(baseedge, innerrightorg);
X  setdest(baseedge, innerleftdest);
X  /* Apex is intentionally left NULL. */
X  if (b->verbose > 2) {
X    printf("  Creating base bounding ");
X    printtriangle(m, b, &baseedge);
X  }
X  /* Fix the extreme triangles if necessary. */
X  org(*farleft, farleftpt);
X  if (innerleftdest == farleftpt) {
X    lnext(baseedge, *farleft);
X  }
X  dest(*farright, farrightpt);
X  if (innerrightorg == farrightpt) {
X    lprev(baseedge, *farright);
X  }
X  /* The vertices of the current knitting edge. */
X  lowerleft = innerleftdest;
X  lowerright = innerrightorg;
X  /* The candidate vertices for knitting. */
X  apex(leftcand, upperleft);
X  apex(rightcand, upperright);
X  /* Walk up the gap between the two triangulations, knitting them together. */
X  while (1) {
X    /* Have we reached the top?  (This isn't quite the right question,       */
X    /*   because even though the left triangulation might seem finished now, */
X    /*   moving up on the right triangulation might reveal a new vertex of   */
X    /*   the left triangulation.  And vice-versa.)                           */
X    leftfinished = counterclockwise(m, b, upperleft, lowerleft, lowerright) <=
X                   0.0;
X    rightfinished = counterclockwise(m, b, upperright, lowerleft, lowerright)
X                 <= 0.0;
X    if (leftfinished && rightfinished) {
X      /* Create the top new bounding triangle. */
X      maketriangle(m, b, &nextedge);
X      setorg(nextedge, lowerleft);
X      setdest(nextedge, lowerright);
X      /* Apex is intentionally left NULL. */
X      /* Connect it to the bounding boxes of the two triangulations. */
X      bond(nextedge, baseedge);
X      lnextself(nextedge);
X      bond(nextedge, rightcand);
X      lnextself(nextedge);
X      bond(nextedge, leftcand);
X      if (b->verbose > 2) {
X        printf("  Creating top bounding ");
X        printtriangle(m, b, &nextedge);
X      }
X      /* Special treatment for horizontal cuts. */
X      if (b->dwyer && (axis == 1)) {
X        org(*farleft, farleftpt);
X        apex(*farleft, farleftapex);
X        dest(*farright, farrightpt);
X        apex(*farright, farrightapex);
X        sym(*farleft, checkedge);
X        apex(checkedge, checkvertex);
X        /* The pointers to the extremal vertices are restored to the  */
X        /*   leftmost and rightmost vertices (rather than topmost and */
X        /*   bottommost).                                             */
X        while (checkvertex[0] < farleftpt[0]) {
X          lprev(checkedge, *farleft);
X          farleftapex = farleftpt;
X          farleftpt = checkvertex;
X          sym(*farleft, checkedge);
X          apex(checkedge, checkvertex);
X        }
X        while (farrightapex[0] > farrightpt[0]) {
X          lprevself(*farright);
X          symself(*farright);
X          farrightpt = farrightapex;
X          apex(*farright, farrightapex);
X        }
X      }
X      return;
X    }
X    /* Consider eliminating edges from the left triangulation. */
X    if (!leftfinished) {
X      /* What vertex would be exposed if an edge were deleted? */
X      lprev(leftcand, nextedge);
X      symself(nextedge);
X      apex(nextedge, nextapex);
X      /* If nextapex is NULL, then no vertex would be exposed; the */
X      /*   triangulation would have been eaten right through.      */
X      if (nextapex != (vertex) NULL) {
X        /* Check whether the edge is Delaunay. */
X        badedge = incircle(m, b, lowerleft, lowerright, upperleft, nextapex) >
X                  0.0;
X        while (badedge) {
X          /* Eliminate the edge with an edge flip.  As a result, the    */
X          /*   left triangulation will have one more boundary triangle. */
X          lnextself(nextedge);
X          sym(nextedge, topcasing);
X          lnextself(nextedge);
X          sym(nextedge, sidecasing);
X          bond(nextedge, topcasing);
X          bond(leftcand, sidecasing);
X          lnextself(leftcand);
X          sym(leftcand, outercasing);
X          lprevself(nextedge);
X          bond(nextedge, outercasing);
X          /* Correct the vertices to reflect the edge flip. */
X          setorg(leftcand, lowerleft);
X          setdest(leftcand, NULL);
X          setapex(leftcand, nextapex);
X          setorg(nextedge, NULL);
X          setdest(nextedge, upperleft);
X          setapex(nextedge, nextapex);
X          /* Consider the newly exposed vertex. */
X          upperleft = nextapex;
X          /* What vertex would be exposed if another edge were deleted? */
X          otricopy(sidecasing, nextedge);
X          apex(nextedge, nextapex);
X          if (nextapex != (vertex) NULL) {
X            /* Check whether the edge is Delaunay. */
X            badedge = incircle(m, b, lowerleft, lowerright, upperleft,
X                               nextapex) > 0.0;
X          } else {
X            /* Avoid eating right through the triangulation. */
X            badedge = 0;
X          }
X        }
X      }
X    }
X    /* Consider eliminating edges from the right triangulation. */
X    if (!rightfinished) {
X      /* What vertex would be exposed if an edge were deleted? */
X      lnext(rightcand, nextedge);
X      symself(nextedge);
X      apex(nextedge, nextapex);
X      /* If nextapex is NULL, then no vertex would be exposed; the */
X      /*   triangulation would have been eaten right through.      */
X      if (nextapex != (vertex) NULL) {
X        /* Check whether the edge is Delaunay. */
X        badedge = incircle(m, b, lowerleft, lowerright, upperright, nextapex) >
X                  0.0;
X        while (badedge) {
X          /* Eliminate the edge with an edge flip.  As a result, the     */
X          /*   right triangulation will have one more boundary triangle. */
X          lprevself(nextedge);
X          sym(nextedge, topcasing);
X          lprevself(nextedge);
X          sym(nextedge, sidecasing);
X          bond(nextedge, topcasing);
X          bond(rightcand, sidecasing);
X          lprevself(rightcand);
X          sym(rightcand, outercasing);
X          lnextself(nextedge);
X          bond(nextedge, outercasing);
X          /* Correct the vertices to reflect the edge flip. */
X          setorg(rightcand, NULL);
X          setdest(rightcand, lowerright);
X          setapex(rightcand, nextapex);
X          setorg(nextedge, upperright);
X          setdest(nextedge, NULL);
X          setapex(nextedge, nextapex);
X          /* Consider the newly exposed vertex. */
X          upperright = nextapex;
X          /* What vertex would be exposed if another edge were deleted? */
X          otricopy(sidecasing, nextedge);
X          apex(nextedge, nextapex);
X          if (nextapex != (vertex) NULL) {
X            /* Check whether the edge is Delaunay. */
X            badedge = incircle(m, b, lowerleft, lowerright, upperright,
X                               nextapex) > 0.0;
X          } else {
X            /* Avoid eating right through the triangulation. */
X            badedge = 0;
X          }
X        }
X      }
X    }
X    if (leftfinished || (!rightfinished &&
X           (incircle(m, b, upperleft, lowerleft, lowerright, upperright) >
X            0.0))) {
X      /* Knit the triangulations, adding an edge from `lowerleft' */
X      /*   to `upperright'.                                       */
X      bond(baseedge, rightcand);
X      lprev(rightcand, baseedge);
X      setdest(baseedge, lowerleft);
X      lowerright = upperright;
X      sym(baseedge, rightcand);
X      apex(rightcand, upperright);
X    } else {
X      /* Knit the triangulations, adding an edge from `upperleft' */
X      /*   to `lowerright'.                                       */
X      bond(baseedge, leftcand);
X      lnext(leftcand, baseedge);
X      setorg(baseedge, lowerright);
X      lowerleft = upperleft;
X      sym(baseedge, leftcand);
X      apex(leftcand, upperleft);
X    }
X    if (b->verbose > 2) {
X      printf("  Connecting ");
X      printtriangle(m, b, &baseedge);
X    }
X  }
}
X
/*****************************************************************************/
/*                                                                           */
/*  divconqrecurse()   Recursively form a Delaunay triangulation by the      */
/*                     divide-and-conquer method.                            */
/*                                                                           */
/*  Recursively breaks down the problem into smaller pieces, which are       */
/*  knitted together by mergehulls().  The base cases (problems of two or    */
/*  three vertices) are handled specially here.                              */
/*                                                                           */
/*  On completion, `farleft' and `farright' are bounding triangles such that */
/*  the origin of `farleft' is the leftmost vertex (breaking ties by         */
/*  choosing the highest leftmost vertex), and the destination of            */
/*  `farright' is the rightmost vertex (breaking ties by choosing the        */
/*  lowest rightmost vertex).                                                */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
void divconqrecurse(struct mesh *m, struct behavior *b, vertex *sortarray,
X                    int vertices, int axis,
X                    struct otri *farleft, struct otri *farright)
#else /* not ANSI_DECLARATORS */
void divconqrecurse(m, b, sortarray, vertices, axis, farleft, farright)
struct mesh *m;
struct behavior *b;
vertex *sortarray;
int vertices;
int axis;
struct otri *farleft;
struct otri *farright;
#endif /* not ANSI_DECLARATORS */
X
{
X  struct otri midtri, tri1, tri2, tri3;
X  struct otri innerleft, innerright;
X  REAL area;
X  int divider;
X
X  if (b->verbose > 2) {
X    printf("  Triangulating %d vertices.\n", vertices);
X  }
X  if (vertices == 2) {
X    /* The triangulation of two vertices is an edge.  An edge is */
X    /*   represented by two bounding triangles.                  */
X    maketriangle(m, b, farleft);
X    setorg(*farleft, sortarray[0]);
X    setdest(*farleft, sortarray[1]);
X    /* The apex is intentionally left NULL. */
X    maketriangle(m, b, farright);
X    setorg(*farright, sortarray[1]);
X    setdest(*farright, sortarray[0]);
X    /* The apex is intentionally left NULL. */
X    bond(*farleft, *farright);
X    lprevself(*farleft);
X    lnextself(*farright);
X    bond(*farleft, *farright);
X    lprevself(*farleft);
X    lnextself(*farright);
X    bond(*farleft, *farright);
X    if (b->verbose > 2) {
X      printf("  Creating ");
X      printtriangle(m, b, farleft);
X      printf("  Creating ");
X      printtriangle(m, b, farright);
X    }
X    /* Ensure that the origin of `farleft' is sortarray[0]. */
X    lprev(*farright, *farleft);
X    return;
X  } else if (vertices == 3) {
X    /* The triangulation of three vertices is either a triangle (with */
X    /*   three bounding triangles) or two edges (with four bounding   */
X    /*   triangles).  In either case, four triangles are created.     */
X    maketriangle(m, b, &midtri);
X    maketriangle(m, b, &tri1);
X    maketriangle(m, b, &tri2);
X    maketriangle(m, b, &tri3);
X    area = counterclockwise(m, b, sortarray[0], sortarray[1], sortarray[2]);
X    if (area == 0.0) {
X      /* Three collinear vertices; the triangulation is two edges. */
X      setorg(midtri, sortarray[0]);
X      setdest(midtri, sortarray[1]);
X      setorg(tri1, sortarray[1]);
X      setdest(tri1, sortarray[0]);
X      setorg(tri2, sortarray[2]);
X      setdest(tri2, sortarray[1]);
X      setorg(tri3, sortarray[1]);
X      setdest(tri3, sortarray[2]);
X      /* All apices are intentionally left NULL. */
X      bond(midtri, tri1);
X      bond(tri2, tri3);
X      lnextself(midtri);
X      lprevself(tri1);
X      lnextself(tri2);
X      lprevself(tri3);
X      bond(midtri, tri3);
X      bond(tri1, tri2);
X      lnextself(midtri);
X      lprevself(tri1);
X      lnextself(tri2);
X      lprevself(tri3);
X      bond(midtri, tri1);
X      bond(tri2, tri3);
X      /* Ensure that the origin of `farleft' is sortarray[0]. */
X      otricopy(tri1, *farleft);
X      /* Ensure that the destination of `farright' is sortarray[2]. */
X      otricopy(tri2, *farright);
X    } else {
X      /* The three vertices are not collinear; the triangulation is one */
X      /*   triangle, namely `midtri'.                                   */
X      setorg(midtri, sortarray[0]);
X      setdest(tri1, sortarray[0]);
X      setorg(tri3, sortarray[0]);
X      /* Apices of tri1, tri2, and tri3 are left NULL. */
X      if (area > 0.0) {
X        /* The vertices are in counterclockwise order. */
X        setdest(midtri, sortarray[1]);
X        setorg(tri1, sortarray[1]);
X        setdest(tri2, sortarray[1]);
X        setapex(midtri, sortarray[2]);
X        setorg(tri2, sortarray[2]);
X        setdest(tri3, sortarray[2]);
X      } else {
X        /* The vertices are in clockwise order. */
X        setdest(midtri, sortarray[2]);
X        setorg(tri1, sortarray[2]);
X        setdest(tri2, sortarray[2]);
X        setapex(midtri, sortarray[1]);
X        setorg(tri2, sortarray[1]);
X        setdest(tri3, sortarray[1]);
X      }
X      /* The topology does not depend on how the vertices are ordered. */
X      bond(midtri, tri1);
X      lnextself(midtri);
X      bond(midtri, tri2);
X      lnextself(midtri);
X      bond(midtri, tri3);
X      lprevself(tri1);
X      lnextself(tri2);
X      bond(tri1, tri2);
X      lprevself(tri1);
X      lprevself(tri3);
X      bond(tri1, tri3);
X      lnextself(tri2);
X      lprevself(tri3);
X      bond(tri2, tri3);
X      /* Ensure that the origin of `farleft' is sortarray[0]. */
X      otricopy(tri1, *farleft);
X      /* Ensure that the destination of `farright' is sortarray[2]. */
X      if (area > 0.0) {
X        otricopy(tri2, *farright);
X      } else {
X        lnext(*farleft, *farright);
X      }
X    }
X    if (b->verbose > 2) {
X      printf("  Creating ");
X      printtriangle(m, b, &midtri);
X      printf("  Creating ");
X      printtriangle(m, b, &tri1);
X      printf("  Creating ");
X      printtriangle(m, b, &tri2);
X      printf("  Creating ");
X      printtriangle(m, b, &tri3);
X    }
X    return;
X  } else {
X    /* Split the vertices in half. */
X    divider = vertices >> 1;
X    /* Recursively triangulate each half. */
X    divconqrecurse(m, b, sortarray, divider, 1 - axis, farleft, &innerleft);
X    divconqrecurse(m, b, &sortarray[divider], vertices - divider, 1 - axis,
X                   &innerright, farright);
X    if (b->verbose > 1) {
X      printf("  Joining triangulations with %d and %d vertices.\n", divider,
X             vertices - divider);
X    }
X    /* Merge the two triangulations into one. */
X    mergehulls(m, b, farleft, &innerleft, &innerright, farright, axis);
X  }
}
X
#ifdef ANSI_DECLARATORS
long removeghosts(struct mesh *m, struct behavior *b, struct otri *startghost)
#else /* not ANSI_DECLARATORS */
long removeghosts(m, b, startghost)
struct mesh *m;
struct behavior *b;
struct otri *startghost;
#endif /* not ANSI_DECLARATORS */
X
{
X  struct otri searchedge;
X  struct otri dissolveedge;
X  struct otri deadtriangle;
X  vertex markorg;
X  long hullsize;
X  triangle ptr;                         /* Temporary variable used by sym(). */
X
X  if (b->verbose) {
X    printf("  Removing ghost triangles.\n");
X  }
X  /* Find an edge on the convex hull to start point location from. */
X  lprev(*startghost, searchedge);
X  symself(searchedge);
X  m->dummytri[0] = encode(searchedge);
X  /* Remove the bounding box and count the convex hull edges. */
X  otricopy(*startghost, dissolveedge);
X  hullsize = 0;
X  do {
X    hullsize++;
X    lnext(dissolveedge, deadtriangle);
X    lprevself(dissolveedge);
X    symself(dissolveedge);
X    /* If no PSLG is involved, set the boundary markers of all the vertices */
X    /*   on the convex hull.  If a PSLG is used, this step is done later.   */
X    if (!b->poly) {
X      /* Watch out for the case where all the input vertices are collinear. */
X      if (dissolveedge.tri != m->dummytri) {
X        org(dissolveedge, markorg);
X        if (vertexmark(markorg) == 0) {
X          setvertexmark(markorg, 1);
X        }
X      }
X    }
X    /* Remove a bounding triangle from a convex hull triangle. */
X    dissolve(dissolveedge);
X    /* Find the next bounding triangle. */
X    sym(deadtriangle, dissolveedge);
X    /* Delete the bounding triangle. */
X    triangledealloc(m, deadtriangle.tri);
X  } while (!otriequal(dissolveedge, *startghost));
X  return hullsize;
}
X
/*****************************************************************************/
/*                                                                           */
/*  divconqdelaunay()   Form a Delaunay triangulation by the divide-and-     */
/*                      conquer method.                                      */
/*                                                                           */
/*  Sorts the vertices, calls a recursive procedure to triangulate them, and */
/*  removes the bounding box, setting boundary markers as appropriate.       */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
long divconqdelaunay(struct mesh *m, struct behavior *b)
#else /* not ANSI_DECLARATORS */
long divconqdelaunay(m, b)
struct mesh *m;
struct behavior *b;
#endif /* not ANSI_DECLARATORS */
X
{
X  vertex *sortarray;
X  struct otri hullleft, hullright;
X  int divider;
X  int i, j;
X
X  if (b->verbose) {
X    printf("  Sorting vertices.\n");
X  }
X
X  /* Allocate an array of pointers to vertices for sorting. */
X  sortarray = (vertex *) trimalloc(m->invertices * (int) sizeof(vertex));
X  traversalinit(&m->vertices);
X  for (i = 0; i < m->invertices; i++) {
X    sortarray[i] = vertextraverse(m);
X  }
X  /* Sort the vertices. */
X  vertexsort(sortarray, m->invertices);
X  /* Discard duplicate vertices, which can really mess up the algorithm. */
X  i = 0;
X  for (j = 1; j < m->invertices; j++) {
X    if ((sortarray[i][0] == sortarray[j][0])
X        && (sortarray[i][1] == sortarray[j][1])) {
X      if (!b->quiet) {
X        printf(
"Warning:  A duplicate vertex at (%.12g, %.12g) appeared and was ignored.\n",
X               sortarray[j][0], sortarray[j][1]);
X      }
X      setvertextype(sortarray[j], UNDEADVERTEX);
X      m->undeads++;
X    } else {
X      i++;
X      sortarray[i] = sortarray[j];
X    }
X  }
X  i++;
X  if (b->dwyer) {
X    /* Re-sort the array of vertices to accommodate alternating cuts. */
X    divider = i >> 1;
X    if (i - divider >= 2) {
X      if (divider >= 2) {
X        alternateaxes(sortarray, divider, 1);
X      }
X      alternateaxes(&sortarray[divider], i - divider, 1);
X    }
X  }
X
X  if (b->verbose) {
X    printf("  Forming triangulation.\n");
X  }
X
X  /* Form the Delaunay triangulation. */
X  divconqrecurse(m, b, sortarray, i, 0, &hullleft, &hullright);
X  trifree((VOID *) sortarray);
X
X  return removeghosts(m, b, &hullleft);
}
X
/**                                                                         **/
/**                                                                         **/
/********* Divide-and-conquer Delaunay triangulation ends here       *********/
X
/********* Incremental Delaunay triangulation begins here            *********/
/**                                                                         **/
/**                                                                         **/
X
/*****************************************************************************/
/*                                                                           */
/*  boundingbox()   Form an "infinite" bounding triangle to insert vertices  */
/*                  into.                                                    */
/*                                                                           */
/*  The vertices at "infinity" are assigned finite coordinates, which are    */
/*  used by the point location routines, but (mostly) ignored by the         */
/*  Delaunay edge flip routines.                                             */
/*                                                                           */
/*****************************************************************************/
X
#ifndef REDUCED
X
#ifdef ANSI_DECLARATORS
void boundingbox(struct mesh *m, struct behavior *b)
#else /* not ANSI_DECLARATORS */
void boundingbox(m, b)
struct mesh *m;
struct behavior *b;
#endif /* not ANSI_DECLARATORS */
X
{
X  struct otri inftri;          /* Handle for the triangular bounding box. */
X  REAL width;
X
X  if (b->verbose) {
X    printf("  Creating triangular bounding box.\n");
X  }
X  /* Find the width (or height, whichever is larger) of the triangulation. */
X  width = m->xmax - m->xmin;
X  if (m->ymax - m->ymin > width) {
X    width = m->ymax - m->ymin;
X  }
X  if (width == 0.0) {
X    width = 1.0;
X  }
X  /* Create the vertices of the bounding box. */
X  m->infvertex1 = (vertex) trimalloc(m->vertices.itembytes);
X  m->infvertex2 = (vertex) trimalloc(m->vertices.itembytes);
X  m->infvertex3 = (vertex) trimalloc(m->vertices.itembytes);
X  m->infvertex1[0] = m->xmin - 50.0 * width;
X  m->infvertex1[1] = m->ymin - 40.0 * width;
X  m->infvertex2[0] = m->xmax + 50.0 * width;
X  m->infvertex2[1] = m->ymin - 40.0 * width;
X  m->infvertex3[0] = 0.5 * (m->xmin + m->xmax);
X  m->infvertex3[1] = m->ymax + 60.0 * width;
X
X  /* Create the bounding box. */
X  maketriangle(m, b, &inftri);
X  setorg(inftri, m->infvertex1);
X  setdest(inftri, m->infvertex2);
X  setapex(inftri, m->infvertex3);
X  /* Link dummytri to the bounding box so we can always find an */
X  /*   edge to begin searching (point location) from.           */
X  m->dummytri[0] = (triangle) inftri.tri;
X  if (b->verbose > 2) {
X    printf("  Creating ");
X    printtriangle(m, b, &inftri);
X  }
}
X
#endif /* not REDUCED */
X
/*****************************************************************************/
/*                                                                           */
/*  removebox()   Remove the "infinite" bounding triangle, setting boundary  */
/*                markers as appropriate.                                    */
/*                                                                           */
/*  The triangular bounding box has three boundary triangles (one for each   */
/*  side of the bounding box), and a bunch of triangles fanning out from     */
/*  the three bounding box vertices (one triangle for each edge of the       */
/*  convex hull of the inner mesh).  This routine removes these triangles.   */
/*                                                                           */
/*  Returns the number of edges on the convex hull of the triangulation.     */
/*                                                                           */
/*****************************************************************************/
X
#ifndef REDUCED
X
#ifdef ANSI_DECLARATORS
long removebox(struct mesh *m, struct behavior *b)
#else /* not ANSI_DECLARATORS */
long removebox(m, b)
struct mesh *m;
struct behavior *b;
#endif /* not ANSI_DECLARATORS */
X
{
X  struct otri deadtriangle;
X  struct otri searchedge;
X  struct otri checkedge;
X  struct otri nextedge, finaledge, dissolveedge;
X  vertex markorg;
X  long hullsize;
X  triangle ptr;                         /* Temporary variable used by sym(). */
X
X  if (b->verbose) {
X    printf("  Removing triangular bounding box.\n");
X  }
X  /* Find a boundary triangle. */
X  nextedge.tri = m->dummytri;
X  nextedge.orient = 0;
X  symself(nextedge);
X  /* Mark a place to stop. */
X  lprev(nextedge, finaledge);
X  lnextself(nextedge);
X  symself(nextedge);
X  /* Find a triangle (on the boundary of the vertex set) that isn't */
X  /*   a bounding box triangle.                                     */
X  lprev(nextedge, searchedge);
X  symself(searchedge);
X  /* Check whether nextedge is another boundary triangle */
X  /*   adjacent to the first one.                        */
X  lnext(nextedge, checkedge);
X  symself(checkedge);
X  if (checkedge.tri == m->dummytri) {
X    /* Go on to the next triangle.  There are only three boundary   */
X    /*   triangles, and this next triangle cannot be the third one, */
X    /*   so it's safe to stop here.                                 */
X    lprevself(searchedge);
X    symself(searchedge);
X  }
X  /* Find a new boundary edge to search from, as the current search */
X  /*   edge lies on a bounding box triangle and will be deleted.    */
X  m->dummytri[0] = encode(searchedge);
X  hullsize = -2l;
X  while (!otriequal(nextedge, finaledge)) {
X    hullsize++;
X    lprev(nextedge, dissolveedge);
X    symself(dissolveedge);
X    /* If not using a PSLG, the vertices should be marked now. */
X    /*   (If using a PSLG, markhull() will do the job.)        */
X    if (!b->poly) {
X      /* Be careful!  One must check for the case where all the input     */
X      /*   vertices are collinear, and thus all the triangles are part of */
X      /*   the bounding box.  Otherwise, the setvertexmark() call below   */
X      /*   will cause a bad pointer reference.                            */
X      if (dissolveedge.tri != m->dummytri) {
X        org(dissolveedge, markorg);
X        if (vertexmark(markorg) == 0) {
X          setvertexmark(markorg, 1);
X        }
X      }
X    }
X    /* Disconnect the bounding box triangle from the mesh triangle. */
X    dissolve(dissolveedge);
X    lnext(nextedge, deadtriangle);
X    sym(deadtriangle, nextedge);
X    /* Get rid of the bounding box triangle. */
X    triangledealloc(m, deadtriangle.tri);
X    /* Do we need to turn the corner? */
X    if (nextedge.tri == m->dummytri) {
X      /* Turn the corner. */
X      otricopy(dissolveedge, nextedge);
X    }
X  }
X  triangledealloc(m, finaledge.tri);
X
X  trifree((VOID *) m->infvertex1);  /* Deallocate the bounding box vertices. */
X  trifree((VOID *) m->infvertex2);
X  trifree((VOID *) m->infvertex3);
X
X  return hullsize;
}
X
#endif /* not REDUCED */
X
/*****************************************************************************/
/*                                                                           */
/*  incrementaldelaunay()   Form a Delaunay triangulation by incrementally   */
/*                          inserting vertices.                              */
/*                                                                           */
/*  Returns the number of edges on the convex hull of the triangulation.     */
/*                                                                           */
/*****************************************************************************/
X
#ifndef REDUCED
X
#ifdef ANSI_DECLARATORS
long incrementaldelaunay(struct mesh *m, struct behavior *b)
#else /* not ANSI_DECLARATORS */
long incrementaldelaunay(m, b)
struct mesh *m;
struct behavior *b;
#endif /* not ANSI_DECLARATORS */
X
{
X  struct otri starttri;
X  vertex vertexloop;
X
X  /* Create a triangular bounding box. */
X  boundingbox(m, b);
X  if (b->verbose) {
X    printf("  Incrementally inserting vertices.\n");
X  }
X  traversalinit(&m->vertices);
X  vertexloop = vertextraverse(m);
X  while (vertexloop != (vertex) NULL) {
X    starttri.tri = m->dummytri;
X    if (insertvertex(m, b, vertexloop, &starttri, (struct osub *) NULL, 0, 0)
X        == DUPLICATEVERTEX) {
X      if (!b->quiet) {
X        printf(
"Warning:  A duplicate vertex at (%.12g, %.12g) appeared and was ignored.\n",
X               vertexloop[0], vertexloop[1]);
X      }
X      setvertextype(vertexloop, UNDEADVERTEX);
X      m->undeads++;
X    }
X    vertexloop = vertextraverse(m);
X  }
X  /* Remove the bounding box. */
X  return removebox(m, b);
}
X
#endif /* not REDUCED */
X
/**                                                                         **/
/**                                                                         **/
/********* Incremental Delaunay triangulation ends here              *********/
X
/********* Sweepline Delaunay triangulation begins here              *********/
/**                                                                         **/
/**                                                                         **/
X
#ifndef REDUCED
X
#ifdef ANSI_DECLARATORS
void eventheapinsert(struct event **heap, int heapsize, struct event *newevent)
#else /* not ANSI_DECLARATORS */
void eventheapinsert(heap, heapsize, newevent)
struct event **heap;
int heapsize;
struct event *newevent;
#endif /* not ANSI_DECLARATORS */
X
{
X  REAL eventx, eventy;
X  int eventnum;
X  int parent;
X  int notdone;
X
X  eventx = newevent->xkey;
X  eventy = newevent->ykey;
X  eventnum = heapsize;
X  notdone = eventnum > 0;
X  while (notdone) {
X    parent = (eventnum - 1) >> 1;
X    if ((heap[parent]->ykey < eventy) ||
X        ((heap[parent]->ykey == eventy)
X         && (heap[parent]->xkey <= eventx))) {
X      notdone = 0;
X    } else {
X      heap[eventnum] = heap[parent];
X      heap[eventnum]->heapposition = eventnum;
X
X      eventnum = parent;
X      notdone = eventnum > 0;
X    }
X  }
X  heap[eventnum] = newevent;
X  newevent->heapposition = eventnum;
}
X
#endif /* not REDUCED */
X
#ifndef REDUCED
X
#ifdef ANSI_DECLARATORS
void eventheapify(struct event **heap, int heapsize, int eventnum)
#else /* not ANSI_DECLARATORS */
void eventheapify(heap, heapsize, eventnum)
struct event **heap;
int heapsize;
int eventnum;
#endif /* not ANSI_DECLARATORS */
X
{
X  struct event *thisevent;
X  REAL eventx, eventy;
X  int leftchild, rightchild;
X  int smallest;
X  int notdone;
X
X  thisevent = heap[eventnum];
X  eventx = thisevent->xkey;
X  eventy = thisevent->ykey;
X  leftchild = 2 * eventnum + 1;
X  notdone = leftchild < heapsize;
X  while (notdone) {
X    if ((heap[leftchild]->ykey < eventy) ||
X        ((heap[leftchild]->ykey == eventy)
X         && (heap[leftchild]->xkey < eventx))) {
X      smallest = leftchild;
X    } else {
X      smallest = eventnum;
X    }
X    rightchild = leftchild + 1;
X    if (rightchild < heapsize) {
X      if ((heap[rightchild]->ykey < heap[smallest]->ykey) ||
X          ((heap[rightchild]->ykey == heap[smallest]->ykey)
X           && (heap[rightchild]->xkey < heap[smallest]->xkey))) {
X        smallest = rightchild;
X      }
X    }
X    if (smallest == eventnum) {
X      notdone = 0;
X    } else {
X      heap[eventnum] = heap[smallest];
X      heap[eventnum]->heapposition = eventnum;
X      heap[smallest] = thisevent;
X      thisevent->heapposition = smallest;
X
X      eventnum = smallest;
X      leftchild = 2 * eventnum + 1;
X      notdone = leftchild < heapsize;
X    }
X  }
}
X
#endif /* not REDUCED */
X
#ifndef REDUCED
X
#ifdef ANSI_DECLARATORS
void eventheapdelete(struct event **heap, int heapsize, int eventnum)
#else /* not ANSI_DECLARATORS */
void eventheapdelete(heap, heapsize, eventnum)
struct event **heap;
int heapsize;
int eventnum;
#endif /* not ANSI_DECLARATORS */
X
{
X  struct event *moveevent;
X  REAL eventx, eventy;
X  int parent;
X  int notdone;
X
X  moveevent = heap[heapsize - 1];
X  if (eventnum > 0) {
X    eventx = moveevent->xkey;
X    eventy = moveevent->ykey;
X    do {
X      parent = (eventnum - 1) >> 1;
X      if ((heap[parent]->ykey < eventy) ||
X          ((heap[parent]->ykey == eventy)
X           && (heap[parent]->xkey <= eventx))) {
X        notdone = 0;
X      } else {
X        heap[eventnum] = heap[parent];
X        heap[eventnum]->heapposition = eventnum;
X
X        eventnum = parent;
X        notdone = eventnum > 0;
X      }
X    } while (notdone);
X  }
X  heap[eventnum] = moveevent;
X  moveevent->heapposition = eventnum;
X  eventheapify(heap, heapsize - 1, eventnum);
}
X
#endif /* not REDUCED */
X
#ifndef REDUCED
X
#ifdef ANSI_DECLARATORS
void createeventheap(struct mesh *m, struct event ***eventheap,
X                     struct event **events, struct event **freeevents)
#else /* not ANSI_DECLARATORS */
void createeventheap(m, eventheap, events, freeevents)
struct mesh *m;
struct event ***eventheap;
struct event **events;
struct event **freeevents;
#endif /* not ANSI_DECLARATORS */
X
{
X  vertex thisvertex;
X  int maxevents;
X  int i;
X
X  maxevents = (3 * m->invertices) / 2;
X  *eventheap = (struct event **) trimalloc(maxevents *
X                                           (int) sizeof(struct event *));
X  *events = (struct event *) trimalloc(maxevents * (int) sizeof(struct event));
X  traversalinit(&m->vertices);
X  for (i = 0; i < m->invertices; i++) {
X    thisvertex = vertextraverse(m);
X    (*events)[i].eventptr = (VOID *) thisvertex;
X    (*events)[i].xkey = thisvertex[0];
X    (*events)[i].ykey = thisvertex[1];
X    eventheapinsert(*eventheap, i, *events + i);
X  }
X  *freeevents = (struct event *) NULL;
X  for (i = maxevents - 1; i >= m->invertices; i--) {
X    (*events)[i].eventptr = (VOID *) *freeevents;
X    *freeevents = *events + i;
X  }
}
X
#endif /* not REDUCED */
X
#ifndef REDUCED
X
#ifdef ANSI_DECLARATORS
int rightofhyperbola(struct mesh *m, struct otri *fronttri, vertex newsite)
#else /* not ANSI_DECLARATORS */
int rightofhyperbola(m, fronttri, newsite)
struct mesh *m;
struct otri *fronttri;
vertex newsite;
#endif /* not ANSI_DECLARATORS */
X
{
X  vertex leftvertex, rightvertex;
X  REAL dxa, dya, dxb, dyb;
X
X  m->hyperbolacount++;
X
X  dest(*fronttri, leftvertex);
X  apex(*fronttri, rightvertex);
X  if ((leftvertex[1] < rightvertex[1]) ||
X      ((leftvertex[1] == rightvertex[1]) &&
X       (leftvertex[0] < rightvertex[0]))) {
X    if (newsite[0] >= rightvertex[0]) {
X      return 1;
X    }
X  } else {
X    if (newsite[0] <= leftvertex[0]) {
X      return 0;
X    }
X  }
X  dxa = leftvertex[0] - newsite[0];
X  dya = leftvertex[1] - newsite[1];
X  dxb = rightvertex[0] - newsite[0];
X  dyb = rightvertex[1] - newsite[1];
X  return dya * (dxb * dxb + dyb * dyb) > dyb * (dxa * dxa + dya * dya);
}
X
#endif /* not REDUCED */
X
#ifndef REDUCED
X
#ifdef ANSI_DECLARATORS
REAL circletop(struct mesh *m, vertex pa, vertex pb, vertex pc, REAL ccwabc)
#else /* not ANSI_DECLARATORS */
REAL circletop(m, pa, pb, pc, ccwabc)
struct mesh *m;
vertex pa;
vertex pb;
vertex pc;
REAL ccwabc;
#endif /* not ANSI_DECLARATORS */
X
{
X  REAL xac, yac, xbc, ybc, xab, yab;
X  REAL aclen2, bclen2, ablen2;
X
X  m->circletopcount++;
X
X  xac = pa[0] - pc[0];
X  yac = pa[1] - pc[1];
X  xbc = pb[0] - pc[0];
X  ybc = pb[1] - pc[1];
X  xab = pa[0] - pb[0];
X  yab = pa[1] - pb[1];
X  aclen2 = xac * xac + yac * yac;
X  bclen2 = xbc * xbc + ybc * ybc;
X  ablen2 = xab * xab + yab * yab;
X  return pc[1] + (xac * bclen2 - xbc * aclen2 + sqrt(aclen2 * bclen2 * ablen2))
X               / (2.0 * ccwabc);
}
X
#endif /* not REDUCED */
X
#ifndef REDUCED
X
#ifdef ANSI_DECLARATORS
void check4deadevent(struct otri *checktri, struct event **freeevents,
X                     struct event **eventheap, int *heapsize)
#else /* not ANSI_DECLARATORS */
void check4deadevent(checktri, freeevents, eventheap, heapsize)
struct otri *checktri;
struct event **freeevents;
struct event **eventheap;
int *heapsize;
#endif /* not ANSI_DECLARATORS */
X
{
X  struct event *deadevent;
X  vertex eventvertex;
X  int eventnum;
X
X  org(*checktri, eventvertex);
X  if (eventvertex != (vertex) NULL) {
X    deadevent = (struct event *) eventvertex;
X    eventnum = deadevent->heapposition;
X    deadevent->eventptr = (VOID *) *freeevents;
X    *freeevents = deadevent;
X    eventheapdelete(eventheap, *heapsize, eventnum);
X    (*heapsize)--;
X    setorg(*checktri, NULL);
X  }
}
X
#endif /* not REDUCED */
X
#ifndef REDUCED
X
#ifdef ANSI_DECLARATORS
struct splaynode *splay(struct mesh *m, struct splaynode *splaytree,
X                        vertex searchpoint, struct otri *searchtri)
#else /* not ANSI_DECLARATORS */
struct splaynode *splay(m, splaytree, searchpoint, searchtri)
struct mesh *m;
struct splaynode *splaytree;
vertex searchpoint;
struct otri *searchtri;
#endif /* not ANSI_DECLARATORS */
X
{
X  struct splaynode *child, *grandchild;
X  struct splaynode *lefttree, *righttree;
X  struct splaynode *leftright;
X  vertex checkvertex;
X  int rightofroot, rightofchild;
X
X  if (splaytree == (struct splaynode *) NULL) {
X    return (struct splaynode *) NULL;
X  }
X  dest(splaytree->keyedge, checkvertex);
X  if (checkvertex == splaytree->keydest) {
X    rightofroot = rightofhyperbola(m, &splaytree->keyedge, searchpoint);
X    if (rightofroot) {
X      otricopy(splaytree->keyedge, *searchtri);
X      child = splaytree->rchild;
X    } else {
X      child = splaytree->lchild;
X    }
X    if (child == (struct splaynode *) NULL) {
X      return splaytree;
X    }
X    dest(child->keyedge, checkvertex);
X    if (checkvertex != child->keydest) {
X      child = splay(m, child, searchpoint, searchtri);
X      if (child == (struct splaynode *) NULL) {
X        if (rightofroot) {
X          splaytree->rchild = (struct splaynode *) NULL;
X        } else {
X          splaytree->lchild = (struct splaynode *) NULL;
X        }
X        return splaytree;
X      }
X    }
X    rightofchild = rightofhyperbola(m, &child->keyedge, searchpoint);
X    if (rightofchild) {
X      otricopy(child->keyedge, *searchtri);
X      grandchild = splay(m, child->rchild, searchpoint, searchtri);
X      child->rchild = grandchild;
X    } else {
X      grandchild = splay(m, child->lchild, searchpoint, searchtri);
X      child->lchild = grandchild;
X    }
X    if (grandchild == (struct splaynode *) NULL) {
X      if (rightofroot) {
X        splaytree->rchild = child->lchild;
X        child->lchild = splaytree;
X      } else {
X        splaytree->lchild = child->rchild;
X        child->rchild = splaytree;
X      }
X      return child;
X    }
X    if (rightofchild) {
X      if (rightofroot) {
X        splaytree->rchild = child->lchild;
X        child->lchild = splaytree;
X      } else {
X        splaytree->lchild = grandchild->rchild;
X        grandchild->rchild = splaytree;
X      }
X      child->rchild = grandchild->lchild;
X      grandchild->lchild = child;
X    } else {
X      if (rightofroot) {
X        splaytree->rchild = grandchild->lchild;
X        grandchild->lchild = splaytree;
X      } else {
X        splaytree->lchild = child->rchild;
X        child->rchild = splaytree;
X      }
X      child->lchild = grandchild->rchild;
X      grandchild->rchild = child;
X    }
X    return grandchild;
X  } else {
X    lefttree = splay(m, splaytree->lchild, searchpoint, searchtri);
X    righttree = splay(m, splaytree->rchild, searchpoint, searchtri);
X
X    pooldealloc(&m->splaynodes, (VOID *) splaytree);
X    if (lefttree == (struct splaynode *) NULL) {
X      return righttree;
X    } else if (righttree == (struct splaynode *) NULL) {
X      return lefttree;
X    } else if (lefttree->rchild == (struct splaynode *) NULL) {
X      lefttree->rchild = righttree->lchild;
X      righttree->lchild = lefttree;
X      return righttree;
X    } else if (righttree->lchild == (struct splaynode *) NULL) {
X      righttree->lchild = lefttree->rchild;
X      lefttree->rchild = righttree;
X      return lefttree;
X    } else {
/*      printf("Holy Toledo!!!\n"); */
X      leftright = lefttree->rchild;
X      while (leftright->rchild != (struct splaynode *) NULL) {
X        leftright = leftright->rchild;
X      }
X      leftright->rchild = righttree;
X      return lefttree;
X    }
X  }
}
X
#endif /* not REDUCED */
X
#ifndef REDUCED
X
#ifdef ANSI_DECLARATORS
struct splaynode *splayinsert(struct mesh *m, struct splaynode *splayroot,
X                              struct otri *newkey, vertex searchpoint)
#else /* not ANSI_DECLARATORS */
struct splaynode *splayinsert(m, splayroot, newkey, searchpoint)
struct mesh *m;
struct splaynode *splayroot;
struct otri *newkey;
vertex searchpoint;
#endif /* not ANSI_DECLARATORS */
X
{
X  struct splaynode *newsplaynode;
X
X  newsplaynode = (struct splaynode *) poolalloc(&m->splaynodes);
X  otricopy(*newkey, newsplaynode->keyedge);
X  dest(*newkey, newsplaynode->keydest);
X  if (splayroot == (struct splaynode *) NULL) {
X    newsplaynode->lchild = (struct splaynode *) NULL;
X    newsplaynode->rchild = (struct splaynode *) NULL;
X  } else if (rightofhyperbola(m, &splayroot->keyedge, searchpoint)) {
X    newsplaynode->lchild = splayroot;
X    newsplaynode->rchild = splayroot->rchild;
X    splayroot->rchild = (struct splaynode *) NULL;
X  } else {
X    newsplaynode->lchild = splayroot->lchild;
X    newsplaynode->rchild = splayroot;
X    splayroot->lchild = (struct splaynode *) NULL;
X  }
X  return newsplaynode;
}
X
#endif /* not REDUCED */
X
#ifndef REDUCED
X
#ifdef ANSI_DECLARATORS
struct splaynode *circletopinsert(struct mesh *m, struct behavior *b,
X                                  struct splaynode *splayroot,
X                                  struct otri *newkey,
X                                  vertex pa, vertex pb, vertex pc, REAL topy)
#else /* not ANSI_DECLARATORS */
struct splaynode *circletopinsert(m, b, splayroot, newkey, pa, pb, pc, topy)
struct mesh *m;
struct behavior *b;
struct splaynode *splayroot;
struct otri *newkey;
vertex pa;
vertex pb;
vertex pc;
REAL topy;
#endif /* not ANSI_DECLARATORS */
X
{
X  REAL ccwabc;
X  REAL xac, yac, xbc, ybc;
X  REAL aclen2, bclen2;
X  REAL searchpoint[2];
X  struct otri dummytri;
X
X  ccwabc = counterclockwise(m, b, pa, pb, pc);
X  xac = pa[0] - pc[0];
X  yac = pa[1] - pc[1];
X  xbc = pb[0] - pc[0];
X  ybc = pb[1] - pc[1];
X  aclen2 = xac * xac + yac * yac;
X  bclen2 = xbc * xbc + ybc * ybc;
X  searchpoint[0] = pc[0] - (yac * bclen2 - ybc * aclen2) / (2.0 * ccwabc);
X  searchpoint[1] = topy;
X  return splayinsert(m, splay(m, splayroot, (vertex) searchpoint, &dummytri),
X                     newkey, (vertex) searchpoint);
}
X
#endif /* not REDUCED */
X
#ifndef REDUCED
X
#ifdef ANSI_DECLARATORS
struct splaynode *frontlocate(struct mesh *m, struct splaynode *splayroot,
X                              struct otri *bottommost, vertex searchvertex,
X                              struct otri *searchtri, int *farright)
#else /* not ANSI_DECLARATORS */
struct splaynode *frontlocate(m, splayroot, bottommost, searchvertex,
X                              searchtri, farright)
struct mesh *m;
struct splaynode *splayroot;
struct otri *bottommost;
vertex searchvertex;
struct otri *searchtri;
int *farright;
#endif /* not ANSI_DECLARATORS */
X
{
X  int farrightflag;
X  triangle ptr;                       /* Temporary variable used by onext(). */
X
X  otricopy(*bottommost, *searchtri);
X  splayroot = splay(m, splayroot, searchvertex, searchtri);
X
X  farrightflag = 0;
X  while (!farrightflag && rightofhyperbola(m, searchtri, searchvertex)) {
X    onextself(*searchtri);
X    farrightflag = otriequal(*searchtri, *bottommost);
X  }
X  *farright = farrightflag;
X  return splayroot;
}
X
#endif /* not REDUCED */
X
#ifndef REDUCED
X
#ifdef ANSI_DECLARATORS
long sweeplinedelaunay(struct mesh *m, struct behavior *b)
#else /* not ANSI_DECLARATORS */
long sweeplinedelaunay(m, b)
struct mesh *m;
struct behavior *b;
#endif /* not ANSI_DECLARATORS */
X
{
X  struct event **eventheap;
X  struct event *events;
X  struct event *freeevents;
X  struct event *nextevent;
X  struct event *newevent;
X  struct splaynode *splayroot;
X  struct otri bottommost;
X  struct otri searchtri;
X  struct otri fliptri;
X  struct otri lefttri, righttri, farlefttri, farrighttri;
X  struct otri inserttri;
X  vertex firstvertex, secondvertex;
X  vertex nextvertex, lastvertex;
X  vertex connectvertex;
X  vertex leftvertex, midvertex, rightvertex;
X  REAL lefttest, righttest;
X  int heapsize;
X  int check4events, farrightflag;
X  triangle ptr;   /* Temporary variable used by sym(), onext(), and oprev(). */
X
X  poolinit(&m->splaynodes, sizeof(struct splaynode), SPLAYNODEPERBLOCK,
X           SPLAYNODEPERBLOCK, 0);
X  splayroot = (struct splaynode *) NULL;
X
X  if (b->verbose) {
X    printf("  Placing vertices in event heap.\n");
X  }
X  createeventheap(m, &eventheap, &events, &freeevents);
X  heapsize = m->invertices;
X
X  if (b->verbose) {
X    printf("  Forming triangulation.\n");
X  }
X  maketriangle(m, b, &lefttri);
X  maketriangle(m, b, &righttri);
X  bond(lefttri, righttri);
X  lnextself(lefttri);
X  lprevself(righttri);
X  bond(lefttri, righttri);
X  lnextself(lefttri);
X  lprevself(righttri);
X  bond(lefttri, righttri);
X  firstvertex = (vertex) eventheap[0]->eventptr;
X  eventheap[0]->eventptr = (VOID *) freeevents;
X  freeevents = eventheap[0];
X  eventheapdelete(eventheap, heapsize, 0);
X  heapsize--;
X  do {
X    if (heapsize == 0) {
X      printf("Error:  Input vertices are all identical.\n");
X      triexit(1);
X    }
X    secondvertex = (vertex) eventheap[0]->eventptr;
X    eventheap[0]->eventptr = (VOID *) freeevents;
X    freeevents = eventheap[0];
X    eventheapdelete(eventheap, heapsize, 0);
X    heapsize--;
X    if ((firstvertex[0] == secondvertex[0]) &&
X        (firstvertex[1] == secondvertex[1])) {
X      if (!b->quiet) {
X        printf(
"Warning:  A duplicate vertex at (%.12g, %.12g) appeared and was ignored.\n",
X               secondvertex[0], secondvertex[1]);
X      }
X      setvertextype(secondvertex, UNDEADVERTEX);
X      m->undeads++;
X    }
X  } while ((firstvertex[0] == secondvertex[0]) &&
X           (firstvertex[1] == secondvertex[1]));
X  setorg(lefttri, firstvertex);
X  setdest(lefttri, secondvertex);
X  setorg(righttri, secondvertex);
X  setdest(righttri, firstvertex);
X  lprev(lefttri, bottommost);
X  lastvertex = secondvertex;
X  while (heapsize > 0) {
X    nextevent = eventheap[0];
X    eventheapdelete(eventheap, heapsize, 0);
X    heapsize--;
X    check4events = 1;
X    if (nextevent->xkey < m->xmin) {
X      decode(nextevent->eventptr, fliptri);
X      oprev(fliptri, farlefttri);
X      check4deadevent(&farlefttri, &freeevents, eventheap, &heapsize);
X      onext(fliptri, farrighttri);
X      check4deadevent(&farrighttri, &freeevents, eventheap, &heapsize);
X
X      if (otriequal(farlefttri, bottommost)) {
X        lprev(fliptri, bottommost);
X      }
X      flip(m, b, &fliptri);
X      setapex(fliptri, NULL);
X      lprev(fliptri, lefttri);
X      lnext(fliptri, righttri);
X      sym(lefttri, farlefttri);
X
X      if (randomnation(SAMPLERATE) == 0) {
X        symself(fliptri);
X        dest(fliptri, leftvertex);
X        apex(fliptri, midvertex);
X        org(fliptri, rightvertex);
X        splayroot = circletopinsert(m, b, splayroot, &lefttri, leftvertex,
X                                    midvertex, rightvertex, nextevent->ykey);
X      }
X    } else {
X      nextvertex = (vertex) nextevent->eventptr;
X      if ((nextvertex[0] == lastvertex[0]) &&
X          (nextvertex[1] == lastvertex[1])) {
X        if (!b->quiet) {
X          printf(
"Warning:  A duplicate vertex at (%.12g, %.12g) appeared and was ignored.\n",
X                 nextvertex[0], nextvertex[1]);
X        }
X        setvertextype(nextvertex, UNDEADVERTEX);
X        m->undeads++;
X        check4events = 0;
X      } else {
X        lastvertex = nextvertex;
X
X        splayroot = frontlocate(m, splayroot, &bottommost, nextvertex,
X                                &searchtri, &farrightflag);
/*
X        otricopy(bottommost, searchtri);
X        farrightflag = 0;
X        while (!farrightflag && rightofhyperbola(m, &searchtri, nextvertex)) {
X          onextself(searchtri);
X          farrightflag = otriequal(searchtri, bottommost);
X        }
*/
X
X        check4deadevent(&searchtri, &freeevents, eventheap, &heapsize);
X
X        otricopy(searchtri, farrighttri);
X        sym(searchtri, farlefttri);
X        maketriangle(m, b, &lefttri);
X        maketriangle(m, b, &righttri);
X        dest(farrighttri, connectvertex);
X        setorg(lefttri, connectvertex);
X        setdest(lefttri, nextvertex);
X        setorg(righttri, nextvertex);
X        setdest(righttri, connectvertex);
X        bond(lefttri, righttri);
X        lnextself(lefttri);
X        lprevself(righttri);
X        bond(lefttri, righttri);
X        lnextself(lefttri);
X        lprevself(righttri);
X        bond(lefttri, farlefttri);
X        bond(righttri, farrighttri);
X        if (!farrightflag && otriequal(farrighttri, bottommost)) {
X          otricopy(lefttri, bottommost);
X        }
X
X        if (randomnation(SAMPLERATE) == 0) {
X          splayroot = splayinsert(m, splayroot, &lefttri, nextvertex);
X        } else if (randomnation(SAMPLERATE) == 0) {
X          lnext(righttri, inserttri);
X          splayroot = splayinsert(m, splayroot, &inserttri, nextvertex);
X        }
X      }
X    }
X    nextevent->eventptr = (VOID *) freeevents;
X    freeevents = nextevent;
X
X    if (check4events) {
X      apex(farlefttri, leftvertex);
X      dest(lefttri, midvertex);
X      apex(lefttri, rightvertex);
X      lefttest = counterclockwise(m, b, leftvertex, midvertex, rightvertex);
X      if (lefttest > 0.0) {
X        newevent = freeevents;
X        freeevents = (struct event *) freeevents->eventptr;
X        newevent->xkey = m->xminextreme;
X        newevent->ykey = circletop(m, leftvertex, midvertex, rightvertex,
X                                   lefttest);
X        newevent->eventptr = (VOID *) encode(lefttri);
X        eventheapinsert(eventheap, heapsize, newevent);
X        heapsize++;
X        setorg(lefttri, newevent);
X      }
X      apex(righttri, leftvertex);
X      org(righttri, midvertex);
X      apex(farrighttri, rightvertex);
X      righttest = counterclockwise(m, b, leftvertex, midvertex, rightvertex);
X      if (righttest > 0.0) {
X        newevent = freeevents;
X        freeevents = (struct event *) freeevents->eventptr;
X        newevent->xkey = m->xminextreme;
X        newevent->ykey = circletop(m, leftvertex, midvertex, rightvertex,
X                                   righttest);
X        newevent->eventptr = (VOID *) encode(farrighttri);
X        eventheapinsert(eventheap, heapsize, newevent);
X        heapsize++;
X        setorg(farrighttri, newevent);
X      }
X    }
X  }
X
X  pooldeinit(&m->splaynodes);
X  lprevself(bottommost);
X  return removeghosts(m, b, &bottommost);
}
X
#endif /* not REDUCED */
X
/**                                                                         **/
/**                                                                         **/
/********* Sweepline Delaunay triangulation ends here                *********/
X
/********* General mesh construction routines begin here             *********/
/**                                                                         **/
/**                                                                         **/
X
/*****************************************************************************/
/*                                                                           */
/*  delaunay()   Form a Delaunay triangulation.                              */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
long delaunay(struct mesh *m, struct behavior *b)
#else /* not ANSI_DECLARATORS */
long delaunay(m, b)
struct mesh *m;
struct behavior *b;
#endif /* not ANSI_DECLARATORS */
X
{
X  long hulledges;
X
X  m->eextras = 0;
X  initializetrisubpools(m, b);
X
#ifdef REDUCED
X  if (!b->quiet) {
X    printf(
X      "Constructing Delaunay triangulation by divide-and-conquer method.\n");
X  }
X  hulledges = divconqdelaunay(m, b);
#else /* not REDUCED */
X  if (!b->quiet) {
X    printf("Constructing Delaunay triangulation ");
X    if (b->incremental) {
X      printf("by incremental method.\n");
X    } else if (b->sweepline) {
X      printf("by sweepline method.\n");
X    } else {
X      printf("by divide-and-conquer method.\n");
X    }
X  }
X  if (b->incremental) {
X    hulledges = incrementaldelaunay(m, b);
X  } else if (b->sweepline) {
X    hulledges = sweeplinedelaunay(m, b);
X  } else {
X    hulledges = divconqdelaunay(m, b);
X  }
#endif /* not REDUCED */
X
X  if (m->triangles.items == 0) {
X    /* The input vertices were all collinear, so there are no triangles. */
X    return 0l;
X  } else {
X    return hulledges;
X  }
}
X
/*****************************************************************************/
/*                                                                           */
/*  reconstruct()   Reconstruct a triangulation from its .ele (and possibly  */
/*                  .poly) file.  Used when the -r switch is used.           */
/*                                                                           */
/*  Reads an .ele file and reconstructs the original mesh.  If the -p switch */
/*  is used, this procedure will also read a .poly file and reconstruct the  */
/*  subsegments of the original mesh.  If the -a switch is used, this        */
/*  procedure will also read an .area file and set a maximum area constraint */
/*  on each triangle.                                                        */
/*                                                                           */
/*  Vertices that are not corners of triangles, such as nodes on edges of    */
/*  subparametric elements, are discarded.                                   */
/*                                                                           */
/*  This routine finds the adjacencies between triangles (and subsegments)   */
/*  by forming one stack of triangles for each vertex.  Each triangle is on  */
/*  three different stacks simultaneously.  Each triangle's subsegment       */
/*  pointers are used to link the items in each stack.  This memory-saving   */
/*  feature makes the code harder to read.  The most important thing to keep */
/*  in mind is that each triangle is removed from a stack precisely when     */
/*  the corresponding pointer is adjusted to refer to a subsegment rather    */
/*  than the next triangle of the stack.                                     */
/*                                                                           */
/*****************************************************************************/
X
#ifndef CDT_ONLY
X
#ifdef TRILIBRARY
X
#ifdef ANSI_DECLARATORS
int reconstruct(struct mesh *m, struct behavior *b, int *trianglelist,
X                REAL *triangleattriblist, REAL *trianglearealist,
X                int elements, int corners, int attribs,
X                int *segmentlist,int *segmentmarkerlist, int numberofsegments)
#else /* not ANSI_DECLARATORS */
int reconstruct(m, b, trianglelist, triangleattriblist, trianglearealist,
X                elements, corners, attribs, segmentlist, segmentmarkerlist,
X                numberofsegments)
struct mesh *m;
struct behavior *b;
int *trianglelist;
REAL *triangleattriblist;
REAL *trianglearealist;
int elements;
int corners;
int attribs;
int *segmentlist;
int *segmentmarkerlist;
int numberofsegments;
#endif /* not ANSI_DECLARATORS */
X
#else /* not TRILIBRARY */
X
#ifdef ANSI_DECLARATORS
long reconstruct(struct mesh *m, struct behavior *b, char *elefilename,
X                 char *areafilename, char *polyfilename, FILE *polyfile)
#else /* not ANSI_DECLARATORS */
long reconstruct(m, b, elefilename, areafilename, polyfilename, polyfile)
struct mesh *m;
struct behavior *b;
char *elefilename;
char *areafilename;
char *polyfilename;
FILE *polyfile;
#endif /* not ANSI_DECLARATORS */
X
#endif /* not TRILIBRARY */
X
{
#ifdef TRILIBRARY
X  int vertexindex;
X  int attribindex;
#else /* not TRILIBRARY */
X  FILE *elefile;
X  FILE *areafile;
X  char inputline[INPUTLINESIZE];
X  char *stringptr;
X  int areaelements;
#endif /* not TRILIBRARY */
X  struct otri triangleloop;
X  struct otri triangleleft;
X  struct otri checktri;
X  struct otri checkleft;
X  struct otri checkneighbor;
X  struct osub subsegloop;
X  triangle *vertexarray;
X  triangle *prevlink;
X  triangle nexttri;
X  vertex tdest, tapex;
X  vertex checkdest, checkapex;
X  vertex shorg;
X  vertex killvertex;
X  vertex segmentorg, segmentdest;
X  REAL area;
X  int corner[3];
X  int end[2];
X  int killvertexindex;
X  int incorners;
X  int segmentmarkers;
X  int boundmarker;
X  int aroundvertex;
X  long hullsize;
X  int notfound;
X  long elementnumber, segmentnumber;
X  int i, j;
X  triangle ptr;                         /* Temporary variable used by sym(). */
X
#ifdef TRILIBRARY
X  m->inelements = elements;
X  incorners = corners;
X  if (incorners < 3) {
X    printf("Error:  Triangles must have at least 3 vertices.\n");
X    triexit(1);
X  }
X  m->eextras = attribs;
#else /* not TRILIBRARY */
X  /* Read the triangles from an .ele file. */
X  if (!b->quiet) {
X    printf("Opening %s.\n", elefilename);
X  }
X  elefile = fopen(elefilename, "r");
X  if (elefile == (FILE *) NULL) {
X    printf("  Error:  Cannot access file %s.\n", elefilename);
X    triexit(1);
X  }
X  /* Read number of triangles, number of vertices per triangle, and */
X  /*   number of triangle attributes from .ele file.                */
X  stringptr = readline(inputline, elefile, elefilename);
X  m->inelements = (int) strtol(stringptr, &stringptr, 0);
X  stringptr = findfield(stringptr);
X  if (*stringptr == '\0') {
X    incorners = 3;
X  } else {
X    incorners = (int) strtol(stringptr, &stringptr, 0);
X    if (incorners < 3) {
X      printf("Error:  Triangles in %s must have at least 3 vertices.\n",
X             elefilename);
X      triexit(1);
X    }
X  }
X  stringptr = findfield(stringptr);
X  if (*stringptr == '\0') {
X    m->eextras = 0;
X  } else {
X    m->eextras = (int) strtol(stringptr, &stringptr, 0);
X  }
#endif /* not TRILIBRARY */
X
X  initializetrisubpools(m, b);
X
X  /* Create the triangles. */
X  for (elementnumber = 1; elementnumber <= m->inelements; elementnumber++) {
X    maketriangle(m, b, &triangleloop);
X    /* Mark the triangle as living. */
X    triangleloop.tri[3] = (triangle) triangleloop.tri;
X  }
X
X  segmentmarkers = 0;
X  if (b->poly) {
#ifdef TRILIBRARY
X    m->insegments = numberofsegments;
X    segmentmarkers = segmentmarkerlist != (int *) NULL;
#else /* not TRILIBRARY */
X    /* Read number of segments and number of segment */
X    /*   boundary markers from .poly file.           */
X    stringptr = readline(inputline, polyfile, b->inpolyfilename);
X    m->insegments = (int) strtol(stringptr, &stringptr, 0);
X    stringptr = findfield(stringptr);
X    if (*stringptr != '\0') {
X      segmentmarkers = (int) strtol(stringptr, &stringptr, 0);
X    }
#endif /* not TRILIBRARY */
X
X    /* Create the subsegments. */
X    for (segmentnumber = 1; segmentnumber <= m->insegments; segmentnumber++) {
X      makesubseg(m, &subsegloop);
X      /* Mark the subsegment as living. */
X      subsegloop.ss[2] = (subseg) subsegloop.ss;
X    }
X  }
X
#ifdef TRILIBRARY
X  vertexindex = 0;
X  attribindex = 0;
#else /* not TRILIBRARY */
X  if (b->vararea) {
X    /* Open an .area file, check for consistency with the .ele file. */
X    if (!b->quiet) {
X      printf("Opening %s.\n", areafilename);
X    }
X    areafile = fopen(areafilename, "r");
X    if (areafile == (FILE *) NULL) {
X      printf("  Error:  Cannot access file %s.\n", areafilename);
X      triexit(1);
X    }
X    stringptr = readline(inputline, areafile, areafilename);
X    areaelements = (int) strtol(stringptr, &stringptr, 0);
X    if (areaelements != m->inelements) {
X      printf("Error:  %s and %s disagree on number of triangles.\n",
X             elefilename, areafilename);
X      triexit(1);
X    }
X  }
#endif /* not TRILIBRARY */
X
X  if (!b->quiet) {
X    printf("Reconstructing mesh.\n");
X  }
X  /* Allocate a temporary array that maps each vertex to some adjacent */
X  /*   triangle.  I took care to allocate all the permanent memory for */
X  /*   triangles and subsegments first.                                */
X  vertexarray = (triangle *) trimalloc(m->vertices.items *
X                                       (int) sizeof(triangle));
X  /* Each vertex is initially unrepresented. */
X  for (i = 0; i < m->vertices.items; i++) {
X    vertexarray[i] = (triangle) m->dummytri;
X  }
X
X  if (b->verbose) {
X    printf("  Assembling triangles.\n");
X  }
X  /* Read the triangles from the .ele file, and link */
X  /*   together those that share an edge.            */
X  traversalinit(&m->triangles);
X  triangleloop.tri = triangletraverse(m);
X  elementnumber = b->firstnumber;
X  while (triangleloop.tri != (triangle *) NULL) {
#ifdef TRILIBRARY
X    /* Copy the triangle's three corners. */
X    for (j = 0; j < 3; j++) {
X      corner[j] = trianglelist[vertexindex++];
X      if ((corner[j] < b->firstnumber) ||
X          (corner[j] >= b->firstnumber + m->invertices)) {
X        printf("Error:  Triangle %ld has an invalid vertex index.\n",
X               elementnumber);
X        triexit(1);
X      }
X    }
#else /* not TRILIBRARY */
X    /* Read triangle number and the triangle's three corners. */
X    stringptr = readline(inputline, elefile, elefilename);
X    for (j = 0; j < 3; j++) {
X      stringptr = findfield(stringptr);
X      if (*stringptr == '\0') {
X        printf("Error:  Triangle %ld is missing vertex %d in %s.\n",
X               elementnumber, j + 1, elefilename);
X        triexit(1);
X      } else {
X        corner[j] = (int) strtol(stringptr, &stringptr, 0);
X        if ((corner[j] < b->firstnumber) ||
X            (corner[j] >= b->firstnumber + m->invertices)) {
X          printf("Error:  Triangle %ld has an invalid vertex index.\n",
X                 elementnumber);
X          triexit(1);
X        }
X      }
X    }
#endif /* not TRILIBRARY */
X
X    /* Find out about (and throw away) extra nodes. */
X    for (j = 3; j < incorners; j++) {
#ifdef TRILIBRARY
X      killvertexindex = trianglelist[vertexindex++];
#else /* not TRILIBRARY */
X      stringptr = findfield(stringptr);
X      if (*stringptr != '\0') {
X        killvertexindex = (int) strtol(stringptr, &stringptr, 0);
#endif /* not TRILIBRARY */
X        if ((killvertexindex >= b->firstnumber) &&
X            (killvertexindex < b->firstnumber + m->invertices)) {
X          /* Delete the non-corner vertex if it's not already deleted. */
X          killvertex = getvertex(m, b, killvertexindex);
X          if (vertextype(killvertex) != DEADVERTEX) {
X            vertexdealloc(m, killvertex);
X          }
X        }
#ifndef TRILIBRARY
X      }
#endif /* not TRILIBRARY */
X    }
X
X    /* Read the triangle's attributes. */
X    for (j = 0; j < m->eextras; j++) {
#ifdef TRILIBRARY
X      setelemattribute(triangleloop, j, triangleattriblist[attribindex++]);
#else /* not TRILIBRARY */
X      stringptr = findfield(stringptr);
X      if (*stringptr == '\0') {
X        setelemattribute(triangleloop, j, 0);
X      } else {
X        setelemattribute(triangleloop, j,
X                         (REAL) strtod(stringptr, &stringptr));
X      }
#endif /* not TRILIBRARY */
X    }
X
X    if (b->vararea) {
#ifdef TRILIBRARY
X      area = trianglearealist[elementnumber - b->firstnumber];
#else /* not TRILIBRARY */
X      /* Read an area constraint from the .area file. */
X      stringptr = readline(inputline, areafile, areafilename);
X      stringptr = findfield(stringptr);
X      if (*stringptr == '\0') {
X        area = -1.0;                      /* No constraint on this triangle. */
X      } else {
X        area = (REAL) strtod(stringptr, &stringptr);
X      }
#endif /* not TRILIBRARY */
X      setareabound(triangleloop, area);
X    }
X
X    /* Set the triangle's vertices. */
X    triangleloop.orient = 0;
X    setorg(triangleloop, getvertex(m, b, corner[0]));
X    setdest(triangleloop, getvertex(m, b, corner[1]));
X    setapex(triangleloop, getvertex(m, b, corner[2]));
X    /* Try linking the triangle to others that share these vertices. */
X    for (triangleloop.orient = 0; triangleloop.orient < 3;
X         triangleloop.orient++) {
X      /* Take the number for the origin of triangleloop. */
X      aroundvertex = corner[triangleloop.orient];
X      /* Look for other triangles having this vertex. */
X      nexttri = vertexarray[aroundvertex - b->firstnumber];
X      /* Link the current triangle to the next one in the stack. */
X      triangleloop.tri[6 + triangleloop.orient] = nexttri;
X      /* Push the current triangle onto the stack. */
X      vertexarray[aroundvertex - b->firstnumber] = encode(triangleloop);
X      decode(nexttri, checktri);
X      if (checktri.tri != m->dummytri) {
X        dest(triangleloop, tdest);
X        apex(triangleloop, tapex);
X        /* Look for other triangles that share an edge. */
X        do {
X          dest(checktri, checkdest);
X          apex(checktri, checkapex);
X          if (tapex == checkdest) {
X            /* The two triangles share an edge; bond them together. */
X            lprev(triangleloop, triangleleft);
X            bond(triangleleft, checktri);
X          }
X          if (tdest == checkapex) {
X            /* The two triangles share an edge; bond them together. */
X            lprev(checktri, checkleft);
X            bond(triangleloop, checkleft);
X          }
X          /* Find the next triangle in the stack. */
X          nexttri = checktri.tri[6 + checktri.orient];
X          decode(nexttri, checktri);
X        } while (checktri.tri != m->dummytri);
X      }
X    }
X    triangleloop.tri = triangletraverse(m);
X    elementnumber++;
X  }
X
#ifdef TRILIBRARY
X  vertexindex = 0;
#else /* not TRILIBRARY */
X  fclose(elefile);
X  if (b->vararea) {
X    fclose(areafile);
X  }
#endif /* not TRILIBRARY */
X
X  hullsize = 0;                      /* Prepare to count the boundary edges. */
X  if (b->poly) {
X    if (b->verbose) {
X      printf("  Marking segments in triangulation.\n");
X    }
X    /* Read the segments from the .poly file, and link them */
X    /*   to their neighboring triangles.                    */
X    boundmarker = 0;
X    traversalinit(&m->subsegs);
X    subsegloop.ss = subsegtraverse(m);
X    segmentnumber = b->firstnumber;
X    while (subsegloop.ss != (subseg *) NULL) {
#ifdef TRILIBRARY
X      end[0] = segmentlist[vertexindex++];
X      end[1] = segmentlist[vertexindex++];
X      if (segmentmarkers) {
X        boundmarker = segmentmarkerlist[segmentnumber - b->firstnumber];
X      }
#else /* not TRILIBRARY */
X      /* Read the endpoints of each segment, and possibly a boundary marker. */
X      stringptr = readline(inputline, polyfile, b->inpolyfilename);
X      /* Skip the first (segment number) field. */
X      stringptr = findfield(stringptr);
X      if (*stringptr == '\0') {
X        printf("Error:  Segment %ld has no endpoints in %s.\n", segmentnumber,
X               polyfilename);
X        triexit(1);
X      } else {
X        end[0] = (int) strtol(stringptr, &stringptr, 0);
X      }
X      stringptr = findfield(stringptr);
X      if (*stringptr == '\0') {
X        printf("Error:  Segment %ld is missing its second endpoint in %s.\n",
X               segmentnumber, polyfilename);
X        triexit(1);
X      } else {
X        end[1] = (int) strtol(stringptr, &stringptr, 0);
X      }
X      if (segmentmarkers) {
X        stringptr = findfield(stringptr);
X        if (*stringptr == '\0') {
X          boundmarker = 0;
X        } else {
X          boundmarker = (int) strtol(stringptr, &stringptr, 0);
X        }
X      }
#endif /* not TRILIBRARY */
X      for (j = 0; j < 2; j++) {
X        if ((end[j] < b->firstnumber) ||
X            (end[j] >= b->firstnumber + m->invertices)) {
X          printf("Error:  Segment %ld has an invalid vertex index.\n", 
X                 segmentnumber);
X          triexit(1);
X        }
X      }
X
X      /* set the subsegment's vertices. */
X      subsegloop.ssorient = 0;
X      segmentorg = getvertex(m, b, end[0]);
X      segmentdest = getvertex(m, b, end[1]);
X      setsorg(subsegloop, segmentorg);
X      setsdest(subsegloop, segmentdest);
X      setsegorg(subsegloop, segmentorg);
X      setsegdest(subsegloop, segmentdest);
X      setmark(subsegloop, boundmarker);
X      /* Try linking the subsegment to triangles that share these vertices. */
X      for (subsegloop.ssorient = 0; subsegloop.ssorient < 2;
X           subsegloop.ssorient++) {
X        /* Take the number for the destination of subsegloop. */
X        aroundvertex = end[1 - subsegloop.ssorient];
X        /* Look for triangles having this vertex. */
X        prevlink = &vertexarray[aroundvertex - b->firstnumber];
X        nexttri = vertexarray[aroundvertex - b->firstnumber];
X        decode(nexttri, checktri);
X        sorg(subsegloop, shorg);
X        notfound = 1;
X        /* Look for triangles having this edge.  Note that I'm only       */
X        /*   comparing each triangle's destination with the subsegment;   */
X        /*   each triangle's apex is handled through a different vertex.  */
X        /*   Because each triangle appears on three vertices' lists, each */
X        /*   occurrence of a triangle on a list can (and does) represent  */
X        /*   an edge.  In this way, most edges are represented twice, and */
X        /*   every triangle-subsegment bond is represented once.          */
X        while (notfound && (checktri.tri != m->dummytri)) {
X          dest(checktri, checkdest);
X          if (shorg == checkdest) {
X            /* We have a match.  Remove this triangle from the list. */
X            *prevlink = checktri.tri[6 + checktri.orient];
X            /* Bond the subsegment to the triangle. */
X            tsbond(checktri, subsegloop);
X            /* Check if this is a boundary edge. */
X            sym(checktri, checkneighbor);
X            if (checkneighbor.tri == m->dummytri) {
X              /* The next line doesn't insert a subsegment (because there's */
X              /*   already one there), but it sets the boundary markers of  */
X              /*   the existing subsegment and its vertices.                */
X              insertsubseg(m, b, &checktri, 1);
X              hullsize++;
X            }
X            notfound = 0;
X          }
X          /* Find the next triangle in the stack. */
X          prevlink = &checktri.tri[6 + checktri.orient];
X          nexttri = checktri.tri[6 + checktri.orient];
X          decode(nexttri, checktri);
X        }
X      }
X      subsegloop.ss = subsegtraverse(m);
X      segmentnumber++;
X    }
X  }
X
X  /* Mark the remaining edges as not being attached to any subsegment. */
X  /* Also, count the (yet uncounted) boundary edges.                   */
X  for (i = 0; i < m->vertices.items; i++) {
X    /* Search the stack of triangles adjacent to a vertex. */
X    nexttri = vertexarray[i];
X    decode(nexttri, checktri);
X    while (checktri.tri != m->dummytri) {
X      /* Find the next triangle in the stack before this */
X      /*   information gets overwritten.                 */
X      nexttri = checktri.tri[6 + checktri.orient];
X      /* No adjacent subsegment.  (This overwrites the stack info.) */
X      tsdissolve(checktri);
X      sym(checktri, checkneighbor);
X      if (checkneighbor.tri == m->dummytri) {
X        insertsubseg(m, b, &checktri, 1);
X        hullsize++;
X      }
X      decode(nexttri, checktri);
X    }
X  }
X
X  trifree((VOID *) vertexarray);
X  return hullsize;
}
X
#endif /* not CDT_ONLY */
X
/**                                                                         **/
/**                                                                         **/
/********* General mesh construction routines end here               *********/
X
/********* Segment insertion begins here                             *********/
/**                                                                         **/
/**                                                                         **/
X
/*****************************************************************************/
/*                                                                           */
/*  finddirection()   Find the first triangle on the path from one point     */
/*                    to another.                                            */
/*                                                                           */
/*  Finds the triangle that intersects a line segment drawn from the         */
/*  origin of `searchtri' to the point `searchpoint', and returns the result */
/*  in `searchtri'.  The origin of `searchtri' does not change, even though  */
/*  the triangle returned may differ from the one passed in.  This routine   */
/*  is used to find the direction to move in to get from one point to        */
/*  another.                                                                 */
/*                                                                           */
/*  The return value notes whether the destination or apex of the found      */
/*  triangle is collinear with the two points in question.                   */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
enum finddirectionresult finddirection(struct mesh *m, struct behavior *b,
X                                       struct otri *searchtri,
X                                       vertex searchpoint)
#else /* not ANSI_DECLARATORS */
enum finddirectionresult finddirection(m, b, searchtri, searchpoint)
struct mesh *m;
struct behavior *b;
struct otri *searchtri;
vertex searchpoint;
#endif /* not ANSI_DECLARATORS */
X
{
X  struct otri checktri;
X  vertex startvertex;
X  vertex leftvertex, rightvertex;
X  REAL leftccw, rightccw;
X  int leftflag, rightflag;
X  triangle ptr;           /* Temporary variable used by onext() and oprev(). */
X
X  org(*searchtri, startvertex);
X  dest(*searchtri, rightvertex);
X  apex(*searchtri, leftvertex);
X  /* Is `searchpoint' to the left? */
X  leftccw = counterclockwise(m, b, searchpoint, startvertex, leftvertex);
X  leftflag = leftccw > 0.0;
X  /* Is `searchpoint' to the right? */
X  rightccw = counterclockwise(m, b, startvertex, searchpoint, rightvertex);
X  rightflag = rightccw > 0.0;
X  if (leftflag && rightflag) {
X    /* `searchtri' faces directly away from `searchpoint'.  We could go left */
X    /*   or right.  Ask whether it's a triangle or a boundary on the left.   */
X    onext(*searchtri, checktri);
X    if (checktri.tri == m->dummytri) {
X      leftflag = 0;
X    } else {
X      rightflag = 0;
X    }
X  }
X  while (leftflag) {
X    /* Turn left until satisfied. */
X    onextself(*searchtri);
X    if (searchtri->tri == m->dummytri) {
X      printf("Internal error in finddirection():  Unable to find a\n");
X      printf("  triangle leading from (%.12g, %.12g) to", startvertex[0],
X             startvertex[1]);
X      printf("  (%.12g, %.12g).\n", searchpoint[0], searchpoint[1]);
X      internalerror();
X    }
X    apex(*searchtri, leftvertex);
X    rightccw = leftccw;
X    leftccw = counterclockwise(m, b, searchpoint, startvertex, leftvertex);
X    leftflag = leftccw > 0.0;
X  }
X  while (rightflag) {
X    /* Turn right until satisfied. */
X    oprevself(*searchtri);
X    if (searchtri->tri == m->dummytri) {
X      printf("Internal error in finddirection():  Unable to find a\n");
X      printf("  triangle leading from (%.12g, %.12g) to", startvertex[0],
X             startvertex[1]);
X      printf("  (%.12g, %.12g).\n", searchpoint[0], searchpoint[1]);
X      internalerror();
X    }
X    dest(*searchtri, rightvertex);
X    leftccw = rightccw;
X    rightccw = counterclockwise(m, b, startvertex, searchpoint, rightvertex);
X    rightflag = rightccw > 0.0;
X  }
X  if (leftccw == 0.0) {
X    return LEFTCOLLINEAR;
X  } else if (rightccw == 0.0) {
X    return RIGHTCOLLINEAR;
X  } else {
X    return WITHIN;
X  }
}
X
/*****************************************************************************/
/*                                                                           */
/*  segmentintersection()   Find the intersection of an existing segment     */
/*                          and a segment that is being inserted.  Insert    */
/*                          a vertex at the intersection, splitting an       */
/*                          existing subsegment.                             */
/*                                                                           */
/*  The segment being inserted connects the apex of splittri to endpoint2.   */
/*  splitsubseg is the subsegment being split, and MUST adjoin splittri.     */
/*  Hence, endpoints of the subsegment being split are the origin and        */
/*  destination of splittri.                                                 */
/*                                                                           */
/*  On completion, splittri is a handle having the newly inserted            */
/*  intersection point as its origin, and endpoint1 as its destination.      */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
void segmentintersection(struct mesh *m, struct behavior *b,
X                         struct otri *splittri, struct osub *splitsubseg,
X                         vertex endpoint2)
#else /* not ANSI_DECLARATORS */
void segmentintersection(m, b, splittri, splitsubseg, endpoint2)
struct mesh *m;
struct behavior *b;
struct otri *splittri;
struct osub *splitsubseg;
vertex endpoint2;
#endif /* not ANSI_DECLARATORS */
X
{
X  struct osub opposubseg;
X  vertex endpoint1;
X  vertex torg, tdest;
X  vertex leftvertex, rightvertex;
X  vertex newvertex;
X  enum insertvertexresult success;
X  enum finddirectionresult collinear;
X  REAL ex, ey;
X  REAL tx, ty;
X  REAL etx, ety;
X  REAL split, denom;
X  int i;
X  triangle ptr;                       /* Temporary variable used by onext(). */
X  subseg sptr;                        /* Temporary variable used by snext(). */
X
X  /* Find the other three segment endpoints. */
X  apex(*splittri, endpoint1);
X  org(*splittri, torg);
X  dest(*splittri, tdest);
X  /* Segment intersection formulae; see the Antonio reference. */
X  tx = tdest[0] - torg[0];
X  ty = tdest[1] - torg[1];
X  ex = endpoint2[0] - endpoint1[0];
X  ey = endpoint2[1] - endpoint1[1];
X  etx = torg[0] - endpoint2[0];
X  ety = torg[1] - endpoint2[1];
X  denom = ty * ex - tx * ey;
X  if (denom == 0.0) {
X    printf("Internal error in segmentintersection():");
X    printf("  Attempt to find intersection of parallel segments.\n");
X    internalerror();
X  }
X  split = (ey * etx - ex * ety) / denom;
X  /* Create the new vertex. */
X  newvertex = (vertex) poolalloc(&m->vertices);
X  /* Interpolate its coordinate and attributes. */
X  for (i = 0; i < 2 + m->nextras; i++) {
X    newvertex[i] = torg[i] + split * (tdest[i] - torg[i]);
X  }
X  setvertexmark(newvertex, mark(*splitsubseg));
X  setvertextype(newvertex, INPUTVERTEX);
X  if (b->verbose > 1) {
X    printf(
X  "  Splitting subsegment (%.12g, %.12g) (%.12g, %.12g) at (%.12g, %.12g).\n",
X           torg[0], torg[1], tdest[0], tdest[1], newvertex[0], newvertex[1]);
X  }
X  /* Insert the intersection vertex.  This should always succeed. */
X  success = insertvertex(m, b, newvertex, splittri, splitsubseg, 0, 0);
X  if (success != SUCCESSFULVERTEX) {
X    printf("Internal error in segmentintersection():\n");
X    printf("  Failure to split a segment.\n");
X    internalerror();
X  }
X  /* Record a triangle whose origin is the new vertex. */
X  setvertex2tri(newvertex, encode(*splittri));
X  if (m->steinerleft > 0) {
X    m->steinerleft--;
X  }
X
X  /* Divide the segment into two, and correct the segment endpoints. */
X  ssymself(*splitsubseg);
X  spivot(*splitsubseg, opposubseg);
X  sdissolve(*splitsubseg);
X  sdissolve(opposubseg);
X  do {
X    setsegorg(*splitsubseg, newvertex);
X    snextself(*splitsubseg);
X  } while (splitsubseg->ss != m->dummysub);
X  do {
X    setsegorg(opposubseg, newvertex);
X    snextself(opposubseg);
X  } while (opposubseg.ss != m->dummysub);
X
X  /* Inserting the vertex may have caused edge flips.  We wish to rediscover */
X  /*   the edge connecting endpoint1 to the new intersection vertex.         */
X  collinear = finddirection(m, b, splittri, endpoint1);
X  dest(*splittri, rightvertex);
X  apex(*splittri, leftvertex);
X  if ((leftvertex[0] == endpoint1[0]) && (leftvertex[1] == endpoint1[1])) {
X    onextself(*splittri);
X  } else if ((rightvertex[0] != endpoint1[0]) ||
X             (rightvertex[1] != endpoint1[1])) {
X    printf("Internal error in segmentintersection():\n");
X    printf("  Topological inconsistency after splitting a segment.\n");
X    internalerror();
X  }
X  /* `splittri' should have destination endpoint1. */
}
X
/*****************************************************************************/
/*                                                                           */
/*  scoutsegment()   Scout the first triangle on the path from one endpoint  */
/*                   to another, and check for completion (reaching the      */
/*                   second endpoint), a collinear vertex, or the            */
/*                   intersection of two segments.                           */
/*                                                                           */
/*  Returns one if the entire segment is successfully inserted, and zero if  */
/*  the job must be finished by conformingedge() or constrainededge().       */
/*                                                                           */
/*  If the first triangle on the path has the second endpoint as its         */
/*  destination or apex, a subsegment is inserted and the job is done.       */
/*                                                                           */
/*  If the first triangle on the path has a destination or apex that lies on */
/*  the segment, a subsegment is inserted connecting the first endpoint to   */
/*  the collinear vertex, and the search is continued from the collinear     */
/*  vertex.                                                                  */
/*                                                                           */
/*  If the first triangle on the path has a subsegment opposite its origin,  */
/*  then there is a segment that intersects the segment being inserted.      */
/*  Their intersection vertex is inserted, splitting the subsegment.         */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
int scoutsegment(struct mesh *m, struct behavior *b, struct otri *searchtri,
X                 vertex endpoint2, int newmark)
#else /* not ANSI_DECLARATORS */
int scoutsegment(m, b, searchtri, endpoint2, newmark)
struct mesh *m;
struct behavior *b;
struct otri *searchtri;
vertex endpoint2;
int newmark;
#endif /* not ANSI_DECLARATORS */
X
{
X  struct otri crosstri;
X  struct osub crosssubseg;
X  vertex leftvertex, rightvertex;
X  enum finddirectionresult collinear;
X  subseg sptr;                      /* Temporary variable used by tspivot(). */
X
X  collinear = finddirection(m, b, searchtri, endpoint2);
X  dest(*searchtri, rightvertex);
X  apex(*searchtri, leftvertex);
X  if (((leftvertex[0] == endpoint2[0]) && (leftvertex[1] == endpoint2[1])) ||
X      ((rightvertex[0] == endpoint2[0]) && (rightvertex[1] == endpoint2[1]))) {
X    /* The segment is already an edge in the mesh. */
X    if ((leftvertex[0] == endpoint2[0]) && (leftvertex[1] == endpoint2[1])) {
X      lprevself(*searchtri);
X    }
X    /* Insert a subsegment, if there isn't already one there. */
X    insertsubseg(m, b, searchtri, newmark);
X    return 1;
X  } else if (collinear == LEFTCOLLINEAR) {
X    /* We've collided with a vertex between the segment's endpoints. */
X    /* Make the collinear vertex be the triangle's origin. */
X    lprevself(*searchtri);
X    insertsubseg(m, b, searchtri, newmark);
X    /* Insert the remainder of the segment. */
X    return scoutsegment(m, b, searchtri, endpoint2, newmark);
X  } else if (collinear == RIGHTCOLLINEAR) {
X    /* We've collided with a vertex between the segment's endpoints. */
X    insertsubseg(m, b, searchtri, newmark);
X    /* Make the collinear vertex be the triangle's origin. */
X    lnextself(*searchtri);
X    /* Insert the remainder of the segment. */
X    return scoutsegment(m, b, searchtri, endpoint2, newmark);
X  } else {
X    lnext(*searchtri, crosstri);
X    tspivot(crosstri, crosssubseg);
X    /* Check for a crossing segment. */
X    if (crosssubseg.ss == m->dummysub) {
X      return 0;
X    } else {
X      /* Insert a vertex at the intersection. */
X      segmentintersection(m, b, &crosstri, &crosssubseg, endpoint2);
X      otricopy(crosstri, *searchtri);
X      insertsubseg(m, b, searchtri, newmark);
X      /* Insert the remainder of the segment. */
X      return scoutsegment(m, b, searchtri, endpoint2, newmark);
X    }
X  }
}
X
/*****************************************************************************/
/*                                                                           */
/*  conformingedge()   Force a segment into a conforming Delaunay            */
/*                     triangulation by inserting a vertex at its midpoint,  */
/*                     and recursively forcing in the two half-segments if   */
/*                     necessary.                                            */
/*                                                                           */
/*  Generates a sequence of subsegments connecting `endpoint1' to            */
/*  `endpoint2'.  `newmark' is the boundary marker of the segment, assigned  */
/*  to each new splitting vertex and subsegment.                             */
/*                                                                           */
/*  Note that conformingedge() does not always maintain the conforming       */
/*  Delaunay property.  Once inserted, segments are locked into place;       */
/*  vertices inserted later (to force other segments in) may render these    */
/*  fixed segments non-Delaunay.  The conforming Delaunay property will be   */
/*  restored by enforcequality() by splitting encroached subsegments.        */
/*                                                                           */
/*****************************************************************************/
X
#ifndef REDUCED
#ifndef CDT_ONLY
X
#ifdef ANSI_DECLARATORS
void conformingedge(struct mesh *m, struct behavior *b,
X                    vertex endpoint1, vertex endpoint2, int newmark)
#else /* not ANSI_DECLARATORS */
void conformingedge(m, b, endpoint1, endpoint2, newmark)
struct mesh *m;
struct behavior *b;
vertex endpoint1;
vertex endpoint2;
int newmark;
#endif /* not ANSI_DECLARATORS */
X
{
X  struct otri searchtri1, searchtri2;
X  struct osub brokensubseg;
X  vertex newvertex;
X  vertex midvertex1, midvertex2;
X  enum insertvertexresult success;
X  int i;
X  subseg sptr;                      /* Temporary variable used by tspivot(). */
X
X  if (b->verbose > 2) {
X    printf("Forcing segment into triangulation by recursive splitting:\n");
X    printf("  (%.12g, %.12g) (%.12g, %.12g)\n", endpoint1[0], endpoint1[1],
X           endpoint2[0], endpoint2[1]);
X  }
X  /* Create a new vertex to insert in the middle of the segment. */
X  newvertex = (vertex) poolalloc(&m->vertices);
X  /* Interpolate coordinates and attributes. */
X  for (i = 0; i < 2 + m->nextras; i++) {
X    newvertex[i] = 0.5 * (endpoint1[i] + endpoint2[i]);
X  }
X  setvertexmark(newvertex, newmark);
X  setvertextype(newvertex, SEGMENTVERTEX);
X  /* No known triangle to search from. */
X  searchtri1.tri = m->dummytri;
X  /* Attempt to insert the new vertex. */
X  success = insertvertex(m, b, newvertex, &searchtri1, (struct osub *) NULL,
X                         0, 0);
X  if (success == DUPLICATEVERTEX) {
X    if (b->verbose > 2) {
X      printf("  Segment intersects existing vertex (%.12g, %.12g).\n",
X             newvertex[0], newvertex[1]);
X    }
X    /* Use the vertex that's already there. */
X    vertexdealloc(m, newvertex);
X    org(searchtri1, newvertex);
X  } else {
X    if (success == VIOLATINGVERTEX) {
X      if (b->verbose > 2) {
X        printf("  Two segments intersect at (%.12g, %.12g).\n",
X               newvertex[0], newvertex[1]);
X      }
X      /* By fluke, we've landed right on another segment.  Split it. */
X      tspivot(searchtri1, brokensubseg);
X      success = insertvertex(m, b, newvertex, &searchtri1, &brokensubseg,
X                             0, 0);
X      if (success != SUCCESSFULVERTEX) {
X        printf("Internal error in conformingedge():\n");
X        printf("  Failure to split a segment.\n");
X        internalerror();
X      }
X    }
X    /* The vertex has been inserted successfully. */
X    if (m->steinerleft > 0) {
X      m->steinerleft--;
X    }
X  }
X  otricopy(searchtri1, searchtri2);
X  /* `searchtri1' and `searchtri2' are fastened at their origins to         */
X  /*   `newvertex', and will be directed toward `endpoint1' and `endpoint2' */
X  /*   respectively.  First, we must get `searchtri2' out of the way so it  */
X  /*   won't be invalidated during the insertion of the first half of the   */
X  /*   segment.                                                             */
X  finddirection(m, b, &searchtri2, endpoint2);
X  if (!scoutsegment(m, b, &searchtri1, endpoint1, newmark)) {
X    /* The origin of searchtri1 may have changed if a collision with an */
X    /*   intervening vertex on the segment occurred.                    */
X    org(searchtri1, midvertex1);
X    conformingedge(m, b, midvertex1, endpoint1, newmark);
X  }
X  if (!scoutsegment(m, b, &searchtri2, endpoint2, newmark)) {
X    /* The origin of searchtri2 may have changed if a collision with an */
X    /*   intervening vertex on the segment occurred.                    */
X    org(searchtri2, midvertex2);
X    conformingedge(m, b, midvertex2, endpoint2, newmark);
X  }
}
X
#endif /* not CDT_ONLY */
#endif /* not REDUCED */
X
/*****************************************************************************/
/*                                                                           */
/*  delaunayfixup()   Enforce the Delaunay condition at an edge, fanning out */
/*                    recursively from an existing vertex.  Pay special      */
/*                    attention to stacking inverted triangles.              */
/*                                                                           */
/*  This is a support routine for inserting segments into a constrained      */
/*  Delaunay triangulation.                                                  */
/*                                                                           */
/*  The origin of fixuptri is treated as if it has just been inserted, and   */
/*  the local Delaunay condition needs to be enforced.  It is only enforced  */
/*  in one sector, however, that being the angular range defined by          */
/*  fixuptri.                                                                */
/*                                                                           */
/*  This routine also needs to make decisions regarding the "stacking" of    */
/*  triangles.  (Read the description of constrainededge() below before      */
/*  reading on here, so you understand the algorithm.)  If the position of   */
/*  the new vertex (the origin of fixuptri) indicates that the vertex before */
/*  it on the polygon is a reflex vertex, then "stack" the triangle by       */
/*  doing nothing.  (fixuptri is an inverted triangle, which is how stacked  */
/*  triangles are identified.)                                               */
/*                                                                           */
/*  Otherwise, check whether the vertex before that was a reflex vertex.     */
/*  If so, perform an edge flip, thereby eliminating an inverted triangle    */
/*  (popping it off the stack).  The edge flip may result in the creation    */
/*  of a new inverted triangle, depending on whether or not the new vertex   */
/*  is visible to the vertex three edges behind on the polygon.              */
/*                                                                           */
/*  If neither of the two vertices behind the new vertex are reflex          */
/*  vertices, fixuptri and fartri, the triangle opposite it, are not         */
/*  inverted; hence, ensure that the edge between them is locally Delaunay.  */
/*                                                                           */
/*  `leftside' indicates whether or not fixuptri is to the left of the       */
/*  segment being inserted.  (Imagine that the segment is pointing up from   */
/*  endpoint1 to endpoint2.)                                                 */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
void delaunayfixup(struct mesh *m, struct behavior *b,
X                   struct otri *fixuptri, int leftside)
#else /* not ANSI_DECLARATORS */
void delaunayfixup(m, b, fixuptri, leftside)
struct mesh *m;
struct behavior *b;
struct otri *fixuptri;
int leftside;
#endif /* not ANSI_DECLARATORS */
X
{
X  struct otri neartri;
X  struct otri fartri;
X  struct osub faredge;
X  vertex nearvertex, leftvertex, rightvertex, farvertex;
X  triangle ptr;                         /* Temporary variable used by sym(). */
X  subseg sptr;                      /* Temporary variable used by tspivot(). */
X
X  lnext(*fixuptri, neartri);
X  sym(neartri, fartri);
X  /* Check if the edge opposite the origin of fixuptri can be flipped. */
X  if (fartri.tri == m->dummytri) {
X    return;
X  }
X  tspivot(neartri, faredge);
X  if (faredge.ss != m->dummysub) {
X    return;
X  }
X  /* Find all the relevant vertices. */
X  apex(neartri, nearvertex);
X  org(neartri, leftvertex);
X  dest(neartri, rightvertex);
X  apex(fartri, farvertex);
X  /* Check whether the previous polygon vertex is a reflex vertex. */
X  if (leftside) {
X    if (counterclockwise(m, b, nearvertex, leftvertex, farvertex) <= 0.0) {
X      /* leftvertex is a reflex vertex too.  Nothing can */
X      /*   be done until a convex section is found.      */
X      return;
X    }
X  } else {
X    if (counterclockwise(m, b, farvertex, rightvertex, nearvertex) <= 0.0) {
X      /* rightvertex is a reflex vertex too.  Nothing can */
X      /*   be done until a convex section is found.       */
X      return;
X    }
X  }
X  if (counterclockwise(m, b, rightvertex, leftvertex, farvertex) > 0.0) {
X    /* fartri is not an inverted triangle, and farvertex is not a reflex */
X    /*   vertex.  As there are no reflex vertices, fixuptri isn't an     */
X    /*   inverted triangle, either.  Hence, test the edge between the    */
X    /*   triangles to ensure it is locally Delaunay.                     */
X    if (incircle(m, b, leftvertex, farvertex, rightvertex, nearvertex) <=
X        0.0) {
X      return;
X    }
X    /* Not locally Delaunay; go on to an edge flip. */
X  }        /* else fartri is inverted; remove it from the stack by flipping. */
X  flip(m, b, &neartri);
X  lprevself(*fixuptri);    /* Restore the origin of fixuptri after the flip. */
X  /* Recursively process the two triangles that result from the flip. */
X  delaunayfixup(m, b, fixuptri, leftside);
X  delaunayfixup(m, b, &fartri, leftside);
}
X
/*****************************************************************************/
/*                                                                           */
/*  constrainededge()   Force a segment into a constrained Delaunay          */
/*                      triangulation by deleting the triangles it           */
/*                      intersects, and triangulating the polygons that      */
/*                      form on each side of it.                             */
/*                                                                           */
/*  Generates a single subsegment connecting `endpoint1' to `endpoint2'.     */
/*  The triangle `starttri' has `endpoint1' as its origin.  `newmark' is the */
/*  boundary marker of the segment.                                          */
/*                                                                           */
/*  To insert a segment, every triangle whose interior intersects the        */
/*  segment is deleted.  The union of these deleted triangles is a polygon   */
/*  (which is not necessarily monotone, but is close enough), which is       */
/*  divided into two polygons by the new segment.  This routine's task is    */
/*  to generate the Delaunay triangulation of these two polygons.            */
/*                                                                           */
/*  You might think of this routine's behavior as a two-step process.  The   */
/*  first step is to walk from endpoint1 to endpoint2, flipping each edge    */
/*  encountered.  This step creates a fan of edges connected to endpoint1,   */
/*  including the desired edge to endpoint2.  The second step enforces the   */
/*  Delaunay condition on each side of the segment in an incremental manner: */
/*  proceeding along the polygon from endpoint1 to endpoint2 (this is done   */
/*  independently on each side of the segment), each vertex is "enforced"    */
/*  as if it had just been inserted, but affecting only the previous         */
/*  vertices.  The result is the same as if the vertices had been inserted   */
/*  in the order they appear on the polygon, so the result is Delaunay.      */
/*                                                                           */
/*  In truth, constrainededge() interleaves these two steps.  The procedure  */
/*  walks from endpoint1 to endpoint2, and each time an edge is encountered  */
/*  and flipped, the newly exposed vertex (at the far end of the flipped     */
/*  edge) is "enforced" upon the previously flipped edges, usually affecting */
/*  only one side of the polygon (depending upon which side of the segment   */
/*  the vertex falls on).                                                    */
/*                                                                           */
/*  The algorithm is complicated by the need to handle polygons that are not */
/*  convex.  Although the polygon is not necessarily monotone, it can be     */
/*  triangulated in a manner similar to the stack-based algorithms for       */
/*  monotone polygons.  For each reflex vertex (local concavity) of the      */
/*  polygon, there will be an inverted triangle formed by one of the edge    */
/*  flips.  (An inverted triangle is one with negative area - that is, its   */
/*  vertices are arranged in clockwise order - and is best thought of as a   */
/*  wrinkle in the fabric of the mesh.)  Each inverted triangle can be       */
/*  thought of as a reflex vertex pushed on the stack, waiting to be fixed   */
/*  later.                                                                   */
/*                                                                           */
/*  A reflex vertex is popped from the stack when a vertex is inserted that  */
/*  is visible to the reflex vertex.  (However, if the vertex behind the     */
/*  reflex vertex is not visible to the reflex vertex, a new inverted        */
/*  triangle will take its place on the stack.)  These details are handled   */
/*  by the delaunayfixup() routine above.                                    */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
void constrainededge(struct mesh *m, struct behavior *b,
X                     struct otri *starttri, vertex endpoint2, int newmark)
#else /* not ANSI_DECLARATORS */
void constrainededge(m, b, starttri, endpoint2, newmark)
struct mesh *m;
struct behavior *b;
struct otri *starttri;
vertex endpoint2;
int newmark;
#endif /* not ANSI_DECLARATORS */
X
{
X  struct otri fixuptri, fixuptri2;
X  struct osub crosssubseg;
X  vertex endpoint1;
X  vertex farvertex;
X  REAL area;
X  int collision;
X  int done;
X  triangle ptr;             /* Temporary variable used by sym() and oprev(). */
X  subseg sptr;                      /* Temporary variable used by tspivot(). */
X
X  org(*starttri, endpoint1);
X  lnext(*starttri, fixuptri);
X  flip(m, b, &fixuptri);
X  /* `collision' indicates whether we have found a vertex directly */
X  /*   between endpoint1 and endpoint2.                            */
X  collision = 0;
X  done = 0;
X  do {
X    org(fixuptri, farvertex);
X    /* `farvertex' is the extreme point of the polygon we are "digging" */
X    /*   to get from endpoint1 to endpoint2.                           */
X    if ((farvertex[0] == endpoint2[0]) && (farvertex[1] == endpoint2[1])) {
X      oprev(fixuptri, fixuptri2);
X      /* Enforce the Delaunay condition around endpoint2. */
X      delaunayfixup(m, b, &fixuptri, 0);
X      delaunayfixup(m, b, &fixuptri2, 1);
X      done = 1;
X    } else {
X      /* Check whether farvertex is to the left or right of the segment */
X      /*   being inserted, to decide which edge of fixuptri to dig      */
X      /*   through next.                                                */
X      area = counterclockwise(m, b, endpoint1, endpoint2, farvertex);
X      if (area == 0.0) {
X        /* We've collided with a vertex between endpoint1 and endpoint2. */
X        collision = 1;
X        oprev(fixuptri, fixuptri2);
X        /* Enforce the Delaunay condition around farvertex. */
X        delaunayfixup(m, b, &fixuptri, 0);
X        delaunayfixup(m, b, &fixuptri2, 1);
X        done = 1;
X      } else {
X        if (area > 0.0) {        /* farvertex is to the left of the segment. */
X          oprev(fixuptri, fixuptri2);
X          /* Enforce the Delaunay condition around farvertex, on the */
X          /*   left side of the segment only.                        */
X          delaunayfixup(m, b, &fixuptri2, 1);
X          /* Flip the edge that crosses the segment.  After the edge is */
X          /*   flipped, one of its endpoints is the fan vertex, and the */
X          /*   destination of fixuptri is the fan vertex.               */
X          lprevself(fixuptri);
X        } else {                /* farvertex is to the right of the segment. */
X          delaunayfixup(m, b, &fixuptri, 0);
X          /* Flip the edge that crosses the segment.  After the edge is */
X          /*   flipped, one of its endpoints is the fan vertex, and the */
X          /*   destination of fixuptri is the fan vertex.               */
X          oprevself(fixuptri);
X        }
X        /* Check for two intersecting segments. */
X        tspivot(fixuptri, crosssubseg);
X        if (crosssubseg.ss == m->dummysub) {
X          flip(m, b, &fixuptri);    /* May create inverted triangle at left. */
X        } else {
X          /* We've collided with a segment between endpoint1 and endpoint2. */
X          collision = 1;
X          /* Insert a vertex at the intersection. */
X          segmentintersection(m, b, &fixuptri, &crosssubseg, endpoint2);
X          done = 1;
X        }
X      }
X    }
X  } while (!done);
X  /* Insert a subsegment to make the segment permanent. */
X  insertsubseg(m, b, &fixuptri, newmark);
X  /* If there was a collision with an interceding vertex, install another */
X  /*   segment connecting that vertex with endpoint2.                     */
X  if (collision) {
X    /* Insert the remainder of the segment. */
X    if (!scoutsegment(m, b, &fixuptri, endpoint2, newmark)) {
X      constrainededge(m, b, &fixuptri, endpoint2, newmark);
X    }
X  }
}
X
/*****************************************************************************/
/*                                                                           */
/*  insertsegment()   Insert a PSLG segment into a triangulation.            */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
void insertsegment(struct mesh *m, struct behavior *b,
X                   vertex endpoint1, vertex endpoint2, int newmark)
#else /* not ANSI_DECLARATORS */
void insertsegment(m, b, endpoint1, endpoint2, newmark)
struct mesh *m;
struct behavior *b;
vertex endpoint1;
vertex endpoint2;
int newmark;
#endif /* not ANSI_DECLARATORS */
X
{
X  struct otri searchtri1, searchtri2;
X  triangle encodedtri;
X  vertex checkvertex;
X  triangle ptr;                         /* Temporary variable used by sym(). */
X
X  if (b->verbose > 1) {
X    printf("  Connecting (%.12g, %.12g) to (%.12g, %.12g).\n",
X           endpoint1[0], endpoint1[1], endpoint2[0], endpoint2[1]);
X  }
X
X  /* Find a triangle whose origin is the segment's first endpoint. */
X  checkvertex = (vertex) NULL;
X  encodedtri = vertex2tri(endpoint1);
X  if (encodedtri != (triangle) NULL) {
X    decode(encodedtri, searchtri1);
X    org(searchtri1, checkvertex);
X  }
X  if (checkvertex != endpoint1) {
X    /* Find a boundary triangle to search from. */
X    searchtri1.tri = m->dummytri;
X    searchtri1.orient = 0;
X    symself(searchtri1);
X    /* Search for the segment's first endpoint by point location. */
X    if (locate(m, b, endpoint1, &searchtri1) != ONVERTEX) {
X      printf(
X        "Internal error in insertsegment():  Unable to locate PSLG vertex\n");
X      printf("  (%.12g, %.12g) in triangulation.\n",
X             endpoint1[0], endpoint1[1]);
X      internalerror();
X    }
X  }
X  /* Remember this triangle to improve subsequent point location. */
X  otricopy(searchtri1, m->recenttri);
X  /* Scout the beginnings of a path from the first endpoint */
X  /*   toward the second.                                   */
X  if (scoutsegment(m, b, &searchtri1, endpoint2, newmark)) {
X    /* The segment was easily inserted. */
X    return;
X  }
X  /* The first endpoint may have changed if a collision with an intervening */
X  /*   vertex on the segment occurred.                                      */
X  org(searchtri1, endpoint1);
X
X  /* Find a triangle whose origin is the segment's second endpoint. */
X  checkvertex = (vertex) NULL;
X  encodedtri = vertex2tri(endpoint2);
X  if (encodedtri != (triangle) NULL) {
X    decode(encodedtri, searchtri2);
X    org(searchtri2, checkvertex);
X  }
X  if (checkvertex != endpoint2) {
X    /* Find a boundary triangle to search from. */
X    searchtri2.tri = m->dummytri;
X    searchtri2.orient = 0;
X    symself(searchtri2);
X    /* Search for the segment's second endpoint by point location. */
X    if (locate(m, b, endpoint2, &searchtri2) != ONVERTEX) {
X      printf(
X        "Internal error in insertsegment():  Unable to locate PSLG vertex\n");
X      printf("  (%.12g, %.12g) in triangulation.\n",
X             endpoint2[0], endpoint2[1]);
X      internalerror();
X    }
X  }
X  /* Remember this triangle to improve subsequent point location. */
X  otricopy(searchtri2, m->recenttri);
X  /* Scout the beginnings of a path from the second endpoint */
X  /*   toward the first.                                     */
X  if (scoutsegment(m, b, &searchtri2, endpoint1, newmark)) {
X    /* The segment was easily inserted. */
X    return;
X  }
X  /* The second endpoint may have changed if a collision with an intervening */
X  /*   vertex on the segment occurred.                                       */
X  org(searchtri2, endpoint2);
X
#ifndef REDUCED
#ifndef CDT_ONLY
X  if (b->splitseg) {
X    /* Insert vertices to force the segment into the triangulation. */
X    conformingedge(m, b, endpoint1, endpoint2, newmark);
X  } else {
#endif /* not CDT_ONLY */
#endif /* not REDUCED */
X    /* Insert the segment directly into the triangulation. */
X    constrainededge(m, b, &searchtri1, endpoint2, newmark);
#ifndef REDUCED
#ifndef CDT_ONLY
X  }
#endif /* not CDT_ONLY */
#endif /* not REDUCED */
}
X
/*****************************************************************************/
/*                                                                           */
/*  markhull()   Cover the convex hull of a triangulation with subsegments.  */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
void markhull(struct mesh *m, struct behavior *b)
#else /* not ANSI_DECLARATORS */
void markhull(m, b)
struct mesh *m;
struct behavior *b;
#endif /* not ANSI_DECLARATORS */
X
{
X  struct otri hulltri;
X  struct otri nexttri;
X  struct otri starttri;
X  triangle ptr;             /* Temporary variable used by sym() and oprev(). */
X
X  /* Find a triangle handle on the hull. */
X  hulltri.tri = m->dummytri;
X  hulltri.orient = 0;
X  symself(hulltri);
X  /* Remember where we started so we know when to stop. */
X  otricopy(hulltri, starttri);
X  /* Go once counterclockwise around the convex hull. */
X  do {
X    /* Create a subsegment if there isn't already one here. */
X    insertsubseg(m, b, &hulltri, 1);
X    /* To find the next hull edge, go clockwise around the next vertex. */
X    lnextself(hulltri);
X    oprev(hulltri, nexttri);
X    while (nexttri.tri != m->dummytri) {
X      otricopy(nexttri, hulltri);
X      oprev(hulltri, nexttri);
X    }
X  } while (!otriequal(hulltri, starttri));
}
X
/*****************************************************************************/
/*                                                                           */
/*  formskeleton()   Create the segments of a triangulation, including PSLG  */
/*                   segments and edges on the convex hull.                  */
/*                                                                           */
/*  The PSLG segments are read from a .poly file.  The return value is the   */
/*  number of segments in the file.                                          */
/*                                                                           */
/*****************************************************************************/
X
#ifdef TRILIBRARY
X
#ifdef ANSI_DECLARATORS
void formskeleton(struct mesh *m, struct behavior *b, int *segmentlist,
X                  int *segmentmarkerlist, int numberofsegments)
#else /* not ANSI_DECLARATORS */
void formskeleton(m, b, segmentlist, segmentmarkerlist, numberofsegments)
struct mesh *m;
struct behavior *b;
int *segmentlist;
int *segmentmarkerlist;
int numberofsegments;
#endif /* not ANSI_DECLARATORS */
X
#else /* not TRILIBRARY */
X
#ifdef ANSI_DECLARATORS
void formskeleton(struct mesh *m, struct behavior *b,
X                  FILE *polyfile, char *polyfilename)
#else /* not ANSI_DECLARATORS */
void formskeleton(m, b, polyfile, polyfilename)
struct mesh *m;
struct behavior *b;
FILE *polyfile;
char *polyfilename;
#endif /* not ANSI_DECLARATORS */
X
#endif /* not TRILIBRARY */
X
{
#ifdef TRILIBRARY
X  char polyfilename[6];
X  int index;
#else /* not TRILIBRARY */
X  char inputline[INPUTLINESIZE];
X  char *stringptr;
#endif /* not TRILIBRARY */
X  vertex endpoint1, endpoint2;
X  int segmentmarkers;
X  int end1, end2;
X  int boundmarker;
X  int i;
X
X  if (b->poly) {
X    if (!b->quiet) {
X      printf("Recovering segments in Delaunay triangulation.\n");
X    }
#ifdef TRILIBRARY
X    strcpy(polyfilename, "input");
X    m->insegments = numberofsegments;
X    segmentmarkers = segmentmarkerlist != (int *) NULL;
X    index = 0;
#else /* not TRILIBRARY */
X    /* Read the segments from a .poly file. */
X    /* Read number of segments and number of boundary markers. */
X    stringptr = readline(inputline, polyfile, polyfilename);
X    m->insegments = (int) strtol(stringptr, &stringptr, 0);
X    stringptr = findfield(stringptr);
X    if (*stringptr == '\0') {
X      segmentmarkers = 0;
X    } else {
X      segmentmarkers = (int) strtol(stringptr, &stringptr, 0);
X    }
#endif /* not TRILIBRARY */
X    /* If the input vertices are collinear, there is no triangulation, */
X    /*   so don't try to insert segments.                              */
X    if (m->triangles.items == 0) {
X      return;
X    }
X
X    /* If segments are to be inserted, compute a mapping */
X    /*   from vertices to triangles.                     */
X    if (m->insegments > 0) {
X      makevertexmap(m, b);
X      if (b->verbose) {
X        printf("  Recovering PSLG segments.\n");
X      }
X    }
X
X    boundmarker = 0;
X    /* Read and insert the segments. */
X    for (i = 0; i < m->insegments; i++) {
#ifdef TRILIBRARY
X      end1 = segmentlist[index++];
X      end2 = segmentlist[index++];
X      if (segmentmarkers) {
X        boundmarker = segmentmarkerlist[i];
X      }
#else /* not TRILIBRARY */
X      stringptr = readline(inputline, polyfile, b->inpolyfilename);
X      stringptr = findfield(stringptr);
X      if (*stringptr == '\0') {
X        printf("Error:  Segment %d has no endpoints in %s.\n",
X               b->firstnumber + i, polyfilename);
X        triexit(1);
X      } else {
X        end1 = (int) strtol(stringptr, &stringptr, 0);
X      }
X      stringptr = findfield(stringptr);
X      if (*stringptr == '\0') {
X        printf("Error:  Segment %d is missing its second endpoint in %s.\n",
X               b->firstnumber + i, polyfilename);
X        triexit(1);
X      } else {
X        end2 = (int) strtol(stringptr, &stringptr, 0);
X      }
X      if (segmentmarkers) {
X        stringptr = findfield(stringptr);
X        if (*stringptr == '\0') {
X          boundmarker = 0;
X        } else {
X          boundmarker = (int) strtol(stringptr, &stringptr, 0);
X        }
X      }
#endif /* not TRILIBRARY */
X      if ((end1 < b->firstnumber) ||
X          (end1 >= b->firstnumber + m->invertices)) {
X        if (!b->quiet) {
X          printf("Warning:  Invalid first endpoint of segment %d in %s.\n",
X                 b->firstnumber + i, polyfilename);
X        }
X      } else if ((end2 < b->firstnumber) ||
X                 (end2 >= b->firstnumber + m->invertices)) {
X        if (!b->quiet) {
X          printf("Warning:  Invalid second endpoint of segment %d in %s.\n",
X                 b->firstnumber + i, polyfilename);
X        }
X      } else {
X        /* Find the vertices numbered `end1' and `end2'. */
X        endpoint1 = getvertex(m, b, end1);
X        endpoint2 = getvertex(m, b, end2);
X        if ((endpoint1[0] == endpoint2[0]) && (endpoint1[1] == endpoint2[1])) {
X          if (!b->quiet) {
X            printf("Warning:  Endpoints of segment %d are coincident in %s.\n",
X                   b->firstnumber + i, polyfilename);
X          }
X        } else {
X          insertsegment(m, b, endpoint1, endpoint2, boundmarker);
X        }
X      }
X    }
X  } else {
X    m->insegments = 0;
X  }
X  if (b->convex || !b->poly) {
X    /* Enclose the convex hull with subsegments. */
X    if (b->verbose) {
X      printf("  Enclosing convex hull with segments.\n");
X    }
X    markhull(m, b);
X  }
}
X
/**                                                                         **/
/**                                                                         **/
/********* Segment insertion ends here                               *********/
X
/********* Carving out holes and concavities begins here             *********/
/**                                                                         **/
/**                                                                         **/
X
/*****************************************************************************/
/*                                                                           */
/*  infecthull()   Virally infect all of the triangles of the convex hull    */
/*                 that are not protected by subsegments.  Where there are   */
/*                 subsegments, set boundary markers as appropriate.         */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
void infecthull(struct mesh *m, struct behavior *b)
#else /* not ANSI_DECLARATORS */
void infecthull(m, b)
struct mesh *m;
struct behavior *b;
#endif /* not ANSI_DECLARATORS */
X
{
X  struct otri hulltri;
X  struct otri nexttri;
X  struct otri starttri;
X  struct osub hullsubseg;
X  triangle **deadtriangle;
X  vertex horg, hdest;
X  triangle ptr;                         /* Temporary variable used by sym(). */
X  subseg sptr;                      /* Temporary variable used by tspivot(). */
X
X  if (b->verbose) {
X    printf("  Marking concavities (external triangles) for elimination.\n");
X  }
X  /* Find a triangle handle on the hull. */
X  hulltri.tri = m->dummytri;
X  hulltri.orient = 0;
X  symself(hulltri);
X  /* Remember where we started so we know when to stop. */
X  otricopy(hulltri, starttri);
X  /* Go once counterclockwise around the convex hull. */
X  do {
X    /* Ignore triangles that are already infected. */
X    if (!infected(hulltri)) {
X      /* Is the triangle protected by a subsegment? */
X      tspivot(hulltri, hullsubseg);
X      if (hullsubseg.ss == m->dummysub) {
X        /* The triangle is not protected; infect it. */
X        if (!infected(hulltri)) {
X          infect(hulltri);
X          deadtriangle = (triangle **) poolalloc(&m->viri);
X          *deadtriangle = hulltri.tri;
X        }
X      } else {
X        /* The triangle is protected; set boundary markers if appropriate. */
X        if (mark(hullsubseg) == 0) {
X          setmark(hullsubseg, 1);
X          org(hulltri, horg);
X          dest(hulltri, hdest);
X          if (vertexmark(horg) == 0) {
X            setvertexmark(horg, 1);
X          }
X          if (vertexmark(hdest) == 0) {
X            setvertexmark(hdest, 1);
X          }
X        }
X      }
X    }
X    /* To find the next hull edge, go clockwise around the next vertex. */
X    lnextself(hulltri);
X    oprev(hulltri, nexttri);
X    while (nexttri.tri != m->dummytri) {
X      otricopy(nexttri, hulltri);
X      oprev(hulltri, nexttri);
X    }
X  } while (!otriequal(hulltri, starttri));
}
X
/*****************************************************************************/
/*                                                                           */
/*  plague()   Spread the virus from all infected triangles to any neighbors */
/*             not protected by subsegments.  Delete all infected triangles. */
/*                                                                           */
/*  This is the procedure that actually creates holes and concavities.       */
/*                                                                           */
/*  This procedure operates in two phases.  The first phase identifies all   */
/*  the triangles that will die, and marks them as infected.  They are       */
/*  marked to ensure that each triangle is added to the virus pool only      */
/*  once, so the procedure will terminate.                                   */
/*                                                                           */
/*  The second phase actually eliminates the infected triangles.  It also    */
/*  eliminates orphaned vertices.                                            */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
void plague(struct mesh *m, struct behavior *b)
#else /* not ANSI_DECLARATORS */
void plague(m, b)
struct mesh *m;
struct behavior *b;
#endif /* not ANSI_DECLARATORS */
X
{
X  struct otri testtri;
X  struct otri neighbor;
X  triangle **virusloop;
X  triangle **deadtriangle;
X  struct osub neighborsubseg;
X  vertex testvertex;
X  vertex norg, ndest;
X  vertex deadorg, deaddest, deadapex;
X  int killorg;
X  triangle ptr;             /* Temporary variable used by sym() and onext(). */
X  subseg sptr;                      /* Temporary variable used by tspivot(). */
X
X  if (b->verbose) {
X    printf("  Marking neighbors of marked triangles.\n");
X  }
X  /* Loop through all the infected triangles, spreading the virus to */
X  /*   their neighbors, then to their neighbors' neighbors.          */
X  traversalinit(&m->viri);
X  virusloop = (triangle **) traverse(&m->viri);
X  while (virusloop != (triangle **) NULL) {
X    testtri.tri = *virusloop;
X    /* A triangle is marked as infected by messing with one of its pointers */
X    /*   to subsegments, setting it to an illegal value.  Hence, we have to */
X    /*   temporarily uninfect this triangle so that we can examine its      */
X    /*   adjacent subsegments.                                              */
X    uninfect(testtri);
X    if (b->verbose > 2) {
X      /* Assign the triangle an orientation for convenience in */
X      /*   checking its vertices.                              */
X      testtri.orient = 0;
X      org(testtri, deadorg);
X      dest(testtri, deaddest);
X      apex(testtri, deadapex);
X      printf("    Checking (%.12g, %.12g) (%.12g, %.12g) (%.12g, %.12g)\n",
X             deadorg[0], deadorg[1], deaddest[0], deaddest[1],
X             deadapex[0], deadapex[1]);
X    }
X    /* Check each of the triangle's three neighbors. */
X    for (testtri.orient = 0; testtri.orient < 3; testtri.orient++) {
X      /* Find the neighbor. */
X      sym(testtri, neighbor);
X      /* Check for a subsegment between the triangle and its neighbor. */
X      tspivot(testtri, neighborsubseg);
X      /* Check if the neighbor is nonexistent or already infected. */
X      if ((neighbor.tri == m->dummytri) || infected(neighbor)) {
X        if (neighborsubseg.ss != m->dummysub) {
X          /* There is a subsegment separating the triangle from its      */
X          /*   neighbor, but both triangles are dying, so the subsegment */
X          /*   dies too.                                                 */
X          subsegdealloc(m, neighborsubseg.ss);
X          if (neighbor.tri != m->dummytri) {
X            /* Make sure the subsegment doesn't get deallocated again */
X            /*   later when the infected neighbor is visited.         */
X            uninfect(neighbor);
X            tsdissolve(neighbor);
X            infect(neighbor);
X          }
X        }
X      } else {                   /* The neighbor exists and is not infected. */
X        if (neighborsubseg.ss == m->dummysub) {
X          /* There is no subsegment protecting the neighbor, so */
X          /*   the neighbor becomes infected.                   */
X          if (b->verbose > 2) {
X            org(neighbor, deadorg);
X            dest(neighbor, deaddest);
X            apex(neighbor, deadapex);
X            printf(
X              "    Marking (%.12g, %.12g) (%.12g, %.12g) (%.12g, %.12g)\n",
X                   deadorg[0], deadorg[1], deaddest[0], deaddest[1],
X                   deadapex[0], deadapex[1]);
X          }
X          infect(neighbor);
X          /* Ensure that the neighbor's neighbors will be infected. */
X          deadtriangle = (triangle **) poolalloc(&m->viri);
X          *deadtriangle = neighbor.tri;
X        } else {               /* The neighbor is protected by a subsegment. */
X          /* Remove this triangle from the subsegment. */
X          stdissolve(neighborsubseg);
X          /* The subsegment becomes a boundary.  Set markers accordingly. */
X          if (mark(neighborsubseg) == 0) {
X            setmark(neighborsubseg, 1);
X          }
X          org(neighbor, norg);
X          dest(neighbor, ndest);
X          if (vertexmark(norg) == 0) {
X            setvertexmark(norg, 1);
X          }
X          if (vertexmark(ndest) == 0) {
X            setvertexmark(ndest, 1);
X          }
X        }
X      }
X    }
X    /* Remark the triangle as infected, so it doesn't get added to the */
X    /*   virus pool again.                                             */
X    infect(testtri);
X    virusloop = (triangle **) traverse(&m->viri);
X  }
X
X  if (b->verbose) {
X    printf("  Deleting marked triangles.\n");
X  }
X
X  traversalinit(&m->viri);
X  virusloop = (triangle **) traverse(&m->viri);
X  while (virusloop != (triangle **) NULL) {
X    testtri.tri = *virusloop;
X
X    /* Check each of the three corners of the triangle for elimination. */
X    /*   This is done by walking around each vertex, checking if it is  */
X    /*   still connected to at least one live triangle.                 */
X    for (testtri.orient = 0; testtri.orient < 3; testtri.orient++) {
X      org(testtri, testvertex);
X      /* Check if the vertex has already been tested. */
X      if (testvertex != (vertex) NULL) {
X        killorg = 1;
X        /* Mark the corner of the triangle as having been tested. */
X        setorg(testtri, NULL);
X        /* Walk counterclockwise about the vertex. */
X        onext(testtri, neighbor);
X        /* Stop upon reaching a boundary or the starting triangle. */
X        while ((neighbor.tri != m->dummytri) &&
X               (!otriequal(neighbor, testtri))) {
X          if (infected(neighbor)) {
X            /* Mark the corner of this triangle as having been tested. */
X            setorg(neighbor, NULL);
X          } else {
X            /* A live triangle.  The vertex survives. */
X            killorg = 0;
X          }
X          /* Walk counterclockwise about the vertex. */
X          onextself(neighbor);
X        }
X        /* If we reached a boundary, we must walk clockwise as well. */
X        if (neighbor.tri == m->dummytri) {
X          /* Walk clockwise about the vertex. */
X          oprev(testtri, neighbor);
X          /* Stop upon reaching a boundary. */
X          while (neighbor.tri != m->dummytri) {
X            if (infected(neighbor)) {
X            /* Mark the corner of this triangle as having been tested. */
X              setorg(neighbor, NULL);
X            } else {
X              /* A live triangle.  The vertex survives. */
X              killorg = 0;
X            }
X            /* Walk clockwise about the vertex. */
X            oprevself(neighbor);
X          }
X        }
X        if (killorg) {
X          if (b->verbose > 1) {
X            printf("    Deleting vertex (%.12g, %.12g)\n",
X                   testvertex[0], testvertex[1]);
X          }
X          setvertextype(testvertex, UNDEADVERTEX);
X          m->undeads++;
X        }
X      }
X    }
X
X    /* Record changes in the number of boundary edges, and disconnect */
X    /*   dead triangles from their neighbors.                         */
X    for (testtri.orient = 0; testtri.orient < 3; testtri.orient++) {
X      sym(testtri, neighbor);
X      if (neighbor.tri == m->dummytri) {
X        /* There is no neighboring triangle on this edge, so this edge    */
X        /*   is a boundary edge.  This triangle is being deleted, so this */
X        /*   boundary edge is deleted.                                    */
X        m->hullsize--;
X      } else {
X        /* Disconnect the triangle from its neighbor. */
X        dissolve(neighbor);
X        /* There is a neighboring triangle on this edge, so this edge */
X        /*   becomes a boundary edge when this triangle is deleted.   */
X        m->hullsize++;
X      }
X    }
X    /* Return the dead triangle to the pool of triangles. */
X    triangledealloc(m, testtri.tri);
X    virusloop = (triangle **) traverse(&m->viri);
X  }
X  /* Empty the virus pool. */
X  poolrestart(&m->viri);
}
X
/*****************************************************************************/
/*                                                                           */
/*  regionplague()   Spread regional attributes and/or area constraints      */
/*                   (from a .poly file) throughout the mesh.                */
/*                                                                           */
/*  This procedure operates in two phases.  The first phase spreads an       */
/*  attribute and/or an area constraint through a (segment-bounded) region.  */
/*  The triangles are marked to ensure that each triangle is added to the    */
/*  virus pool only once, so the procedure will terminate.                   */
/*                                                                           */
/*  The second phase uninfects all infected triangles, returning them to     */
/*  normal.                                                                  */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
void regionplague(struct mesh *m, struct behavior *b,
X                  REAL attribute, REAL area)
#else /* not ANSI_DECLARATORS */
void regionplague(m, b, attribute, area)
struct mesh *m;
struct behavior *b;
REAL attribute;
REAL area;
#endif /* not ANSI_DECLARATORS */
X
{
X  struct otri testtri;
X  struct otri neighbor;
X  triangle **virusloop;
X  triangle **regiontri;
X  struct osub neighborsubseg;
X  vertex regionorg, regiondest, regionapex;
X  triangle ptr;             /* Temporary variable used by sym() and onext(). */
X  subseg sptr;                      /* Temporary variable used by tspivot(). */
X
X  if (b->verbose > 1) {
X    printf("  Marking neighbors of marked triangles.\n");
X  }
X  /* Loop through all the infected triangles, spreading the attribute      */
X  /*   and/or area constraint to their neighbors, then to their neighbors' */
X  /*   neighbors.                                                          */
X  traversalinit(&m->viri);
X  virusloop = (triangle **) traverse(&m->viri);
X  while (virusloop != (triangle **) NULL) {
X    testtri.tri = *virusloop;
X    /* A triangle is marked as infected by messing with one of its pointers */
X    /*   to subsegments, setting it to an illegal value.  Hence, we have to */
X    /*   temporarily uninfect this triangle so that we can examine its      */
X    /*   adjacent subsegments.                                              */
X    uninfect(testtri);
X    if (b->regionattrib) {
X      /* Set an attribute. */
X      setelemattribute(testtri, m->eextras, attribute);
X    }
X    if (b->vararea) {
X      /* Set an area constraint. */
X      setareabound(testtri, area);
X    }
X    if (b->verbose > 2) {
X      /* Assign the triangle an orientation for convenience in */
X      /*   checking its vertices.                              */
X      testtri.orient = 0;
X      org(testtri, regionorg);
X      dest(testtri, regiondest);
X      apex(testtri, regionapex);
X      printf("    Checking (%.12g, %.12g) (%.12g, %.12g) (%.12g, %.12g)\n",
X             regionorg[0], regionorg[1], regiondest[0], regiondest[1],
X             regionapex[0], regionapex[1]);
X    }
X    /* Check each of the triangle's three neighbors. */
X    for (testtri.orient = 0; testtri.orient < 3; testtri.orient++) {
X      /* Find the neighbor. */
X      sym(testtri, neighbor);
X      /* Check for a subsegment between the triangle and its neighbor. */
X      tspivot(testtri, neighborsubseg);
X      /* Make sure the neighbor exists, is not already infected, and */
X      /*   isn't protected by a subsegment.                          */
X      if ((neighbor.tri != m->dummytri) && !infected(neighbor)
X          && (neighborsubseg.ss == m->dummysub)) {
X        if (b->verbose > 2) {
X          org(neighbor, regionorg);
X          dest(neighbor, regiondest);
X          apex(neighbor, regionapex);
X          printf("    Marking (%.12g, %.12g) (%.12g, %.12g) (%.12g, %.12g)\n",
X                 regionorg[0], regionorg[1], regiondest[0], regiondest[1],
X                 regionapex[0], regionapex[1]);
X        }
X        /* Infect the neighbor. */
X        infect(neighbor);
X        /* Ensure that the neighbor's neighbors will be infected. */
X        regiontri = (triangle **) poolalloc(&m->viri);
X        *regiontri = neighbor.tri;
X      }
X    }
X    /* Remark the triangle as infected, so it doesn't get added to the */
X    /*   virus pool again.                                             */
X    infect(testtri);
X    virusloop = (triangle **) traverse(&m->viri);
X  }
X
X  /* Uninfect all triangles. */
X  if (b->verbose > 1) {
X    printf("  Unmarking marked triangles.\n");
X  }
X  traversalinit(&m->viri);
X  virusloop = (triangle **) traverse(&m->viri);
X  while (virusloop != (triangle **) NULL) {
X    testtri.tri = *virusloop;
X    uninfect(testtri);
X    virusloop = (triangle **) traverse(&m->viri);
X  }
X  /* Empty the virus pool. */
X  poolrestart(&m->viri);
}
X
/*****************************************************************************/
/*                                                                           */
/*  carveholes()   Find the holes and infect them.  Find the area            */
/*                 constraints and infect them.  Infect the convex hull.     */
/*                 Spread the infection and kill triangles.  Spread the      */
/*                 area constraints.                                         */
/*                                                                           */
/*  This routine mainly calls other routines to carry out all these          */
/*  functions.                                                               */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
void carveholes(struct mesh *m, struct behavior *b, REAL *holelist, int holes,
X                REAL *regionlist, int regions)
#else /* not ANSI_DECLARATORS */
void carveholes(m, b, holelist, holes, regionlist, regions)
struct mesh *m;
struct behavior *b;
REAL *holelist;
int holes;
REAL *regionlist;
int regions;
#endif /* not ANSI_DECLARATORS */
X
{
X  struct otri searchtri;
X  struct otri triangleloop;
X  struct otri *regiontris;
X  triangle **holetri;
X  triangle **regiontri;
X  vertex searchorg, searchdest;
X  enum locateresult intersect;
X  int i;
X  triangle ptr;                         /* Temporary variable used by sym(). */
X
X  if (!(b->quiet || (b->noholes && b->convex))) {
X    printf("Removing unwanted triangles.\n");
X    if (b->verbose && (holes > 0)) {
X      printf("  Marking holes for elimination.\n");
X    }
X  }
X
X  if (regions > 0) {
X    /* Allocate storage for the triangles in which region points fall. */
X    regiontris = (struct otri *) trimalloc(regions *
X                                           (int) sizeof(struct otri));
X  } else {
X    regiontris = (struct otri *) NULL;
X  }
X
X  if (((holes > 0) && !b->noholes) || !b->convex || (regions > 0)) {
X    /* Initialize a pool of viri to be used for holes, concavities, */
X    /*   regional attributes, and/or regional area constraints.     */
X    poolinit(&m->viri, sizeof(triangle *), VIRUSPERBLOCK, VIRUSPERBLOCK, 0);
X  }
X
X  if (!b->convex) {
X    /* Mark as infected any unprotected triangles on the boundary. */
X    /*   This is one way by which concavities are created.         */
X    infecthull(m, b);
X  }
X
X  if ((holes > 0) && !b->noholes) {
X    /* Infect each triangle in which a hole lies. */
X    for (i = 0; i < 2 * holes; i += 2) {
X      /* Ignore holes that aren't within the bounds of the mesh. */
X      if ((holelist[i] >= m->xmin) && (holelist[i] <= m->xmax)
X          && (holelist[i + 1] >= m->ymin) && (holelist[i + 1] <= m->ymax)) {
X        /* Start searching from some triangle on the outer boundary. */
X        searchtri.tri = m->dummytri;
X        searchtri.orient = 0;
X        symself(searchtri);
X        /* Ensure that the hole is to the left of this boundary edge; */
X        /*   otherwise, locate() will falsely report that the hole    */
X        /*   falls within the starting triangle.                      */
X        org(searchtri, searchorg);
X        dest(searchtri, searchdest);
X        if (counterclockwise(m, b, searchorg, searchdest, &holelist[i]) >
X            0.0) {
X          /* Find a triangle that contains the hole. */
X          intersect = locate(m, b, &holelist[i], &searchtri);
X          if ((intersect != OUTSIDE) && (!infected(searchtri))) {
X            /* Infect the triangle.  This is done by marking the triangle  */
X            /*   as infected and including the triangle in the virus pool. */
X            infect(searchtri);
X            holetri = (triangle **) poolalloc(&m->viri);
X            *holetri = searchtri.tri;
X          }
X        }
X      }
X    }
X  }
X
X  /* Now, we have to find all the regions BEFORE we carve the holes, because */
X  /*   locate() won't work when the triangulation is no longer convex.       */
X  /*   (Incidentally, this is the reason why regional attributes and area    */
X  /*   constraints can't be used when refining a preexisting mesh, which     */
X  /*   might not be convex; they can only be used with a freshly             */
X  /*   triangulated PSLG.)                                                   */
X  if (regions > 0) {
X    /* Find the starting triangle for each region. */
X    for (i = 0; i < regions; i++) {
X      regiontris[i].tri = m->dummytri;
X      /* Ignore region points that aren't within the bounds of the mesh. */
X      if ((regionlist[4 * i] >= m->xmin) && (regionlist[4 * i] <= m->xmax) &&
X          (regionlist[4 * i + 1] >= m->ymin) &&
X          (regionlist[4 * i + 1] <= m->ymax)) {
X        /* Start searching from some triangle on the outer boundary. */
X        searchtri.tri = m->dummytri;
X        searchtri.orient = 0;
X        symself(searchtri);
X        /* Ensure that the region point is to the left of this boundary */
X        /*   edge; otherwise, locate() will falsely report that the     */
X        /*   region point falls within the starting triangle.           */
X        org(searchtri, searchorg);
X        dest(searchtri, searchdest);
X        if (counterclockwise(m, b, searchorg, searchdest, &regionlist[4 * i]) >
X            0.0) {
X          /* Find a triangle that contains the region point. */
X          intersect = locate(m, b, &regionlist[4 * i], &searchtri);
X          if ((intersect != OUTSIDE) && (!infected(searchtri))) {
X            /* Record the triangle for processing after the */
X            /*   holes have been carved.                    */
X            otricopy(searchtri, regiontris[i]);
X          }
X        }
X      }
X    }
X  }
X
X  if (m->viri.items > 0) {
X    /* Carve the holes and concavities. */
X    plague(m, b);
X  }
X  /* The virus pool should be empty now. */
X
X  if (regions > 0) {
X    if (!b->quiet) {
X      if (b->regionattrib) {
X        if (b->vararea) {
X          printf("Spreading regional attributes and area constraints.\n");
X        } else {
X          printf("Spreading regional attributes.\n");
X        }
X      } else { 
X        printf("Spreading regional area constraints.\n");
X      }
X    }
X    if (b->regionattrib && !b->refine) {
X      /* Assign every triangle a regional attribute of zero. */
X      traversalinit(&m->triangles);
X      triangleloop.orient = 0;
X      triangleloop.tri = triangletraverse(m);
X      while (triangleloop.tri != (triangle *) NULL) {
X        setelemattribute(triangleloop, m->eextras, 0.0);
X        triangleloop.tri = triangletraverse(m);
X      }
X    }
X    for (i = 0; i < regions; i++) {
X      if (regiontris[i].tri != m->dummytri) {
X        /* Make sure the triangle under consideration still exists. */
X        /*   It may have been eaten by the virus.                   */
X        if (!deadtri(regiontris[i].tri)) {
X          /* Put one triangle in the virus pool. */
X          infect(regiontris[i]);
X          regiontri = (triangle **) poolalloc(&m->viri);
X          *regiontri = regiontris[i].tri;
X          /* Apply one region's attribute and/or area constraint. */
X          regionplague(m, b, regionlist[4 * i + 2], regionlist[4 * i + 3]);
X          /* The virus pool should be empty now. */
X        }
X      }
X    }
X    if (b->regionattrib && !b->refine) {
X      /* Note the fact that each triangle has an additional attribute. */
X      m->eextras++;
X    }
X  }
X
X  /* Free up memory. */
X  if (((holes > 0) && !b->noholes) || !b->convex || (regions > 0)) {
X    pooldeinit(&m->viri);
X  }
X  if (regions > 0) {
X    trifree((VOID *) regiontris);
X  }
}
X
/**                                                                         **/
/**                                                                         **/
/********* Carving out holes and concavities ends here               *********/
X
/********* Mesh quality maintenance begins here                      *********/
/**                                                                         **/
/**                                                                         **/
X
/*****************************************************************************/
/*                                                                           */
/*  tallyencs()   Traverse the entire list of subsegments, and check each    */
/*                to see if it is encroached.  If so, add it to the list.    */
/*                                                                           */
/*****************************************************************************/
X
#ifndef CDT_ONLY
X
#ifdef ANSI_DECLARATORS
void tallyencs(struct mesh *m, struct behavior *b)
#else /* not ANSI_DECLARATORS */
void tallyencs(m, b)
struct mesh *m;
struct behavior *b;
#endif /* not ANSI_DECLARATORS */
X
{
X  struct osub subsegloop;
X  int dummy;
X
X  traversalinit(&m->subsegs);
X  subsegloop.ssorient = 0;
X  subsegloop.ss = subsegtraverse(m);
X  while (subsegloop.ss != (subseg *) NULL) {
X    /* If the segment is encroached, add it to the list. */
X    dummy = checkseg4encroach(m, b, &subsegloop);
X    subsegloop.ss = subsegtraverse(m);
X  }
}
X
#endif /* not CDT_ONLY */
X
/*****************************************************************************/
/*                                                                           */
/*  precisionerror()  Print an error message for precision problems.         */
/*                                                                           */
/*****************************************************************************/
X
#ifndef CDT_ONLY
X
void precisionerror()
{
X  printf("Try increasing the area criterion and/or reducing the minimum\n");
X  printf("  allowable angle so that tiny triangles are not created.\n");
#ifdef SINGLE
X  printf("Alternatively, try recompiling me with double precision\n");
X  printf("  arithmetic (by removing \"#define SINGLE\" from the\n");
X  printf("  source file or \"-DSINGLE\" from the makefile).\n");
#endif /* SINGLE */
}
X
#endif /* not CDT_ONLY */
X
/*****************************************************************************/
/*                                                                           */
/*  splitencsegs()   Split all the encroached subsegments.                   */
/*                                                                           */
/*  Each encroached subsegment is repaired by splitting it - inserting a     */
/*  vertex at or near its midpoint.  Newly inserted vertices may encroach    */
/*  upon other subsegments; these are also repaired.                         */
/*                                                                           */
/*  `triflaws' is a flag that specifies whether one should take note of new  */
/*  bad triangles that result from inserting vertices to repair encroached   */
/*  subsegments.                                                             */
/*                                                                           */
/*****************************************************************************/
X
#ifndef CDT_ONLY
X
#ifdef ANSI_DECLARATORS
void splitencsegs(struct mesh *m, struct behavior *b, int triflaws)
#else /* not ANSI_DECLARATORS */
void splitencsegs(m, b, triflaws)
struct mesh *m;
struct behavior *b;
int triflaws;
#endif /* not ANSI_DECLARATORS */
X
{
X  struct otri enctri;
X  struct otri testtri;
X  struct osub testsh;
X  struct osub currentenc;
X  struct badsubseg *encloop;
X  vertex eorg, edest, eapex;
X  vertex newvertex;
X  enum insertvertexresult success;
X  REAL segmentlength, nearestpoweroftwo;
X  REAL split;
X  REAL multiplier, divisor;
X  int acuteorg, acuteorg2, acutedest, acutedest2;
X  int dummy;
X  int i;
X  triangle ptr;                     /* Temporary variable used by stpivot(). */
X  subseg sptr;                        /* Temporary variable used by snext(). */
X
X  /* Note that steinerleft == -1 if an unlimited number */
X  /*   of Steiner points is allowed.                    */
X  while ((m->badsubsegs.items > 0) && (m->steinerleft != 0)) {
X    traversalinit(&m->badsubsegs);
X    encloop = badsubsegtraverse(m);
X    while ((encloop != (struct badsubseg *) NULL) && (m->steinerleft != 0)) {
X      sdecode(encloop->encsubseg, currentenc);
X      sorg(currentenc, eorg);
X      sdest(currentenc, edest);
X      /* Make sure that this segment is still the same segment it was   */
X      /*   when it was determined to be encroached.  If the segment was */
X      /*   enqueued multiple times (because several newly inserted      */
X      /*   vertices encroached it), it may have already been split.     */
X      if (!deadsubseg(currentenc.ss) &&
X          (eorg == encloop->subsegorg) && (edest == encloop->subsegdest)) {
X        /* To decide where to split a segment, we need to know if the   */
X        /*   segment shares an endpoint with an adjacent segment.       */
X        /*   The concern is that, if we simply split every encroached   */
X        /*   segment in its center, two adjacent segments with a small  */
X        /*   angle between them might lead to an infinite loop; each    */
X        /*   vertex added to split one segment will encroach upon the   */
X        /*   other segment, which must then be split with a vertex that */
X        /*   will encroach upon the first segment, and so on forever.   */
X        /* To avoid this, imagine a set of concentric circles, whose    */
X        /*   radii are powers of two, about each segment endpoint.      */
X        /*   These concentric circles determine where the segment is    */
X        /*   split.  (If both endpoints are shared with adjacent        */
X        /*   segments, split the segment in the middle, and apply the   */
X        /*   concentric circles for later splittings.)                  */
X
X        /* Is the origin shared with another segment? */
X        stpivot(currentenc, enctri);
X        lnext(enctri, testtri);
X        tspivot(testtri, testsh);
X        acuteorg = testsh.ss != m->dummysub;
X        /* Is the destination shared with another segment? */
X        lnextself(testtri);
X        tspivot(testtri, testsh);
X        acutedest = testsh.ss != m->dummysub;
X
X        /* If we're using Chew's algorithm (rather than Ruppert's) */
X        /*   to define encroachment, delete free vertices from the */
X        /*   subsegment's diametral circle.                        */
X        if (!b->conformdel && !acuteorg && !acutedest) {
X          apex(enctri, eapex);
X          while ((vertextype(eapex) == FREEVERTEX) &&
X                 ((eorg[0] - eapex[0]) * (edest[0] - eapex[0]) +
X                  (eorg[1] - eapex[1]) * (edest[1] - eapex[1]) < 0.0)) {
X            deletevertex(m, b, &testtri);
X            stpivot(currentenc, enctri);
X            apex(enctri, eapex);
X            lprev(enctri, testtri);
X          }
X        }
X
X        /* Now, check the other side of the segment, if there's a triangle */
X        /*   there.                                                        */
X        sym(enctri, testtri);
X        if (testtri.tri != m->dummytri) {
X          /* Is the destination shared with another segment? */
X          lnextself(testtri);
X          tspivot(testtri, testsh);
X          acutedest2 = testsh.ss != m->dummysub;
X          acutedest = acutedest || acutedest2;
X          /* Is the origin shared with another segment? */
X          lnextself(testtri);
X          tspivot(testtri, testsh);
X          acuteorg2 = testsh.ss != m->dummysub;
X          acuteorg = acuteorg || acuteorg2;
X
X          /* Delete free vertices from the subsegment's diametral circle. */
X          if (!b->conformdel && !acuteorg2 && !acutedest2) {
X            org(testtri, eapex);
X            while ((vertextype(eapex) == FREEVERTEX) &&
X                   ((eorg[0] - eapex[0]) * (edest[0] - eapex[0]) +
X                    (eorg[1] - eapex[1]) * (edest[1] - eapex[1]) < 0.0)) {
X              deletevertex(m, b, &testtri);
X              sym(enctri, testtri);
X              apex(testtri, eapex);
X              lprevself(testtri);
X            }
X          }
X        }
X
X        /* Use the concentric circles if exactly one endpoint is shared */
X        /*   with another adjacent segment.                             */
X        if (acuteorg || acutedest) {
X          segmentlength = sqrt((edest[0] - eorg[0]) * (edest[0] - eorg[0]) +
X                               (edest[1] - eorg[1]) * (edest[1] - eorg[1]));
X          /* Find the power of two that most evenly splits the segment.  */
X          /*   The worst case is a 2:1 ratio between subsegment lengths. */
X          nearestpoweroftwo = 1.0;
X          while (segmentlength > 3.0 * nearestpoweroftwo) {
X            nearestpoweroftwo *= 2.0;
X          }
X          while (segmentlength < 1.5 * nearestpoweroftwo) {
X            nearestpoweroftwo *= 0.5;
X          }
X          /* Where do we split the segment? */
X          split = nearestpoweroftwo / segmentlength;
X          if (acutedest) {
X            split = 1.0 - split;
X          }
X        } else {
X          /* If we're not worried about adjacent segments, split */
X          /*   this segment in the middle.                       */
X          split = 0.5;
X        }
X
X        /* Create the new vertex. */
X        newvertex = (vertex) poolalloc(&m->vertices);
X        /* Interpolate its coordinate and attributes. */
X        for (i = 0; i < 2 + m->nextras; i++) {
X          newvertex[i] = eorg[i] + split * (edest[i] - eorg[i]);
X        }
X
X        if (!b->noexact) {
X          /* Roundoff in the above calculation may yield a `newvertex'   */
X          /*   that is not precisely collinear with `eorg' and `edest'.  */
X          /*   Improve collinearity by one step of iterative refinement. */
X          multiplier = counterclockwise(m, b, eorg, edest, newvertex);
X          divisor = ((eorg[0] - edest[0]) * (eorg[0] - edest[0]) +
X                     (eorg[1] - edest[1]) * (eorg[1] - edest[1]));
X          if ((multiplier != 0.0) && (divisor != 0.0)) {
X            multiplier = multiplier / divisor;
X            /* Watch out for NANs. */
X            if (multiplier == multiplier) {
X              newvertex[0] += multiplier * (edest[1] - eorg[1]);
X              newvertex[1] += multiplier * (eorg[0] - edest[0]);
X            }
X          }
X        }
X
X        setvertexmark(newvertex, mark(currentenc));
X        setvertextype(newvertex, SEGMENTVERTEX);
X        if (b->verbose > 1) {
X          printf(
X  "  Splitting subsegment (%.12g, %.12g) (%.12g, %.12g) at (%.12g, %.12g).\n",
X                 eorg[0], eorg[1], edest[0], edest[1],
X                 newvertex[0], newvertex[1]);
X        }
X        /* Check whether the new vertex lies on an endpoint. */
X        if (((newvertex[0] == eorg[0]) && (newvertex[1] == eorg[1])) ||
X            ((newvertex[0] == edest[0]) && (newvertex[1] == edest[1]))) {
X          printf("Error:  Ran out of precision at (%.12g, %.12g).\n",
X                 newvertex[0], newvertex[1]);
X          printf("I attempted to split a segment to a smaller size than\n");
X          printf("  can be accommodated by the finite precision of\n");
X          printf("  floating point arithmetic.\n");
X          precisionerror();
X          triexit(1);
X        }
X        /* Insert the splitting vertex.  This should always succeed. */
X        success = insertvertex(m, b, newvertex, &enctri, &currentenc,
X                               1, triflaws);
X        if ((success != SUCCESSFULVERTEX) && (success != ENCROACHINGVERTEX)) {
X          printf("Internal error in splitencsegs():\n");
X          printf("  Failure to split a segment.\n");
X          internalerror();
X        }
X        if (m->steinerleft > 0) {
X          m->steinerleft--;
X        }
X        /* Check the two new subsegments to see if they're encroached. */
X        dummy = checkseg4encroach(m, b, &currentenc);
X        snextself(currentenc);
X        dummy = checkseg4encroach(m, b, &currentenc);
X      }
X
X      badsubsegdealloc(m, encloop);
X      encloop = badsubsegtraverse(m);
X    }
X  }
}
X
#endif /* not CDT_ONLY */
X
/*****************************************************************************/
/*                                                                           */
/*  tallyfaces()   Test every triangle in the mesh for quality measures.     */
/*                                                                           */
/*****************************************************************************/
X
#ifndef CDT_ONLY
X
#ifdef ANSI_DECLARATORS
void tallyfaces(struct mesh *m, struct behavior *b)
#else /* not ANSI_DECLARATORS */
void tallyfaces(m, b)
struct mesh *m;
struct behavior *b;
#endif /* not ANSI_DECLARATORS */
X
{
X  struct otri triangleloop;
X
X  if (b->verbose) {
X    printf("  Making a list of bad triangles.\n");
X  }
X  traversalinit(&m->triangles);
X  triangleloop.orient = 0;
X  triangleloop.tri = triangletraverse(m);
X  while (triangleloop.tri != (triangle *) NULL) {
X    /* If the triangle is bad, enqueue it. */
X    testtriangle(m, b, &triangleloop);
X    triangleloop.tri = triangletraverse(m);
X  }
}
X
#endif /* not CDT_ONLY */
X
/*****************************************************************************/
/*                                                                           */
/*  splittriangle()   Inserts a vertex at the circumcenter of a triangle.    */
/*                    Deletes the newly inserted vertex if it encroaches     */
/*                    upon a segment.                                        */
/*                                                                           */
/*****************************************************************************/
X
#ifndef CDT_ONLY
X
#ifdef ANSI_DECLARATORS
void splittriangle(struct mesh *m, struct behavior *b,
X                   struct badtriang *badtri)
#else /* not ANSI_DECLARATORS */
void splittriangle(m, b, badtri)
struct mesh *m;
struct behavior *b;
struct badtriang *badtri;
#endif /* not ANSI_DECLARATORS */
X
{
X  struct otri badotri;
X  vertex borg, bdest, bapex;
X  vertex newvertex;
X  REAL xi, eta;
X  enum insertvertexresult success;
X  int errorflag;
X  int i;
X
X  decode(badtri->poortri, badotri);
X  org(badotri, borg);
X  dest(badotri, bdest);
X  apex(badotri, bapex);
X  /* Make sure that this triangle is still the same triangle it was      */
X  /*   when it was tested and determined to be of bad quality.           */
X  /*   Subsequent transformations may have made it a different triangle. */
X  if (!deadtri(badotri.tri) && (borg == badtri->triangorg) &&
X      (bdest == badtri->triangdest) && (bapex == badtri->triangapex)) {
X    if (b->verbose > 1) {
X      printf("  Splitting this triangle at its circumcenter:\n");
X      printf("    (%.12g, %.12g) (%.12g, %.12g) (%.12g, %.12g)\n", borg[0],
X             borg[1], bdest[0], bdest[1], bapex[0], bapex[1]);
X    }
X
X    errorflag = 0;
X    /* Create a new vertex at the triangle's circumcenter. */
X    newvertex = (vertex) poolalloc(&m->vertices);
X    findcircumcenter(m, b, borg, bdest, bapex, newvertex, &xi, &eta, 1);
X
X    /* Check whether the new vertex lies on a triangle vertex. */
X    if (((newvertex[0] == borg[0]) && (newvertex[1] == borg[1])) ||
X        ((newvertex[0] == bdest[0]) && (newvertex[1] == bdest[1])) ||
X        ((newvertex[0] == bapex[0]) && (newvertex[1] == bapex[1]))) {
X      if (!b->quiet) {
X        printf(
X             "Warning:  New vertex (%.12g, %.12g) falls on existing vertex.\n",
X               newvertex[0], newvertex[1]);
X        errorflag = 1;
X      }
X      vertexdealloc(m, newvertex);
X    } else {
X      for (i = 2; i < 2 + m->nextras; i++) {
X        /* Interpolate the vertex attributes at the circumcenter. */
X        newvertex[i] = borg[i] + xi * (bdest[i] - borg[i])
X                              + eta * (bapex[i] - borg[i]);
X      }
X      /* The new vertex must be in the interior, and therefore is a */
X      /*   free vertex with a marker of zero.                       */
X      setvertexmark(newvertex, 0);
X      setvertextype(newvertex, FREEVERTEX);
X
X      /* Ensure that the handle `badotri' does not represent the longest  */
X      /*   edge of the triangle.  This ensures that the circumcenter must */
X      /*   fall to the left of this edge, so point location will work.    */
X      /*   (If the angle org-apex-dest exceeds 90 degrees, then the       */
X      /*   circumcenter lies outside the org-dest edge, and eta is        */
X      /*   negative.  Roundoff error might prevent eta from being         */
X      /*   negative when it should be, so I test eta against xi.)         */
X      if (eta < xi) {
X        lprevself(badotri);
X      }
X
X      /* Insert the circumcenter, searching from the edge of the triangle, */
X      /*   and maintain the Delaunay property of the triangulation.        */
X      success = insertvertex(m, b, newvertex, &badotri, (struct osub *) NULL,
X                             1, 1);
X      if (success == SUCCESSFULVERTEX) {
X        if (m->steinerleft > 0) {
X          m->steinerleft--;
X        }
X      } else if (success == ENCROACHINGVERTEX) {
X        /* If the newly inserted vertex encroaches upon a subsegment, */
X        /*   delete the new vertex.                                   */
X        undovertex(m, b);
X        if (b->verbose > 1) {
X          printf("  Rejecting (%.12g, %.12g).\n", newvertex[0], newvertex[1]);
X        }
X        vertexdealloc(m, newvertex);
X      } else if (success == VIOLATINGVERTEX) {
X        /* Failed to insert the new vertex, but some subsegment was */
X        /*   marked as being encroached.                            */
X        vertexdealloc(m, newvertex);
X      } else {                                 /* success == DUPLICATEVERTEX */
X        /* Couldn't insert the new vertex because a vertex is already there. */
X        if (!b->quiet) {
X          printf(
X            "Warning:  New vertex (%.12g, %.12g) falls on existing vertex.\n",
X                 newvertex[0], newvertex[1]);
X          errorflag = 1;
X        }
X        vertexdealloc(m, newvertex);
X      }
X    }
X    if (errorflag) {
X      if (b->verbose) {
X        printf("  The new vertex is at the circumcenter of triangle\n");
X        printf("    (%.12g, %.12g) (%.12g, %.12g) (%.12g, %.12g)\n",
X               borg[0], borg[1], bdest[0], bdest[1], bapex[0], bapex[1]);
X      }
X      printf("This probably means that I am trying to refine triangles\n");
X      printf("  to a smaller size than can be accommodated by the finite\n");
X      printf("  precision of floating point arithmetic.  (You can be\n");
X      printf("  sure of this if I fail to terminate.)\n");
X      precisionerror();
X    }
X  }
}
X
#endif /* not CDT_ONLY */
X
/*****************************************************************************/
/*                                                                           */
/*  enforcequality()   Remove all the encroached subsegments and bad         */
/*                     triangles from the triangulation.                     */
/*                                                                           */
/*****************************************************************************/
X
#ifndef CDT_ONLY
X
#ifdef ANSI_DECLARATORS
void enforcequality(struct mesh *m, struct behavior *b)
#else /* not ANSI_DECLARATORS */
void enforcequality(m, b)
struct mesh *m;
struct behavior *b;
#endif /* not ANSI_DECLARATORS */
X
{
X  struct badtriang *badtri;
X  int i;
X
X  if (!b->quiet) {
X    printf("Adding Steiner points to enforce quality.\n");
X  }
X  /* Initialize the pool of encroached subsegments. */
X  poolinit(&m->badsubsegs, sizeof(struct badsubseg), BADSUBSEGPERBLOCK,
X           BADSUBSEGPERBLOCK, 0);
X  if (b->verbose) {
X    printf("  Looking for encroached subsegments.\n");
X  }
X  /* Test all segments to see if they're encroached. */
X  tallyencs(m, b);
X  if (b->verbose && (m->badsubsegs.items > 0)) {
X    printf("  Splitting encroached subsegments.\n");
X  }
X  /* Fix encroached subsegments without noting bad triangles. */
X  splitencsegs(m, b, 0);
X  /* At this point, if we haven't run out of Steiner points, the */
X  /*   triangulation should be (conforming) Delaunay.            */
X
X  /* Next, we worry about enforcing triangle quality. */
X  if ((b->minangle > 0.0) || b->vararea || b->fixedarea || b->usertest) {
X    /* Initialize the pool of bad triangles. */
X    poolinit(&m->badtriangles, sizeof(struct badtriang), BADTRIPERBLOCK,
X             BADTRIPERBLOCK, 0);
X    /* Initialize the queues of bad triangles. */
X    for (i = 0; i < 4096; i++) {
X      m->queuefront[i] = (struct badtriang *) NULL;
X    }
X    m->firstnonemptyq = -1;
X    /* Test all triangles to see if they're bad. */
X    tallyfaces(m, b);
X    /* Initialize the pool of recently flipped triangles. */
X    poolinit(&m->flipstackers, sizeof(struct flipstacker), FLIPSTACKERPERBLOCK,
X             FLIPSTACKERPERBLOCK, 0);
X    m->checkquality = 1;
X    if (b->verbose) {
X      printf("  Splitting bad triangles.\n");
X    }
X    while ((m->badtriangles.items > 0) && (m->steinerleft != 0)) {
X      /* Fix one bad triangle by inserting a vertex at its circumcenter. */
X      badtri = dequeuebadtriang(m);
X      splittriangle(m, b, badtri);
X      if (m->badsubsegs.items > 0) {
X        /* Put bad triangle back in queue for another try later. */
X        enqueuebadtriang(m, b, badtri);
X        /* Fix any encroached subsegments that resulted. */
X        /*   Record any new bad triangles that result.   */
X        splitencsegs(m, b, 1);
X      } else {
X        /* Return the bad triangle to the pool. */
X        pooldealloc(&m->badtriangles, (VOID *) badtri);
X      }
X    }
X  }
X  /* At this point, if the "-D" switch was selected and we haven't run out  */
X  /*   of Steiner points, the triangulation should be (conforming) Delaunay */
X  /*   and have no low-quality triangles.                                   */
X
X  /* Might we have run out of Steiner points too soon? */
X  if (!b->quiet && b->conformdel && (m->badsubsegs.items > 0) &&
X      (m->steinerleft == 0)) {
X    printf("\nWarning:  I ran out of Steiner points, but the mesh has\n");
X    if (m->badsubsegs.items == 1) {
X      printf("  one encroached subsegment, and therefore might not be truly\n"
X             );
X    } else {
X      printf("  %ld encroached subsegments, and therefore might not be truly\n"
X             , m->badsubsegs.items);
X    }
X    printf("  Delaunay.  If the Delaunay property is important to you,\n");
X    printf("  try increasing the number of Steiner points (controlled by\n");
X    printf("  the -S switch) slightly and try again.\n\n");
X  }
}
X
#endif /* not CDT_ONLY */
X
/**                                                                         **/
/**                                                                         **/
/********* Mesh quality maintenance ends here                        *********/
X
/*****************************************************************************/
/*                                                                           */
/*  highorder()   Create extra nodes for quadratic subparametric elements.   */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
void highorder(struct mesh *m, struct behavior *b)
#else /* not ANSI_DECLARATORS */
void highorder(m, b)
struct mesh *m;
struct behavior *b;
#endif /* not ANSI_DECLARATORS */
X
{
X  struct otri triangleloop, trisym;
X  struct osub checkmark;
X  vertex newvertex;
X  vertex torg, tdest;
X  int i;
X  triangle ptr;                         /* Temporary variable used by sym(). */
X  subseg sptr;                      /* Temporary variable used by tspivot(). */
X
X  if (!b->quiet) {
X    printf("Adding vertices for second-order triangles.\n");
X  }
X  /* The following line ensures that dead items in the pool of nodes    */
X  /*   cannot be allocated for the extra nodes associated with high     */
X  /*   order elements.  This ensures that the primary nodes (at the     */
X  /*   corners of elements) will occur earlier in the output files, and */
X  /*   have lower indices, than the extra nodes.                        */
X  m->vertices.deaditemstack = (VOID *) NULL;
X
X  traversalinit(&m->triangles);
X  triangleloop.tri = triangletraverse(m);
X  /* To loop over the set of edges, loop over all triangles, and look at   */
X  /*   the three edges of each triangle.  If there isn't another triangle  */
X  /*   adjacent to the edge, operate on the edge.  If there is another     */
X  /*   adjacent triangle, operate on the edge only if the current triangle */
X  /*   has a smaller pointer than its neighbor.  This way, each edge is    */
X  /*   considered only once.                                               */
X  while (triangleloop.tri != (triangle *) NULL) {
X    for (triangleloop.orient = 0; triangleloop.orient < 3;
X         triangleloop.orient++) {
X      sym(triangleloop, trisym);
X      if ((triangleloop.tri < trisym.tri) || (trisym.tri == m->dummytri)) {
X        org(triangleloop, torg);
X        dest(triangleloop, tdest);
X        /* Create a new node in the middle of the edge.  Interpolate */
X        /*   its attributes.                                         */
X        newvertex = (vertex) poolalloc(&m->vertices);
X        for (i = 0; i < 2 + m->nextras; i++) {
X          newvertex[i] = 0.5 * (torg[i] + tdest[i]);
X        }
X        /* Set the new node's marker to zero or one, depending on */
X        /*   whether it lies on a boundary.                       */
X        setvertexmark(newvertex, trisym.tri == m->dummytri);
X        setvertextype(newvertex,
X                      trisym.tri == m->dummytri ? FREEVERTEX : SEGMENTVERTEX);
X        if (b->usesegments) {
X          tspivot(triangleloop, checkmark);
X          /* If this edge is a segment, transfer the marker to the new node. */
X          if (checkmark.ss != m->dummysub) {
X            setvertexmark(newvertex, mark(checkmark));
X            setvertextype(newvertex, SEGMENTVERTEX);
X          }
X        }
X        if (b->verbose > 1) {
X          printf("  Creating (%.12g, %.12g).\n", newvertex[0], newvertex[1]);
X        }
X        /* Record the new node in the (one or two) adjacent elements. */
X        triangleloop.tri[m->highorderindex + triangleloop.orient] =
X                (triangle) newvertex;
X        if (trisym.tri != m->dummytri) {
X          trisym.tri[m->highorderindex + trisym.orient] = (triangle) newvertex;
X        }
X      }
X    }
X    triangleloop.tri = triangletraverse(m);
X  }
}
X
/********* File I/O routines begin here                              *********/
/**                                                                         **/
/**                                                                         **/
X
/*****************************************************************************/
/*                                                                           */
/*  readline()   Read a nonempty line from a file.                           */
/*                                                                           */
/*  A line is considered "nonempty" if it contains something that looks like */
/*  a number.  Comments (prefaced by `#') are ignored.                       */
/*                                                                           */
/*****************************************************************************/
X
#ifndef TRILIBRARY
X
#ifdef ANSI_DECLARATORS
char *readline(char *string, FILE *infile, char *infilename)
#else /* not ANSI_DECLARATORS */
char *readline(string, infile, infilename)
char *string;
FILE *infile;
char *infilename;
#endif /* not ANSI_DECLARATORS */
X
{
X  char *result;
X
X  /* Search for something that looks like a number. */
X  do {
X    result = fgets(string, INPUTLINESIZE, infile);
X    if (result == (char *) NULL) {
X      printf("  Error:  Unexpected end of file in %s.\n", infilename);
X      triexit(1);
X    }
X    /* Skip anything that doesn't look like a number, a comment, */
X    /*   or the end of a line.                                   */
X    while ((*result != '\0') && (*result != '#')
X           && (*result != '.') && (*result != '+') && (*result != '-')
X           && ((*result < '0') || (*result > '9'))) {
X      result++;
X    }
X  /* If it's a comment or end of line, read another line and try again. */
X  } while ((*result == '#') || (*result == '\0'));
X  return result;
}
X
#endif /* not TRILIBRARY */
X
/*****************************************************************************/
/*                                                                           */
/*  findfield()   Find the next field of a string.                           */
/*                                                                           */
/*  Jumps past the current field by searching for whitespace, then jumps     */
/*  past the whitespace to find the next field.                              */
/*                                                                           */
/*****************************************************************************/
X
#ifndef TRILIBRARY
X
#ifdef ANSI_DECLARATORS
char *findfield(char *string)
#else /* not ANSI_DECLARATORS */
char *findfield(string)
char *string;
#endif /* not ANSI_DECLARATORS */
X
{
X  char *result;
X
X  result = string;
X  /* Skip the current field.  Stop upon reaching whitespace. */
X  while ((*result != '\0') && (*result != '#')
X         && (*result != ' ') && (*result != '\t')) {
X    result++;
X  }
X  /* Now skip the whitespace and anything else that doesn't look like a */
X  /*   number, a comment, or the end of a line.                         */
X  while ((*result != '\0') && (*result != '#')
X         && (*result != '.') && (*result != '+') && (*result != '-')
X         && ((*result < '0') || (*result > '9'))) {
X    result++;
X  }
X  /* Check for a comment (prefixed with `#'). */
X  if (*result == '#') {
X    *result = '\0';
X  }
X  return result;
}
X
#endif /* not TRILIBRARY */
X
/*****************************************************************************/
/*                                                                           */
/*  readnodes()   Read the vertices from a file, which may be a .node or     */
/*                .poly file.                                                */
/*                                                                           */
/*****************************************************************************/
X
#ifndef TRILIBRARY
X
#ifdef ANSI_DECLARATORS
void readnodes(struct mesh *m, struct behavior *b, char *nodefilename,
X               char *polyfilename, FILE **polyfile)
#else /* not ANSI_DECLARATORS */
void readnodes(m, b, nodefilename, polyfilename, polyfile)
struct mesh *m;
struct behavior *b;
char *nodefilename;
char *polyfilename;
FILE **polyfile;
#endif /* not ANSI_DECLARATORS */
X
{
X  FILE *infile;
X  vertex vertexloop;
X  char inputline[INPUTLINESIZE];
X  char *stringptr;
X  char *infilename;
X  REAL x, y;
X  int firstnode;
X  int nodemarkers;
X  int currentmarker;
X  int i, j;
X
X  if (b->poly) {
X    /* Read the vertices from a .poly file. */
X    if (!b->quiet) {
X      printf("Opening %s.\n", polyfilename);
X    }
X    *polyfile = fopen(polyfilename, "r");
X    if (*polyfile == (FILE *) NULL) {
X      printf("  Error:  Cannot access file %s.\n", polyfilename);
X      triexit(1);
X    }
X    /* Read number of vertices, number of dimensions, number of vertex */
X    /*   attributes, and number of boundary markers.                   */
X    stringptr = readline(inputline, *polyfile, polyfilename);
X    m->invertices = (int) strtol(stringptr, &stringptr, 0);
X    stringptr = findfield(stringptr);
X    if (*stringptr == '\0') {
X      m->mesh_dim = 2;
X    } else {
X      m->mesh_dim = (int) strtol(stringptr, &stringptr, 0);
X    }
X    stringptr = findfield(stringptr);
X    if (*stringptr == '\0') {
X      m->nextras = 0;
X    } else {
X      m->nextras = (int) strtol(stringptr, &stringptr, 0);
X    }
X    stringptr = findfield(stringptr);
X    if (*stringptr == '\0') {
X      nodemarkers = 0;
X    } else {
X      nodemarkers = (int) strtol(stringptr, &stringptr, 0);
X    }
X    if (m->invertices > 0) {
X      infile = *polyfile;
X      infilename = polyfilename;
X      m->readnodefile = 0;
X    } else {
X      /* If the .poly file claims there are zero vertices, that means that */
X      /*   the vertices should be read from a separate .node file.         */
X      m->readnodefile = 1;
X      infilename = nodefilename;
X    }
X  } else {
X    m->readnodefile = 1;
X    infilename = nodefilename;
X    *polyfile = (FILE *) NULL;
X  }
X
X  if (m->readnodefile) {
X    /* Read the vertices from a .node file. */
X    if (!b->quiet) {
X      printf("Opening %s.\n", nodefilename);
X    }
X    infile = fopen(nodefilename, "r");
X    if (infile == (FILE *) NULL) {
X      printf("  Error:  Cannot access file %s.\n", nodefilename);
X      triexit(1);
X    }
X    /* Read number of vertices, number of dimensions, number of vertex */
X    /*   attributes, and number of boundary markers.                   */
X    stringptr = readline(inputline, infile, nodefilename);
X    m->invertices = (int) strtol(stringptr, &stringptr, 0);
X    stringptr = findfield(stringptr);
X    if (*stringptr == '\0') {
X      m->mesh_dim = 2;
X    } else {
X      m->mesh_dim = (int) strtol(stringptr, &stringptr, 0);
X    }
X    stringptr = findfield(stringptr);
X    if (*stringptr == '\0') {
X      m->nextras = 0;
X    } else {
X      m->nextras = (int) strtol(stringptr, &stringptr, 0);
X    }
X    stringptr = findfield(stringptr);
X    if (*stringptr == '\0') {
X      nodemarkers = 0;
X    } else {
X      nodemarkers = (int) strtol(stringptr, &stringptr, 0);
X    }
X  }
X
X  if (m->invertices < 3) {
X    printf("Error:  Input must have at least three input vertices.\n");
X    triexit(1);
X  }
X  if (m->mesh_dim != 2) {
X    printf("Error:  Triangle only works with two-dimensional meshes.\n");
X    triexit(1);
X  }
X  if (m->nextras == 0) {
X    b->weighted = 0;
X  }
X
X  initializevertexpool(m, b);
X
X  /* Read the vertices. */
X  for (i = 0; i < m->invertices; i++) {
X    vertexloop = (vertex) poolalloc(&m->vertices);
X    stringptr = readline(inputline, infile, infilename);
X    if (i == 0) {
X      firstnode = (int) strtol(stringptr, &stringptr, 0);
X      if ((firstnode == 0) || (firstnode == 1)) {
X        b->firstnumber = firstnode;
X      }
X    }
X    stringptr = findfield(stringptr);
X    if (*stringptr == '\0') {
X      printf("Error:  Vertex %d has no x coordinate.\n", b->firstnumber + i);
X      triexit(1);
X    }
X    x = (REAL) strtod(stringptr, &stringptr);
X    stringptr = findfield(stringptr);
X    if (*stringptr == '\0') {
X      printf("Error:  Vertex %d has no y coordinate.\n", b->firstnumber + i);
X      triexit(1);
X    }
X    y = (REAL) strtod(stringptr, &stringptr);
X    vertexloop[0] = x;
X    vertexloop[1] = y;
X    /* Read the vertex attributes. */
X    for (j = 2; j < 2 + m->nextras; j++) {
X      stringptr = findfield(stringptr);
X      if (*stringptr == '\0') {
X        vertexloop[j] = 0.0;
X      } else {
X        vertexloop[j] = (REAL) strtod(stringptr, &stringptr);
X      }
X    }
X    if (nodemarkers) {
X      /* Read a vertex marker. */
X      stringptr = findfield(stringptr);
X      if (*stringptr == '\0') {
X        setvertexmark(vertexloop, 0);
X      } else {
X        currentmarker = (int) strtol(stringptr, &stringptr, 0);
X        setvertexmark(vertexloop, currentmarker);
X      }
X    } else {
X      /* If no markers are specified in the file, they default to zero. */
X      setvertexmark(vertexloop, 0);
X    }
X    setvertextype(vertexloop, INPUTVERTEX);
X    /* Determine the smallest and largest x and y coordinates. */
X    if (i == 0) {
X      m->xmin = m->xmax = x;
X      m->ymin = m->ymax = y;
X    } else {
X      m->xmin = (x < m->xmin) ? x : m->xmin;
X      m->xmax = (x > m->xmax) ? x : m->xmax;
X      m->ymin = (y < m->ymin) ? y : m->ymin;
X      m->ymax = (y > m->ymax) ? y : m->ymax;
X    }
X  }
X  if (m->readnodefile) {
X    fclose(infile);
X  }
X
X  /* Nonexistent x value used as a flag to mark circle events in sweepline */
X  /*   Delaunay algorithm.                                                 */
X  m->xminextreme = 10 * m->xmin - 9 * m->xmax;
}
X
#endif /* not TRILIBRARY */
X
/*****************************************************************************/
/*                                                                           */
/*  transfernodes()   Read the vertices from memory.                         */
/*                                                                           */
/*****************************************************************************/
X
#ifdef TRILIBRARY
X
#ifdef ANSI_DECLARATORS
void transfernodes(struct mesh *m, struct behavior *b, REAL *pointlist,
X                   REAL *pointattriblist, int *pointmarkerlist,
X                   int numberofpoints, int numberofpointattribs)
#else /* not ANSI_DECLARATORS */
void transfernodes(m, b, pointlist, pointattriblist, pointmarkerlist,
X                   numberofpoints, numberofpointattribs)
struct mesh *m;
struct behavior *b;
REAL *pointlist;
REAL *pointattriblist;
int *pointmarkerlist;
int numberofpoints;
int numberofpointattribs;
#endif /* not ANSI_DECLARATORS */
X
{
X  vertex vertexloop;
X  REAL x, y;
X  int i, j;
X  int coordindex;
X  int attribindex;
X
X  m->invertices = numberofpoints;
X  m->mesh_dim = 2;
X  m->nextras = numberofpointattribs;
X  m->readnodefile = 0;
X  if (m->invertices < 3) {
X    printf("Error:  Input must have at least three input vertices.\n");
X    triexit(1);
X  }
X  if (m->nextras == 0) {
X    b->weighted = 0;
X  }
X
X  initializevertexpool(m, b);
X
X  /* Read the vertices. */
X  coordindex = 0;
X  attribindex = 0;
X  for (i = 0; i < m->invertices; i++) {
X    vertexloop = (vertex) poolalloc(&m->vertices);
X    /* Read the vertex coordinates. */
X    x = vertexloop[0] = pointlist[coordindex++];
X    y = vertexloop[1] = pointlist[coordindex++];
X    /* Read the vertex attributes. */
X    for (j = 0; j < numberofpointattribs; j++) {
X      vertexloop[2 + j] = pointattriblist[attribindex++];
X    }
X    if (pointmarkerlist != (int *) NULL) {
X      /* Read a vertex marker. */
X      setvertexmark(vertexloop, pointmarkerlist[i]);
X    } else {
X      /* If no markers are specified, they default to zero. */
X      setvertexmark(vertexloop, 0);
X    }
X    setvertextype(vertexloop, INPUTVERTEX);
X    /* Determine the smallest and largest x and y coordinates. */
X    if (i == 0) {
X      m->xmin = m->xmax = x;
X      m->ymin = m->ymax = y;
X    } else {
X      m->xmin = (x < m->xmin) ? x : m->xmin;
X      m->xmax = (x > m->xmax) ? x : m->xmax;
X      m->ymin = (y < m->ymin) ? y : m->ymin;
X      m->ymax = (y > m->ymax) ? y : m->ymax;
X    }
X  }
X
X  /* Nonexistent x value used as a flag to mark circle events in sweepline */
X  /*   Delaunay algorithm.                                                 */
X  m->xminextreme = 10 * m->xmin - 9 * m->xmax;
}
X
#endif /* TRILIBRARY */
X
/*****************************************************************************/
/*                                                                           */
/*  readholes()   Read the holes, and possibly regional attributes and area  */
/*                constraints, from a .poly file.                            */
/*                                                                           */
/*****************************************************************************/
X
#ifndef TRILIBRARY
X
#ifdef ANSI_DECLARATORS
void readholes(struct mesh *m, struct behavior *b,
X               FILE *polyfile, char *polyfilename, REAL **hlist, int *holes,
X               REAL **rlist, int *regions)
#else /* not ANSI_DECLARATORS */
void readholes(m, b, polyfile, polyfilename, hlist, holes, rlist, regions)
struct mesh *m;
struct behavior *b;
FILE *polyfile;
char *polyfilename;
REAL **hlist;
int *holes;
REAL **rlist;
int *regions;
#endif /* not ANSI_DECLARATORS */
X
{
X  REAL *holelist;
X  REAL *regionlist;
X  char inputline[INPUTLINESIZE];
X  char *stringptr;
X  int index;
X  int i;
X
X  /* Read the holes. */
X  stringptr = readline(inputline, polyfile, polyfilename);
X  *holes = (int) strtol(stringptr, &stringptr, 0);
X  if (*holes > 0) {
X    holelist = (REAL *) trimalloc(2 * *holes * (int) sizeof(REAL));
X    *hlist = holelist;
X    for (i = 0; i < 2 * *holes; i += 2) {
X      stringptr = readline(inputline, polyfile, polyfilename);
X      stringptr = findfield(stringptr);
X      if (*stringptr == '\0') {
X        printf("Error:  Hole %d has no x coordinate.\n",
X               b->firstnumber + (i >> 1));
X        triexit(1);
X      } else {
X        holelist[i] = (REAL) strtod(stringptr, &stringptr);
X      }
X      stringptr = findfield(stringptr);
X      if (*stringptr == '\0') {
X        printf("Error:  Hole %d has no y coordinate.\n",
X               b->firstnumber + (i >> 1));
X        triexit(1);
X      } else {
X        holelist[i + 1] = (REAL) strtod(stringptr, &stringptr);
X      }
X    }
X  } else {
X    *hlist = (REAL *) NULL;
X  }
X
#ifndef CDT_ONLY
X  if ((b->regionattrib || b->vararea) && !b->refine) {
X    /* Read the area constraints. */
X    stringptr = readline(inputline, polyfile, polyfilename);
X    *regions = (int) strtol(stringptr, &stringptr, 0);
X    if (*regions > 0) {
X      regionlist = (REAL *) trimalloc(4 * *regions * (int) sizeof(REAL));
X      *rlist = regionlist;
X      index = 0;
X      for (i = 0; i < *regions; i++) {
X        stringptr = readline(inputline, polyfile, polyfilename);
X        stringptr = findfield(stringptr);
X        if (*stringptr == '\0') {
X          printf("Error:  Region %d has no x coordinate.\n",
X                 b->firstnumber + i);
X          triexit(1);
X        } else {
X          regionlist[index++] = (REAL) strtod(stringptr, &stringptr);
X        }
X        stringptr = findfield(stringptr);
X        if (*stringptr == '\0') {
X          printf("Error:  Region %d has no y coordinate.\n",
X                 b->firstnumber + i);
X          triexit(1);
X        } else {
X          regionlist[index++] = (REAL) strtod(stringptr, &stringptr);
X        }
X        stringptr = findfield(stringptr);
X        if (*stringptr == '\0') {
X          printf(
X            "Error:  Region %d has no region attribute or area constraint.\n",
X                 b->firstnumber + i);
X          triexit(1);
X        } else {
X          regionlist[index++] = (REAL) strtod(stringptr, &stringptr);
X        }
X        stringptr = findfield(stringptr);
X        if (*stringptr == '\0') {
X          regionlist[index] = regionlist[index - 1];
X        } else {
X          regionlist[index] = (REAL) strtod(stringptr, &stringptr);
X        }
X        index++;
X      }
X    }
X  } else {
X    /* Set `*regions' to zero to avoid an accidental free() later. */
X    *regions = 0;
X    *rlist = (REAL *) NULL;
X  }
#endif /* not CDT_ONLY */
X
X  fclose(polyfile);
}
X
#endif /* not TRILIBRARY */
X
/*****************************************************************************/
/*                                                                           */
/*  finishfile()   Write the command line to the output file so the user     */
/*                 can remember how the file was generated.  Close the file. */
/*                                                                           */
/*****************************************************************************/
X
#ifndef TRILIBRARY
X
#ifdef ANSI_DECLARATORS
void finishfile(FILE *outfile, int argc, char **argv)
#else /* not ANSI_DECLARATORS */
void finishfile(outfile, argc, argv)
FILE *outfile;
int argc;
char **argv;
#endif /* not ANSI_DECLARATORS */
X
{
X  int i;
X
X  fprintf(outfile, "# Generated by");
X  for (i = 0; i < argc; i++) {
X    fprintf(outfile, " ");
X    fputs(argv[i], outfile);
X  }
X  fprintf(outfile, "\n");
X  fclose(outfile);
}
X
#endif /* not TRILIBRARY */
X
/*****************************************************************************/
/*                                                                           */
/*  writenodes()   Number the vertices and write them to a .node file.       */
/*                                                                           */
/*  To save memory, the vertex numbers are written over the boundary markers */
/*  after the vertices are written to a file.                                */
/*                                                                           */
/*****************************************************************************/
X
#ifdef TRILIBRARY
X
#ifdef ANSI_DECLARATORS
void writenodes(struct mesh *m, struct behavior *b, REAL **pointlist,
X                REAL **pointattriblist, int **pointmarkerlist)
#else /* not ANSI_DECLARATORS */
void writenodes(m, b, pointlist, pointattriblist, pointmarkerlist)
struct mesh *m;
struct behavior *b;
REAL **pointlist;
REAL **pointattriblist;
int **pointmarkerlist;
#endif /* not ANSI_DECLARATORS */
X
#else /* not TRILIBRARY */
X
#ifdef ANSI_DECLARATORS
void writenodes(struct mesh *m, struct behavior *b, char *nodefilename,
X                int argc, char **argv)
#else /* not ANSI_DECLARATORS */
void writenodes(m, b, nodefilename, argc, argv)
struct mesh *m;
struct behavior *b;
char *nodefilename;
int argc;
char **argv;
#endif /* not ANSI_DECLARATORS */
X
#endif /* not TRILIBRARY */
X
{
#ifdef TRILIBRARY
X  REAL *plist;
X  REAL *palist;
X  int *pmlist;
X  int coordindex;
X  int attribindex;
#else /* not TRILIBRARY */
X  FILE *outfile;
#endif /* not TRILIBRARY */
X  vertex vertexloop;
X  long outvertices;
X  int vertexnumber;
X  int i;
X
X  if (b->jettison) {
X    outvertices = m->vertices.items - m->undeads;
X  } else {
X    outvertices = m->vertices.items;
X  }
X
#ifdef TRILIBRARY
X  if (!b->quiet) {
X    printf("Writing vertices.\n");
X  }
X  /* Allocate memory for output vertices if necessary. */
X  if (*pointlist == (REAL *) NULL) {
X    *pointlist = (REAL *) trimalloc((int) (outvertices * 2 * sizeof(REAL)));
X  }
X  /* Allocate memory for output vertex attributes if necessary. */
X  if ((m->nextras > 0) && (*pointattriblist == (REAL *) NULL)) {
X    *pointattriblist = (REAL *) trimalloc((int) (outvertices * m->nextras *
X                                                 sizeof(REAL)));
X  }
X  /* Allocate memory for output vertex markers if necessary. */
X  if (!b->nobound && (*pointmarkerlist == (int *) NULL)) {
X    *pointmarkerlist = (int *) trimalloc((int) (outvertices * sizeof(int)));
X  }
X  plist = *pointlist;
X  palist = *pointattriblist;
X  pmlist = *pointmarkerlist;
X  coordindex = 0;
X  attribindex = 0;
#else /* not TRILIBRARY */
X  if (!b->quiet) {
X    printf("Writing %s.\n", nodefilename);
X  }
X  outfile = fopen(nodefilename, "w");
X  if (outfile == (FILE *) NULL) {
X    printf("  Error:  Cannot create file %s.\n", nodefilename);
X    triexit(1);
X  }
X  /* Number of vertices, number of dimensions, number of vertex attributes, */
X  /*   and number of boundary markers (zero or one).                        */
X  fprintf(outfile, "%ld  %d  %d  %d\n", outvertices, m->mesh_dim,
X          m->nextras, 1 - b->nobound);
#endif /* not TRILIBRARY */
X
X  traversalinit(&m->vertices);
X  vertexnumber = b->firstnumber;
X  vertexloop = vertextraverse(m);
X  while (vertexloop != (vertex) NULL) {
X    if (!b->jettison || (vertextype(vertexloop) != UNDEADVERTEX)) {
#ifdef TRILIBRARY
X      /* X and y coordinates. */
X      plist[coordindex++] = vertexloop[0];
X      plist[coordindex++] = vertexloop[1];
X      /* Vertex attributes. */
X      for (i = 0; i < m->nextras; i++) {
X        palist[attribindex++] = vertexloop[2 + i];
X      }
X      if (!b->nobound) {
X        /* Copy the boundary marker. */
X        pmlist[vertexnumber - b->firstnumber] = vertexmark(vertexloop);
X      }
#else /* not TRILIBRARY */
X      /* Vertex number, x and y coordinates. */
X      fprintf(outfile, "%4d    %.17g  %.17g", vertexnumber, vertexloop[0],
X              vertexloop[1]);
X      for (i = 0; i < m->nextras; i++) {
X        /* Write an attribute. */
X        fprintf(outfile, "  %.17g", vertexloop[i + 2]);
X      }
X      if (b->nobound) {
X        fprintf(outfile, "\n");
X      } else {
X        /* Write the boundary marker. */
X        fprintf(outfile, "    %d\n", vertexmark(vertexloop));
X      }
#endif /* not TRILIBRARY */
X
X      setvertexmark(vertexloop, vertexnumber);
X      vertexnumber++;
X    }
X    vertexloop = vertextraverse(m);
X  }
X
#ifndef TRILIBRARY
X  finishfile(outfile, argc, argv);
#endif /* not TRILIBRARY */
}
X
/*****************************************************************************/
/*                                                                           */
/*  numbernodes()   Number the vertices.                                     */
/*                                                                           */
/*  Each vertex is assigned a marker equal to its number.                    */
/*                                                                           */
/*  Used when writenodes() is not called because no .node file is written.   */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
void numbernodes(struct mesh *m, struct behavior *b)
#else /* not ANSI_DECLARATORS */
void numbernodes(m, b)
struct mesh *m;
struct behavior *b;
#endif /* not ANSI_DECLARATORS */
X
{
X  vertex vertexloop;
X  int vertexnumber;
X
X  traversalinit(&m->vertices);
X  vertexnumber = b->firstnumber;
X  vertexloop = vertextraverse(m);
X  while (vertexloop != (vertex) NULL) {
X    setvertexmark(vertexloop, vertexnumber);
X    if (!b->jettison || (vertextype(vertexloop) != UNDEADVERTEX)) {
X      vertexnumber++;
X    }
X    vertexloop = vertextraverse(m);
X  }
}
X
/*****************************************************************************/
/*                                                                           */
/*  writeelements()   Write the triangles to an .ele file.                   */
/*                                                                           */
/*****************************************************************************/
X
#ifdef TRILIBRARY
X
#ifdef ANSI_DECLARATORS
void writeelements(struct mesh *m, struct behavior *b,
X                   int **trianglelist, REAL **triangleattriblist)
#else /* not ANSI_DECLARATORS */
void writeelements(m, b, trianglelist, triangleattriblist)
struct mesh *m;
struct behavior *b;
int **trianglelist;
REAL **triangleattriblist;
#endif /* not ANSI_DECLARATORS */
X
#else /* not TRILIBRARY */
X
#ifdef ANSI_DECLARATORS
void writeelements(struct mesh *m, struct behavior *b, char *elefilename,
X                   int argc, char **argv)
#else /* not ANSI_DECLARATORS */
void writeelements(m, b, elefilename, argc, argv)
struct mesh *m;
struct behavior *b;
char *elefilename;
int argc;
char **argv;
#endif /* not ANSI_DECLARATORS */
X
#endif /* not TRILIBRARY */
X
{
#ifdef TRILIBRARY
X  int *tlist;
X  REAL *talist;
X  int vertexindex;
X  int attribindex;
#else /* not TRILIBRARY */
X  FILE *outfile;
#endif /* not TRILIBRARY */
X  struct otri triangleloop;
X  vertex p1, p2, p3;
X  vertex mid1, mid2, mid3;
X  long elementnumber;
X  int i;
X
#ifdef TRILIBRARY
X  if (!b->quiet) {
X    printf("Writing triangles.\n");
X  }
X  /* Allocate memory for output triangles if necessary. */
X  if (*trianglelist == (int *) NULL) {
X    *trianglelist = (int *) trimalloc((int) (m->triangles.items *
X                                             ((b->order + 1) * (b->order + 2) /
X                                              2) * sizeof(int)));
X  }
X  /* Allocate memory for output triangle attributes if necessary. */
X  if ((m->eextras > 0) && (*triangleattriblist == (REAL *) NULL)) {
X    *triangleattriblist = (REAL *) trimalloc((int) (m->triangles.items *
X                                                    m->eextras *
X                                                    sizeof(REAL)));
X  }
X  tlist = *trianglelist;
X  talist = *triangleattriblist;
X  vertexindex = 0;
X  attribindex = 0;
#else /* not TRILIBRARY */
X  if (!b->quiet) {
X    printf("Writing %s.\n", elefilename);
X  }
X  outfile = fopen(elefilename, "w");
X  if (outfile == (FILE *) NULL) {
X    printf("  Error:  Cannot create file %s.\n", elefilename);
X    triexit(1);
X  }
X  /* Number of triangles, vertices per triangle, attributes per triangle. */
X  fprintf(outfile, "%ld  %d  %d\n", m->triangles.items,
X          (b->order + 1) * (b->order + 2) / 2, m->eextras);
#endif /* not TRILIBRARY */
X
X  traversalinit(&m->triangles);
X  triangleloop.tri = triangletraverse(m);
X  triangleloop.orient = 0;
X  elementnumber = b->firstnumber;
X  while (triangleloop.tri != (triangle *) NULL) {
X    org(triangleloop, p1);
X    dest(triangleloop, p2);
X    apex(triangleloop, p3);
X    if (b->order == 1) {
#ifdef TRILIBRARY
X      tlist[vertexindex++] = vertexmark(p1);
X      tlist[vertexindex++] = vertexmark(p2);
X      tlist[vertexindex++] = vertexmark(p3);
#else /* not TRILIBRARY */
X      /* Triangle number, indices for three vertices. */
X      fprintf(outfile, "%4ld    %4d  %4d  %4d", elementnumber,
X              vertexmark(p1), vertexmark(p2), vertexmark(p3));
#endif /* not TRILIBRARY */
X    } else {
X      mid1 = (vertex) triangleloop.tri[m->highorderindex + 1];
X      mid2 = (vertex) triangleloop.tri[m->highorderindex + 2];
X      mid3 = (vertex) triangleloop.tri[m->highorderindex];
#ifdef TRILIBRARY
X      tlist[vertexindex++] = vertexmark(p1);
X      tlist[vertexindex++] = vertexmark(p2);
X      tlist[vertexindex++] = vertexmark(p3);
X      tlist[vertexindex++] = vertexmark(mid1);
X      tlist[vertexindex++] = vertexmark(mid2);
X      tlist[vertexindex++] = vertexmark(mid3);
#else /* not TRILIBRARY */
X      /* Triangle number, indices for six vertices. */
X      fprintf(outfile, "%4ld    %4d  %4d  %4d  %4d  %4d  %4d", elementnumber,
X              vertexmark(p1), vertexmark(p2), vertexmark(p3), vertexmark(mid1),
X              vertexmark(mid2), vertexmark(mid3));
#endif /* not TRILIBRARY */
X    }
X
#ifdef TRILIBRARY
X    for (i = 0; i < m->eextras; i++) {
X      talist[attribindex++] = elemattribute(triangleloop, i);
X    }
#else /* not TRILIBRARY */
X    for (i = 0; i < m->eextras; i++) {
X      fprintf(outfile, "  %.17g", elemattribute(triangleloop, i));
X    }
X    fprintf(outfile, "\n");
#endif /* not TRILIBRARY */
X
X    triangleloop.tri = triangletraverse(m);
X    elementnumber++;
X  }
X
#ifndef TRILIBRARY
X  finishfile(outfile, argc, argv);
#endif /* not TRILIBRARY */
}
X
/*****************************************************************************/
/*                                                                           */
/*  writepoly()   Write the segments and holes to a .poly file.              */
/*                                                                           */
/*****************************************************************************/
X
#ifdef TRILIBRARY
X
#ifdef ANSI_DECLARATORS
void writepoly(struct mesh *m, struct behavior *b,
X               int **segmentlist, int **segmentmarkerlist)
#else /* not ANSI_DECLARATORS */
void writepoly(m, b, segmentlist, segmentmarkerlist)
struct mesh *m;
struct behavior *b;
int **segmentlist;
int **segmentmarkerlist;
#endif /* not ANSI_DECLARATORS */
X
#else /* not TRILIBRARY */
X
#ifdef ANSI_DECLARATORS
void writepoly(struct mesh *m, struct behavior *b, char *polyfilename,
X               REAL *holelist, int holes, REAL *regionlist, int regions,
X               int argc, char **argv)
#else /* not ANSI_DECLARATORS */
void writepoly(m, b, polyfilename, holelist, holes, regionlist, regions,
X               argc, argv)
struct mesh *m;
struct behavior *b;
char *polyfilename;
REAL *holelist;
int holes;
REAL *regionlist;
int regions;
int argc;
char **argv;
#endif /* not ANSI_DECLARATORS */
X
#endif /* not TRILIBRARY */
X
{
#ifdef TRILIBRARY
X  int *slist;
X  int *smlist;
X  int index;
#else /* not TRILIBRARY */
X  FILE *outfile;
X  long holenumber, regionnumber;
#endif /* not TRILIBRARY */
X  struct osub subsegloop;
X  vertex endpoint1, endpoint2;
X  long subsegnumber;
X
#ifdef TRILIBRARY
X  if (!b->quiet) {
X    printf("Writing segments.\n");
X  }
X  /* Allocate memory for output segments if necessary. */
X  if (*segmentlist == (int *) NULL) {
X    *segmentlist = (int *) trimalloc((int) (m->subsegs.items * 2 *
X                                            sizeof(int)));
X  }
X  /* Allocate memory for output segment markers if necessary. */
X  if (!b->nobound && (*segmentmarkerlist == (int *) NULL)) {
X    *segmentmarkerlist = (int *) trimalloc((int) (m->subsegs.items *
X                                                  sizeof(int)));
X  }
X  slist = *segmentlist;
X  smlist = *segmentmarkerlist;
X  index = 0;
#else /* not TRILIBRARY */
X  if (!b->quiet) {
X    printf("Writing %s.\n", polyfilename);
X  }
X  outfile = fopen(polyfilename, "w");
X  if (outfile == (FILE *) NULL) {
X    printf("  Error:  Cannot create file %s.\n", polyfilename);
X    triexit(1);
X  }
X  /* The zero indicates that the vertices are in a separate .node file. */
X  /*   Followed by number of dimensions, number of vertex attributes,   */
X  /*   and number of boundary markers (zero or one).                    */
X  fprintf(outfile, "%d  %d  %d  %d\n", 0, m->mesh_dim, m->nextras,
X          1 - b->nobound);
X  /* Number of segments, number of boundary markers (zero or one). */
X  fprintf(outfile, "%ld  %d\n", m->subsegs.items, 1 - b->nobound);
#endif /* not TRILIBRARY */
X
X  traversalinit(&m->subsegs);
X  subsegloop.ss = subsegtraverse(m);
X  subsegloop.ssorient = 0;
X  subsegnumber = b->firstnumber;
X  while (subsegloop.ss != (subseg *) NULL) {
X    sorg(subsegloop, endpoint1);
X    sdest(subsegloop, endpoint2);
#ifdef TRILIBRARY
X    /* Copy indices of the segment's two endpoints. */
X    slist[index++] = vertexmark(endpoint1);
X    slist[index++] = vertexmark(endpoint2);
X    if (!b->nobound) {
X      /* Copy the boundary marker. */
X      smlist[subsegnumber - b->firstnumber] = mark(subsegloop);
X    }
#else /* not TRILIBRARY */
X    /* Segment number, indices of its two endpoints, and possibly a marker. */
X    if (b->nobound) {
X      fprintf(outfile, "%4ld    %4d  %4d\n", subsegnumber,
X              vertexmark(endpoint1), vertexmark(endpoint2));
X    } else {
X      fprintf(outfile, "%4ld    %4d  %4d    %4d\n", subsegnumber,
X              vertexmark(endpoint1), vertexmark(endpoint2), mark(subsegloop));
X    }
#endif /* not TRILIBRARY */
X
X    subsegloop.ss = subsegtraverse(m);
X    subsegnumber++;
X  }
X
#ifndef TRILIBRARY
#ifndef CDT_ONLY
X  fprintf(outfile, "%d\n", holes);
X  if (holes > 0) {
X    for (holenumber = 0; holenumber < holes; holenumber++) {
X      /* Hole number, x and y coordinates. */
X      fprintf(outfile, "%4ld   %.17g  %.17g\n", b->firstnumber + holenumber,
X              holelist[2 * holenumber], holelist[2 * holenumber + 1]);
X    }
X  }
X  if (regions > 0) {
X    fprintf(outfile, "%d\n", regions);
X    for (regionnumber = 0; regionnumber < regions; regionnumber++) {
X      /* Region number, x and y coordinates, attribute, maximum area. */
X      fprintf(outfile, "%4ld   %.17g  %.17g  %.17g  %.17g\n",
X              b->firstnumber + regionnumber,
X              regionlist[4 * regionnumber], regionlist[4 * regionnumber + 1],
X              regionlist[4 * regionnumber + 2],
X              regionlist[4 * regionnumber + 3]);
X    }
X  }
#endif /* not CDT_ONLY */
X
X  finishfile(outfile, argc, argv);
#endif /* not TRILIBRARY */
}
X
/*****************************************************************************/
/*                                                                           */
/*  writeedges()   Write the edges to an .edge file.                         */
/*                                                                           */
/*****************************************************************************/
X
#ifdef TRILIBRARY
X
#ifdef ANSI_DECLARATORS
void writeedges(struct mesh *m, struct behavior *b,
X                int **edgelist, int **edgemarkerlist)
#else /* not ANSI_DECLARATORS */
void writeedges(m, b, edgelist, edgemarkerlist)
struct mesh *m;
struct behavior *b;
int **edgelist;
int **edgemarkerlist;
#endif /* not ANSI_DECLARATORS */
X
#else /* not TRILIBRARY */
X
#ifdef ANSI_DECLARATORS
void writeedges(struct mesh *m, struct behavior *b, char *edgefilename,
X                int argc, char **argv)
#else /* not ANSI_DECLARATORS */
void writeedges(m, b, edgefilename, argc, argv)
struct mesh *m;
struct behavior *b;
char *edgefilename;
int argc;
char **argv;
#endif /* not ANSI_DECLARATORS */
X
#endif /* not TRILIBRARY */
X
{
#ifdef TRILIBRARY
X  int *elist;
X  int *emlist;
X  int index;
#else /* not TRILIBRARY */
X  FILE *outfile;
#endif /* not TRILIBRARY */
X  struct otri triangleloop, trisym;
X  struct osub checkmark;
X  vertex p1, p2;
X  long edgenumber;
X  triangle ptr;                         /* Temporary variable used by sym(). */
X  subseg sptr;                      /* Temporary variable used by tspivot(). */
X
#ifdef TRILIBRARY
X  if (!b->quiet) {
X    printf("Writing edges.\n");
X  }
X  /* Allocate memory for edges if necessary. */
X  if (*edgelist == (int *) NULL) {
X    *edgelist = (int *) trimalloc((int) (m->edges * 2 * sizeof(int)));
X  }
X  /* Allocate memory for edge markers if necessary. */
X  if (!b->nobound && (*edgemarkerlist == (int *) NULL)) {
X    *edgemarkerlist = (int *) trimalloc((int) (m->edges * sizeof(int)));
X  }
X  elist = *edgelist;
X  emlist = *edgemarkerlist;
X  index = 0;
#else /* not TRILIBRARY */
X  if (!b->quiet) {
X    printf("Writing %s.\n", edgefilename);
X  }
X  outfile = fopen(edgefilename, "w");
X  if (outfile == (FILE *) NULL) {
X    printf("  Error:  Cannot create file %s.\n", edgefilename);
X    triexit(1);
X  }
X  /* Number of edges, number of boundary markers (zero or one). */
X  fprintf(outfile, "%ld  %d\n", m->edges, 1 - b->nobound);
#endif /* not TRILIBRARY */
X
X  traversalinit(&m->triangles);
X  triangleloop.tri = triangletraverse(m);
X  edgenumber = b->firstnumber;
X  /* To loop over the set of edges, loop over all triangles, and look at   */
X  /*   the three edges of each triangle.  If there isn't another triangle  */
X  /*   adjacent to the edge, operate on the edge.  If there is another     */
X  /*   adjacent triangle, operate on the edge only if the current triangle */
X  /*   has a smaller pointer than its neighbor.  This way, each edge is    */
X  /*   considered only once.                                               */
X  while (triangleloop.tri != (triangle *) NULL) {
X    for (triangleloop.orient = 0; triangleloop.orient < 3;
X         triangleloop.orient++) {
X      sym(triangleloop, trisym);
X      if ((triangleloop.tri < trisym.tri) || (trisym.tri == m->dummytri)) {
X        org(triangleloop, p1);
X        dest(triangleloop, p2);
#ifdef TRILIBRARY
X        elist[index++] = vertexmark(p1);
X        elist[index++] = vertexmark(p2);
#endif /* TRILIBRARY */
X        if (b->nobound) {
#ifndef TRILIBRARY
X          /* Edge number, indices of two endpoints. */
X          fprintf(outfile, "%4ld   %d  %d\n", edgenumber,
X                  vertexmark(p1), vertexmark(p2));
#endif /* not TRILIBRARY */
X        } else {
X          /* Edge number, indices of two endpoints, and a boundary marker. */
X          /*   If there's no subsegment, the boundary marker is zero.      */
X          if (b->usesegments) {
X            tspivot(triangleloop, checkmark);
X            if (checkmark.ss == m->dummysub) {
#ifdef TRILIBRARY
X              emlist[edgenumber - b->firstnumber] = 0;
#else /* not TRILIBRARY */
X              fprintf(outfile, "%4ld   %d  %d  %d\n", edgenumber,
X                      vertexmark(p1), vertexmark(p2), 0);
#endif /* not TRILIBRARY */
X            } else {
#ifdef TRILIBRARY
X              emlist[edgenumber - b->firstnumber] = mark(checkmark);
#else /* not TRILIBRARY */
X              fprintf(outfile, "%4ld   %d  %d  %d\n", edgenumber,
X                      vertexmark(p1), vertexmark(p2), mark(checkmark));
#endif /* not TRILIBRARY */
X            }
X          } else {
#ifdef TRILIBRARY
X            emlist[edgenumber - b->firstnumber] = trisym.tri == m->dummytri;
#else /* not TRILIBRARY */
X            fprintf(outfile, "%4ld   %d  %d  %d\n", edgenumber,
X                    vertexmark(p1), vertexmark(p2), trisym.tri == m->dummytri);
#endif /* not TRILIBRARY */
X          }
X        }
X        edgenumber++;
X      }
X    }
X    triangleloop.tri = triangletraverse(m);
X  }
X
#ifndef TRILIBRARY
X  finishfile(outfile, argc, argv);
#endif /* not TRILIBRARY */
}
X
/*****************************************************************************/
/*                                                                           */
/*  writevoronoi()   Write the Voronoi diagram to a .v.node and .v.edge      */
/*                   file.                                                   */
/*                                                                           */
/*  The Voronoi diagram is the geometric dual of the Delaunay triangulation. */
/*  Hence, the Voronoi vertices are listed by traversing the Delaunay        */
/*  triangles, and the Voronoi edges are listed by traversing the Delaunay   */
/*  edges.                                                                   */
/*                                                                           */
/*  WARNING:  In order to assign numbers to the Voronoi vertices, this       */
/*  procedure messes up the subsegments or the extra nodes of every          */
/*  element.  Hence, you should call this procedure last.                    */
/*                                                                           */
/*****************************************************************************/
X
#ifdef TRILIBRARY
X
#ifdef ANSI_DECLARATORS
void writevoronoi(struct mesh *m, struct behavior *b, REAL **vpointlist,
X                  REAL **vpointattriblist, int **vpointmarkerlist,
X                  int **vedgelist, int **vedgemarkerlist, REAL **vnormlist)
#else /* not ANSI_DECLARATORS */
void writevoronoi(m, b, vpointlist, vpointattriblist, vpointmarkerlist,
X                  vedgelist, vedgemarkerlist, vnormlist)
struct mesh *m;
struct behavior *b;
REAL **vpointlist;
REAL **vpointattriblist;
int **vpointmarkerlist;
int **vedgelist;
int **vedgemarkerlist;
REAL **vnormlist;
#endif /* not ANSI_DECLARATORS */
X
#else /* not TRILIBRARY */
X
#ifdef ANSI_DECLARATORS
void writevoronoi(struct mesh *m, struct behavior *b, char *vnodefilename,
X                  char *vedgefilename, int argc, char **argv)
#else /* not ANSI_DECLARATORS */
void writevoronoi(m, b, vnodefilename, vedgefilename, argc, argv)
struct mesh *m;
struct behavior *b;
char *vnodefilename;
char *vedgefilename;
int argc;
char **argv;
#endif /* not ANSI_DECLARATORS */
X
#endif /* not TRILIBRARY */
X
{
#ifdef TRILIBRARY
X  REAL *plist;
X  REAL *palist;
X  int *elist;
X  REAL *normlist;
X  int coordindex;
X  int attribindex;
#else /* not TRILIBRARY */
X  FILE *outfile;
#endif /* not TRILIBRARY */
X  struct otri triangleloop, trisym;
X  vertex torg, tdest, tapex;
X  REAL circumcenter[2];
X  REAL xi, eta;
X  long vnodenumber, vedgenumber;
X  int p1, p2;
X  int i;
X  triangle ptr;                         /* Temporary variable used by sym(). */
X
#ifdef TRILIBRARY
X  if (!b->quiet) {
X    printf("Writing Voronoi vertices.\n");
X  }
X  /* Allocate memory for Voronoi vertices if necessary. */
X  if (*vpointlist == (REAL *) NULL) {
X    *vpointlist = (REAL *) trimalloc((int) (m->triangles.items * 2 *
X                                            sizeof(REAL)));
X  }
X  /* Allocate memory for Voronoi vertex attributes if necessary. */
X  if (*vpointattriblist == (REAL *) NULL) {
X    *vpointattriblist = (REAL *) trimalloc((int) (m->triangles.items *
X                                                  m->nextras * sizeof(REAL)));
X  }
X  *vpointmarkerlist = (int *) NULL;
X  plist = *vpointlist;
X  palist = *vpointattriblist;
X  coordindex = 0;
X  attribindex = 0;
#else /* not TRILIBRARY */
X  if (!b->quiet) {
X    printf("Writing %s.\n", vnodefilename);
X  }
X  outfile = fopen(vnodefilename, "w");
X  if (outfile == (FILE *) NULL) {
X    printf("  Error:  Cannot create file %s.\n", vnodefilename);
X    triexit(1);
X  }
X  /* Number of triangles, two dimensions, number of vertex attributes, */
X  /*   no markers.                                                     */
X  fprintf(outfile, "%ld  %d  %d  %d\n", m->triangles.items, 2, m->nextras, 0);
#endif /* not TRILIBRARY */
X
X  traversalinit(&m->triangles);
X  triangleloop.tri = triangletraverse(m);
X  triangleloop.orient = 0;
X  vnodenumber = b->firstnumber;
X  while (triangleloop.tri != (triangle *) NULL) {
X    org(triangleloop, torg);
X    dest(triangleloop, tdest);
X    apex(triangleloop, tapex);
X    findcircumcenter(m, b, torg, tdest, tapex, circumcenter, &xi, &eta, 0);
#ifdef TRILIBRARY
X    /* X and y coordinates. */
X    plist[coordindex++] = circumcenter[0];
X    plist[coordindex++] = circumcenter[1];
X    for (i = 2; i < 2 + m->nextras; i++) {
X      /* Interpolate the vertex attributes at the circumcenter. */
X      palist[attribindex++] = torg[i] + xi * (tdest[i] - torg[i])
X                                     + eta * (tapex[i] - torg[i]);
X    }
#else /* not TRILIBRARY */
X    /* Voronoi vertex number, x and y coordinates. */
X    fprintf(outfile, "%4ld    %.17g  %.17g", vnodenumber, circumcenter[0],
X            circumcenter[1]);
X    for (i = 2; i < 2 + m->nextras; i++) {
X      /* Interpolate the vertex attributes at the circumcenter. */
X      fprintf(outfile, "  %.17g", torg[i] + xi * (tdest[i] - torg[i])
X                                         + eta * (tapex[i] - torg[i]));
X    }
X    fprintf(outfile, "\n");
#endif /* not TRILIBRARY */
X
X    * (int *) (triangleloop.tri + 6) = (int) vnodenumber;
X    triangleloop.tri = triangletraverse(m);
X    vnodenumber++;
X  }
X
#ifndef TRILIBRARY
X  finishfile(outfile, argc, argv);
#endif /* not TRILIBRARY */
X
#ifdef TRILIBRARY
X  if (!b->quiet) {
X    printf("Writing Voronoi edges.\n");
X  }
X  /* Allocate memory for output Voronoi edges if necessary. */
X  if (*vedgelist == (int *) NULL) {
X    *vedgelist = (int *) trimalloc((int) (m->edges * 2 * sizeof(int)));
X  }
X  *vedgemarkerlist = (int *) NULL;
X  /* Allocate memory for output Voronoi norms if necessary. */
X  if (*vnormlist == (REAL *) NULL) {
X    *vnormlist = (REAL *) trimalloc((int) (m->edges * 2 * sizeof(REAL)));
X  }
X  elist = *vedgelist;
X  normlist = *vnormlist;
X  coordindex = 0;
#else /* not TRILIBRARY */
X  if (!b->quiet) {
X    printf("Writing %s.\n", vedgefilename);
X  }
X  outfile = fopen(vedgefilename, "w");
X  if (outfile == (FILE *) NULL) {
X    printf("  Error:  Cannot create file %s.\n", vedgefilename);
X    triexit(1);
X  }
X  /* Number of edges, zero boundary markers. */
X  fprintf(outfile, "%ld  %d\n", m->edges, 0);
#endif /* not TRILIBRARY */
X
X  traversalinit(&m->triangles);
X  triangleloop.tri = triangletraverse(m);
X  vedgenumber = b->firstnumber;
X  /* To loop over the set of edges, loop over all triangles, and look at   */
X  /*   the three edges of each triangle.  If there isn't another triangle  */
X  /*   adjacent to the edge, operate on the edge.  If there is another     */
X  /*   adjacent triangle, operate on the edge only if the current triangle */
X  /*   has a smaller pointer than its neighbor.  This way, each edge is    */
X  /*   considered only once.                                               */
X  while (triangleloop.tri != (triangle *) NULL) {
X    for (triangleloop.orient = 0; triangleloop.orient < 3;
X         triangleloop.orient++) {
X      sym(triangleloop, trisym);
X      if ((triangleloop.tri < trisym.tri) || (trisym.tri == m->dummytri)) {
X        /* Find the number of this triangle (and Voronoi vertex). */
X        p1 = * (int *) (triangleloop.tri + 6);
X        if (trisym.tri == m->dummytri) {
X          org(triangleloop, torg);
X          dest(triangleloop, tdest);
#ifdef TRILIBRARY
X          /* Copy an infinite ray.  Index of one endpoint, and -1. */
X          elist[coordindex] = p1;
X          normlist[coordindex++] = tdest[1] - torg[1];
X          elist[coordindex] = -1;
X          normlist[coordindex++] = torg[0] - tdest[0];
#else /* not TRILIBRARY */
X          /* Write an infinite ray.  Edge number, index of one endpoint, -1, */
X          /*   and x and y coordinates of a vector representing the          */
X          /*   direction of the ray.                                         */
X          fprintf(outfile, "%4ld   %d  %d   %.17g  %.17g\n", vedgenumber,
X                  p1, -1, tdest[1] - torg[1], torg[0] - tdest[0]);
#endif /* not TRILIBRARY */
X        } else {
X          /* Find the number of the adjacent triangle (and Voronoi vertex). */
X          p2 = * (int *) (trisym.tri + 6);
X          /* Finite edge.  Write indices of two endpoints. */
#ifdef TRILIBRARY
X          elist[coordindex] = p1;
X          normlist[coordindex++] = 0.0;
X          elist[coordindex] = p2;
X          normlist[coordindex++] = 0.0;
#else /* not TRILIBRARY */
X          fprintf(outfile, "%4ld   %d  %d\n", vedgenumber, p1, p2);
#endif /* not TRILIBRARY */
X        }
X        vedgenumber++;
X      }
X    }
X    triangleloop.tri = triangletraverse(m);
X  }
X
#ifndef TRILIBRARY
X  finishfile(outfile, argc, argv);
#endif /* not TRILIBRARY */
}
X
#ifdef TRILIBRARY
X
#ifdef ANSI_DECLARATORS
void writeneighbors(struct mesh *m, struct behavior *b, int **neighborlist)
#else /* not ANSI_DECLARATORS */
void writeneighbors(m, b, neighborlist)
struct mesh *m;
struct behavior *b;
int **neighborlist;
#endif /* not ANSI_DECLARATORS */
X
#else /* not TRILIBRARY */
X
#ifdef ANSI_DECLARATORS
void writeneighbors(struct mesh *m, struct behavior *b, char *neighborfilename,
X                    int argc, char **argv)
#else /* not ANSI_DECLARATORS */
void writeneighbors(m, b, neighborfilename, argc, argv)
struct mesh *m;
struct behavior *b;
char *neighborfilename;
int argc;
char **argv;
#endif /* not ANSI_DECLARATORS */
X
#endif /* not TRILIBRARY */
X
{
#ifdef TRILIBRARY
X  int *nlist;
X  int index;
#else /* not TRILIBRARY */
X  FILE *outfile;
#endif /* not TRILIBRARY */
X  struct otri triangleloop, trisym;
X  long elementnumber;
X  int neighbor1, neighbor2, neighbor3;
X  triangle ptr;                         /* Temporary variable used by sym(). */
X
#ifdef TRILIBRARY
X  if (!b->quiet) {
X    printf("Writing neighbors.\n");
X  }
X  /* Allocate memory for neighbors if necessary. */
X  if (*neighborlist == (int *) NULL) {
X    *neighborlist = (int *) trimalloc((int) (m->triangles.items * 3 *
X                                             sizeof(int)));
X  }
X  nlist = *neighborlist;
X  index = 0;
#else /* not TRILIBRARY */
X  if (!b->quiet) {
X    printf("Writing %s.\n", neighborfilename);
X  }
X  outfile = fopen(neighborfilename, "w");
X  if (outfile == (FILE *) NULL) {
X    printf("  Error:  Cannot create file %s.\n", neighborfilename);
X    triexit(1);
X  }
X  /* Number of triangles, three neighbors per triangle. */
X  fprintf(outfile, "%ld  %d\n", m->triangles.items, 3);
#endif /* not TRILIBRARY */
X
X  traversalinit(&m->triangles);
X  triangleloop.tri = triangletraverse(m);
X  triangleloop.orient = 0;
X  elementnumber = b->firstnumber;
X  while (triangleloop.tri != (triangle *) NULL) {
X    * (int *) (triangleloop.tri + 6) = (int) elementnumber;
X    triangleloop.tri = triangletraverse(m);
X    elementnumber++;
X  }
X  * (int *) (m->dummytri + 6) = -1;
X
X  traversalinit(&m->triangles);
X  triangleloop.tri = triangletraverse(m);
X  elementnumber = b->firstnumber;
X  while (triangleloop.tri != (triangle *) NULL) {
X    triangleloop.orient = 1;
X    sym(triangleloop, trisym);
X    neighbor1 = * (int *) (trisym.tri + 6);
X    triangleloop.orient = 2;
X    sym(triangleloop, trisym);
X    neighbor2 = * (int *) (trisym.tri + 6);
X    triangleloop.orient = 0;
X    sym(triangleloop, trisym);
X    neighbor3 = * (int *) (trisym.tri + 6);
#ifdef TRILIBRARY
X    nlist[index++] = neighbor1;
X    nlist[index++] = neighbor2;
X    nlist[index++] = neighbor3;
#else /* not TRILIBRARY */
X    /* Triangle number, neighboring triangle numbers. */
X    fprintf(outfile, "%4ld    %d  %d  %d\n", elementnumber,
X            neighbor1, neighbor2, neighbor3);
#endif /* not TRILIBRARY */
X
X    triangleloop.tri = triangletraverse(m);
X    elementnumber++;
X  }
X
#ifndef TRILIBRARY
X  finishfile(outfile, argc, argv);
#endif /* not TRILIBRARY */
}
X
/*****************************************************************************/
/*                                                                           */
/*  writeoff()   Write the triangulation to an .off file.                    */
/*                                                                           */
/*  OFF stands for the Object File Format, a format used by the Geometry     */
/*  Center's Geomview package.                                               */
/*                                                                           */
/*****************************************************************************/
X
#ifndef TRILIBRARY
X
#ifdef ANSI_DECLARATORS
void writeoff(struct mesh *m, struct behavior *b, char *offfilename,
X              int argc, char **argv)
#else /* not ANSI_DECLARATORS */
void writeoff(m, b, offfilename, argc, argv)
struct mesh *m;
struct behavior *b;
char *offfilename;
int argc;
char **argv;
#endif /* not ANSI_DECLARATORS */
X
{
X  FILE *outfile;
X  struct otri triangleloop;
X  vertex vertexloop;
X  vertex p1, p2, p3;
X  long outvertices;
X
X  if (!b->quiet) {
X    printf("Writing %s.\n", offfilename);
X  }
X
X  if (b->jettison) {
X    outvertices = m->vertices.items - m->undeads;
X  } else {
X    outvertices = m->vertices.items;
X  }
X
X  outfile = fopen(offfilename, "w");
X  if (outfile == (FILE *) NULL) {
X    printf("  Error:  Cannot create file %s.\n", offfilename);
X    triexit(1);
X  }
X  /* Number of vertices, triangles, and edges. */
X  fprintf(outfile, "OFF\n%ld  %ld  %ld\n", outvertices, m->triangles.items,
X          m->edges);
X
X  /* Write the vertices. */
X  traversalinit(&m->vertices);
X  vertexloop = vertextraverse(m);
X  while (vertexloop != (vertex) NULL) {
X    if (!b->jettison || (vertextype(vertexloop) != UNDEADVERTEX)) {
X      /* The "0.0" is here because the OFF format uses 3D coordinates. */
X      fprintf(outfile, " %.17g  %.17g  %.17g\n", vertexloop[0], vertexloop[1],
X              0.0);
X    }
X    vertexloop = vertextraverse(m);
X  }
X
X  /* Write the triangles. */
X  traversalinit(&m->triangles);
X  triangleloop.tri = triangletraverse(m);
X  triangleloop.orient = 0;
X  while (triangleloop.tri != (triangle *) NULL) {
X    org(triangleloop, p1);
X    dest(triangleloop, p2);
X    apex(triangleloop, p3);
X    /* The "3" means a three-vertex polygon. */
X    fprintf(outfile, " 3   %4d  %4d  %4d\n", vertexmark(p1) - b->firstnumber,
X            vertexmark(p2) - b->firstnumber, vertexmark(p3) - b->firstnumber);
X    triangleloop.tri = triangletraverse(m);
X  }
X  finishfile(outfile, argc, argv);
}
X
#endif /* not TRILIBRARY */
X
/**                                                                         **/
/**                                                                         **/
/********* File I/O routines end here                                *********/
X
/*****************************************************************************/
/*                                                                           */
/*  quality_statistics()   Print statistics about the quality of the mesh.   */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
void quality_statistics(struct mesh *m, struct behavior *b)
#else /* not ANSI_DECLARATORS */
void quality_statistics(m, b)
struct mesh *m;
struct behavior *b;
#endif /* not ANSI_DECLARATORS */
X
{
X  struct otri triangleloop;
X  vertex p[3];
X  REAL cossquaretable[8];
X  REAL ratiotable[16];
X  REAL dx[3], dy[3];
X  REAL edgelength[3];
X  REAL dotproduct;
X  REAL cossquare;
X  REAL triarea;
X  REAL shortest, longest;
X  REAL trilongest2;
X  REAL smallestarea, biggestarea;
X  REAL triminaltitude2;
X  REAL minaltitude;
X  REAL triaspect2;
X  REAL worstaspect;
X  REAL smallestangle, biggestangle;
X  REAL radconst, degconst;
X  int angletable[18];
X  int aspecttable[16];
X  int aspectindex;
X  int tendegree;
X  int acutebiggest;
X  int i, ii, j, k;
X
X  printf("Mesh quality statistics:\n\n");
X  radconst = PI / 18.0;
X  degconst = 180.0 / PI;
X  for (i = 0; i < 8; i++) {
X    cossquaretable[i] = cos(radconst * (REAL) (i + 1));
X    cossquaretable[i] = cossquaretable[i] * cossquaretable[i];
X  }
X  for (i = 0; i < 18; i++) {
X    angletable[i] = 0;
X  }
X
X  ratiotable[0]  =      1.5;      ratiotable[1]  =     2.0;
X  ratiotable[2]  =      2.5;      ratiotable[3]  =     3.0;
X  ratiotable[4]  =      4.0;      ratiotable[5]  =     6.0;
X  ratiotable[6]  =     10.0;      ratiotable[7]  =    15.0;
X  ratiotable[8]  =     25.0;      ratiotable[9]  =    50.0;
X  ratiotable[10] =    100.0;      ratiotable[11] =   300.0;
X  ratiotable[12] =   1000.0;      ratiotable[13] = 10000.0;
X  ratiotable[14] = 100000.0;      ratiotable[15] =     0.0;
X  for (i = 0; i < 16; i++) {
X    aspecttable[i] = 0;
X  }
X
X  worstaspect = 0.0;
X  minaltitude = m->xmax - m->xmin + m->ymax - m->ymin;
X  minaltitude = minaltitude * minaltitude;
X  shortest = minaltitude;
X  longest = 0.0;
X  smallestarea = minaltitude;
X  biggestarea = 0.0;
X  worstaspect = 0.0;
X  smallestangle = 0.0;
X  biggestangle = 2.0;
X  acutebiggest = 1;
X
X  traversalinit(&m->triangles);
X  triangleloop.tri = triangletraverse(m);
X  triangleloop.orient = 0;
X  while (triangleloop.tri != (triangle *) NULL) {
X    org(triangleloop, p[0]);
X    dest(triangleloop, p[1]);
X    apex(triangleloop, p[2]);
X    trilongest2 = 0.0;
X
X    for (i = 0; i < 3; i++) {
X      j = plus1mod3[i];
X      k = minus1mod3[i];
X      dx[i] = p[j][0] - p[k][0];
X      dy[i] = p[j][1] - p[k][1];
X      edgelength[i] = dx[i] * dx[i] + dy[i] * dy[i];
X      if (edgelength[i] > trilongest2) {
X        trilongest2 = edgelength[i];
X      }
X      if (edgelength[i] > longest) {
X        longest = edgelength[i];
X      }
X      if (edgelength[i] < shortest) {
X        shortest = edgelength[i];
X      }
X    }
X
X    triarea = counterclockwise(m, b, p[0], p[1], p[2]);
X    if (triarea < smallestarea) {
X      smallestarea = triarea;
X    }
X    if (triarea > biggestarea) {
X      biggestarea = triarea;
X    }
X    triminaltitude2 = triarea * triarea / trilongest2;
X    if (triminaltitude2 < minaltitude) {
X      minaltitude = triminaltitude2;
X    }
X    triaspect2 = trilongest2 / triminaltitude2;
X    if (triaspect2 > worstaspect) {
X      worstaspect = triaspect2;
X    }
X    aspectindex = 0;
X    while ((triaspect2 > ratiotable[aspectindex] * ratiotable[aspectindex])
X           && (aspectindex < 15)) {
X      aspectindex++;
X    }
X    aspecttable[aspectindex]++;
X
X    for (i = 0; i < 3; i++) {
X      j = plus1mod3[i];
X      k = minus1mod3[i];
X      dotproduct = dx[j] * dx[k] + dy[j] * dy[k];
X      cossquare = dotproduct * dotproduct / (edgelength[j] * edgelength[k]);
X      tendegree = 8;
X      for (ii = 7; ii >= 0; ii--) {
X        if (cossquare > cossquaretable[ii]) {
X          tendegree = ii;
X        }
X      }
X      if (dotproduct <= 0.0) {
X        angletable[tendegree]++;
X        if (cossquare > smallestangle) {
X          smallestangle = cossquare;
X        }
X        if (acutebiggest && (cossquare < biggestangle)) {
X          biggestangle = cossquare;
X        }
X      } else {
X        angletable[17 - tendegree]++;
X        if (acutebiggest || (cossquare > biggestangle)) {
X          biggestangle = cossquare;
X          acutebiggest = 0;
X        }
X      }
X    }
X    triangleloop.tri = triangletraverse(m);
X  }
X
X  shortest = sqrt(shortest);
X  longest = sqrt(longest);
X  minaltitude = sqrt(minaltitude);
X  worstaspect = sqrt(worstaspect);
X  smallestarea *= 0.5;
X  biggestarea *= 0.5;
X  if (smallestangle >= 1.0) {
X    smallestangle = 0.0;
X  } else {
X    smallestangle = degconst * acos(sqrt(smallestangle));
X  }
X  if (biggestangle >= 1.0) {
X    biggestangle = 180.0;
X  } else {
X    if (acutebiggest) {
X      biggestangle = degconst * acos(sqrt(biggestangle));
X    } else {
X      biggestangle = 180.0 - degconst * acos(sqrt(biggestangle));
X    }
X  }
X
X  printf("  Smallest area: %16.5g   |  Largest area: %16.5g\n",
X         smallestarea, biggestarea);
X  printf("  Shortest edge: %16.5g   |  Longest edge: %16.5g\n",
X         shortest, longest);
X  printf("  Shortest altitude: %12.5g   |  Largest aspect ratio: %8.5g\n\n",
X         minaltitude, worstaspect);
X
X  printf("  Triangle aspect ratio histogram:\n");
X  printf("  1.1547 - %-6.6g    :  %8d    | %6.6g - %-6.6g     :  %8d\n",
X         ratiotable[0], aspecttable[0], ratiotable[7], ratiotable[8],
X         aspecttable[8]);
X  for (i = 1; i < 7; i++) {
X    printf("  %6.6g - %-6.6g    :  %8d    | %6.6g - %-6.6g     :  %8d\n",
X           ratiotable[i - 1], ratiotable[i], aspecttable[i],
X           ratiotable[i + 7], ratiotable[i + 8], aspecttable[i + 8]);
X  }
X  printf("  %6.6g - %-6.6g    :  %8d    | %6.6g -            :  %8d\n",
X         ratiotable[6], ratiotable[7], aspecttable[7], ratiotable[14],
X         aspecttable[15]);
X  printf("  (Aspect ratio is longest edge divided by shortest altitude)\n\n");
X
X  printf("  Smallest angle: %15.5g   |  Largest angle: %15.5g\n\n",
X         smallestangle, biggestangle);
X
X  printf("  Angle histogram:\n");
X  for (i = 0; i < 9; i++) {
X    printf("    %3d - %3d degrees:  %8d    |    %3d - %3d degrees:  %8d\n",
X           i * 10, i * 10 + 10, angletable[i],
X           i * 10 + 90, i * 10 + 100, angletable[i + 9]);
X  }
X  printf("\n");
}
X
/*****************************************************************************/
/*                                                                           */
/*  statistics()   Print all sorts of cool facts.                            */
/*                                                                           */
/*****************************************************************************/
X
#ifdef ANSI_DECLARATORS
void statistics(struct mesh *m, struct behavior *b)
#else /* not ANSI_DECLARATORS */
void statistics(m, b)
struct mesh *m;
struct behavior *b;
#endif /* not ANSI_DECLARATORS */
X
{
X  printf("\nStatistics:\n\n");
X  printf("  Input vertices: %d\n", m->invertices);
X  if (b->refine) {
X    printf("  Input triangles: %d\n", m->inelements);
X  }
X  if (b->poly) {
X    printf("  Input segments: %d\n", m->insegments);
X    if (!b->refine) {
X      printf("  Input holes: %d\n", m->holes);
X    }
X  }
X
X  printf("\n  Mesh vertices: %ld\n", m->vertices.items - m->undeads);
X  printf("  Mesh triangles: %ld\n", m->triangles.items);
X  printf("  Mesh edges: %ld\n", m->edges);
X  printf("  Mesh exterior boundary edges: %ld\n", m->hullsize);
X  if (b->poly || b->refine) {
X    printf("  Mesh interior boundary edges: %ld\n",
X           m->subsegs.items - m->hullsize);
X    printf("  Mesh subsegments (constrained edges): %ld\n",
X           m->subsegs.items);
X  }
X  printf("\n");
X
X  if (b->verbose) {
X    quality_statistics(m, b);
X    printf("Memory allocation statistics:\n\n");
X    printf("  Maximum number of vertices: %ld\n", m->vertices.maxitems);
X    printf("  Maximum number of triangles: %ld\n", m->triangles.maxitems);
X    if (m->subsegs.maxitems > 0) {
X      printf("  Maximum number of subsegments: %ld\n", m->subsegs.maxitems);
X    }
X    if (m->viri.maxitems > 0) {
X      printf("  Maximum number of viri: %ld\n", m->viri.maxitems);
X    }
X    if (m->badsubsegs.maxitems > 0) {
X      printf("  Maximum number of encroached subsegments: %ld\n",
X             m->badsubsegs.maxitems);
X    }
X    if (m->badtriangles.maxitems > 0) {
X      printf("  Maximum number of bad triangles: %ld\n",
X             m->badtriangles.maxitems);
X    }
X    if (m->flipstackers.maxitems > 0) {
X      printf("  Maximum number of stacked triangle flips: %ld\n",
X             m->flipstackers.maxitems);
X    }
X    if (m->splaynodes.maxitems > 0) {
X      printf("  Maximum number of splay tree nodes: %ld\n",
X             m->splaynodes.maxitems);
X    }
X    printf("  Approximate heap memory use (bytes): %ld\n\n",
X           m->vertices.maxitems * m->vertices.itembytes +
X           m->triangles.maxitems * m->triangles.itembytes +
X           m->subsegs.maxitems * m->subsegs.itembytes +
X           m->viri.maxitems * m->viri.itembytes +
X           m->badsubsegs.maxitems * m->badsubsegs.itembytes +
X           m->badtriangles.maxitems * m->badtriangles.itembytes +
X           m->flipstackers.maxitems * m->flipstackers.itembytes +
X           m->splaynodes.maxitems * m->splaynodes.itembytes);
X
X    printf("Algorithmic statistics:\n\n");
X    if (!b->weighted) {
X      printf("  Number of incircle tests: %ld\n", m->incirclecount);
X    } else {
X      printf("  Number of 3D orientation tests: %ld\n", m->orient3dcount);
X    }
X    printf("  Number of 2D orientation tests: %ld\n", m->counterclockcount);
X    if (m->hyperbolacount > 0) {
X      printf("  Number of right-of-hyperbola tests: %ld\n",
X             m->hyperbolacount);
X    }
X    if (m->circletopcount > 0) {
X      printf("  Number of circle top computations: %ld\n",
X             m->circletopcount);
X    }
X    if (m->circumcentercount > 0) {
X      printf("  Number of triangle circumcenter computations: %ld\n",
X             m->circumcentercount);
X    }
X    printf("\n");
X  }
}
X
/*****************************************************************************/
/*                                                                           */
/*  main() or triangulate()   Gosh, do everything.                           */
/*                                                                           */
/*  The sequence is roughly as follows.  Many of these steps can be skipped, */
/*  depending on the command line switches.                                  */
/*                                                                           */
/*  - Initialize constants and parse the command line.                       */
/*  - Read the vertices from a file and either                               */
/*    - triangulate them (no -r), or                                         */
/*    - read an old mesh from files and reconstruct it (-r).                 */
/*  - Insert the PSLG segments (-p), and possibly segments on the convex     */
/*      hull (-c).                                                           */
/*  - Read the holes (-p), regional attributes (-pA), and regional area      */
/*      constraints (-pa).  Carve the holes and concavities, and spread the  */
/*      regional attributes and area constraints.                            */
/*  - Enforce the constraints on minimum angle (-q) and maximum area (-a).   */
/*      Also enforce the conforming Delaunay property (-q and -a).           */
/*  - Compute the number of edges in the resulting mesh.                     */
/*  - Promote the mesh's linear triangles to higher order elements (-o).     */
/*  - Write the output files and print the statistics.                       */
/*  - Check the consistency and Delaunay property of the mesh (-C).          */
/*                                                                           */
/*****************************************************************************/
X
#ifdef TRILIBRARY
X
#ifdef ANSI_DECLARATORS
void triangulate(char *triswitches, struct triangulateio *in,
X                 struct triangulateio *out, struct triangulateio *vorout)
#else /* not ANSI_DECLARATORS */
void triangulate(triswitches, in, out, vorout)
char *triswitches;
struct triangulateio *in;
struct triangulateio *out;
struct triangulateio *vorout;
#endif /* not ANSI_DECLARATORS */
X
#else /* not TRILIBRARY */
X
#ifdef ANSI_DECLARATORS
int main(int argc, char **argv)
#else /* not ANSI_DECLARATORS */
int main(argc, argv)
int argc;
char **argv;
#endif /* not ANSI_DECLARATORS */
X
#endif /* not TRILIBRARY */
X
{
X  struct mesh m;
X  struct behavior b;
X  REAL *holearray;                                        /* Array of holes. */
X  REAL *regionarray;   /* Array of regional attributes and area constraints. */
#ifndef TRILIBRARY
X  FILE *polyfile;
#endif /* not TRILIBRARY */
#ifndef NO_TIMER
X  /* Variables for timing the performance of Triangle.  The types are */
X  /*   defined in sys/time.h.                                         */
X  struct timeval tv0, tv1, tv2, tv3, tv4, tv5, tv6;
X  struct timezone tz;
#endif /* not NO_TIMER */
X
#ifndef NO_TIMER
X  gettimeofday(&tv0, &tz);
#endif /* not NO_TIMER */
X
X  triangleinit(&m);
#ifdef TRILIBRARY
X  parsecommandline(1, &triswitches, &b);
#else /* not TRILIBRARY */
X  parsecommandline(argc, argv, &b);
#endif /* not TRILIBRARY */
X  m.steinerleft = b.steiner;
X
#ifdef TRILIBRARY
X  transfernodes(&m, &b, in->pointlist, in->pointattributelist,
X                in->pointmarkerlist, in->numberofpoints,
X                in->numberofpointattributes);
#else /* not TRILIBRARY */
X  readnodes(&m, &b, b.innodefilename, b.inpolyfilename, &polyfile);
#endif /* not TRILIBRARY */
X
#ifndef NO_TIMER
X  if (!b.quiet) {
X    gettimeofday(&tv1, &tz);
X  }
#endif /* not NO_TIMER */
X
#ifdef CDT_ONLY
X  m.hullsize = delaunay(&m, &b);                /* Triangulate the vertices. */
#else /* not CDT_ONLY */
X  if (b.refine) {
X    /* Read and reconstruct a mesh. */
#ifdef TRILIBRARY
X    m.hullsize = reconstruct(&m, &b, in->trianglelist,
X                             in->triangleattributelist, in->trianglearealist,
X                             in->numberoftriangles, in->numberofcorners,
X                             in->numberoftriangleattributes,
X                             in->segmentlist, in->segmentmarkerlist,
X                             in->numberofsegments);
#else /* not TRILIBRARY */
X    m.hullsize = reconstruct(&m, &b, b.inelefilename, b.areafilename,
X                             b.inpolyfilename, polyfile);
#endif /* not TRILIBRARY */
X  } else {
X    m.hullsize = delaunay(&m, &b);              /* Triangulate the vertices. */
X  }
#endif /* not CDT_ONLY */
X
#ifndef NO_TIMER
X  if (!b.quiet) {
X    gettimeofday(&tv2, &tz);
X    if (b.refine) {
X      printf("Mesh reconstruction");
X    } else {
X      printf("Delaunay");
X    }
X    printf(" milliseconds:  %ld\n", 1000l * (tv2.tv_sec - tv1.tv_sec) +
X           (tv2.tv_usec - tv1.tv_usec) / 1000l);
X  }
#endif /* not NO_TIMER */
X
X  /* Ensure that no vertex can be mistaken for a triangular bounding */
X  /*   box vertex in insertvertex().                                 */
X  m.infvertex1 = (vertex) NULL;
X  m.infvertex2 = (vertex) NULL;
X  m.infvertex3 = (vertex) NULL;
X
X  if (b.usesegments) {
X    m.checksegments = 1;                /* Segments will be introduced next. */
X    if (!b.refine) {
X      /* Insert PSLG segments and/or convex hull segments. */
#ifdef TRILIBRARY
X      formskeleton(&m, &b, in->segmentlist,
X                   in->segmentmarkerlist, in->numberofsegments);
#else /* not TRILIBRARY */
X      formskeleton(&m, &b, polyfile, b.inpolyfilename);
#endif /* not TRILIBRARY */
X    }
X  }
X
#ifndef NO_TIMER
X  if (!b.quiet) {
X    gettimeofday(&tv3, &tz);
X    if (b.usesegments && !b.refine) {
X      printf("Segment milliseconds:  %ld\n",
X             1000l * (tv3.tv_sec - tv2.tv_sec) +
X             (tv3.tv_usec - tv2.tv_usec) / 1000l);
X    }
X  }
#endif /* not NO_TIMER */
X
X  if (b.poly && (m.triangles.items > 0)) {
#ifdef TRILIBRARY
X    holearray = in->holelist;
X    m.holes = in->numberofholes;
X    regionarray = in->regionlist;
X    m.regions = in->numberofregions;
#else /* not TRILIBRARY */
X    readholes(&m, &b, polyfile, b.inpolyfilename, &holearray, &m.holes,
X              &regionarray, &m.regions);
#endif /* not TRILIBRARY */
X    if (!b.refine) {
X      /* Carve out holes and concavities. */
X      carveholes(&m, &b, holearray, m.holes, regionarray, m.regions);
X    }
X  } else {
X    /* Without a PSLG, there can be no holes or regional attributes   */
X    /*   or area constraints.  The following are set to zero to avoid */
X    /*   an accidental free() later.                                  */
X    m.holes = 0;
X    m.regions = 0;
X  }
X
#ifndef NO_TIMER
X  if (!b.quiet) {
X    gettimeofday(&tv4, &tz);
X    if (b.poly && !b.refine) {
X      printf("Hole milliseconds:  %ld\n", 1000l * (tv4.tv_sec - tv3.tv_sec) +
X             (tv4.tv_usec - tv3.tv_usec) / 1000l);
X    }
X  }
#endif /* not NO_TIMER */
X
#ifndef CDT_ONLY
X  if (b.quality && (m.triangles.items > 0)) {
X    enforcequality(&m, &b);           /* Enforce angle and area constraints. */
X  }
#endif /* not CDT_ONLY */
X
#ifndef NO_TIMER
X  if (!b.quiet) {
X    gettimeofday(&tv5, &tz);
#ifndef CDT_ONLY
X    if (b.quality) {
X      printf("Quality milliseconds:  %ld\n",
X             1000l * (tv5.tv_sec - tv4.tv_sec) +
X             (tv5.tv_usec - tv4.tv_usec) / 1000l);
X    }
#endif /* not CDT_ONLY */
X  }
#endif /* not NO_TIMER */
X
X  /* Calculate the number of edges. */
X  m.edges = (3l * m.triangles.items + m.hullsize) / 2l;
X
X  if (b.order > 1) {
X    highorder(&m, &b);       /* Promote elements to higher polynomial order. */
X  }
X  if (!b.quiet) {
X    printf("\n");
X  }
X
#ifdef TRILIBRARY
X  if (b.jettison) {
X    out->numberofpoints = m.vertices.items - m.undeads;
X  } else {
X    out->numberofpoints = m.vertices.items;
X  }
X  out->numberofpointattributes = m.nextras;
X  out->numberoftriangles = m.triangles.items;
X  out->numberofcorners = (b.order + 1) * (b.order + 2) / 2;
X  out->numberoftriangleattributes = m.eextras;
X  out->numberofedges = m.edges;
X  if (b.usesegments) {
X    out->numberofsegments = m.subsegs.items;
X  } else {
X    out->numberofsegments = m.hullsize;
X  }
X  if (vorout != (struct triangulateio *) NULL) {
X    vorout->numberofpoints = m.triangles.items;
X    vorout->numberofpointattributes = m.nextras;
X    vorout->numberofedges = m.edges;
X  }
#endif /* TRILIBRARY */
X  /* If not using iteration numbers, don't write a .node file if one was */
X  /*   read, because the original one would be overwritten!              */
X  if (b.nonodewritten || (b.noiterationnum && m.readnodefile)) {
X    if (!b.quiet) {
#ifdef TRILIBRARY
X      printf("NOT writing vertices.\n");
#else /* not TRILIBRARY */
X      printf("NOT writing a .node file.\n");
#endif /* not TRILIBRARY */
X    }
X    numbernodes(&m, &b);         /* We must remember to number the vertices. */
X  } else {
X    /* writenodes() numbers the vertices too. */
#ifdef TRILIBRARY
X    writenodes(&m, &b, &out->pointlist, &out->pointattributelist,
X               &out->pointmarkerlist);
#else /* not TRILIBRARY */
X    writenodes(&m, &b, b.outnodefilename, argc, argv);
#endif /* TRILIBRARY */
X  }
X  if (b.noelewritten) {
X    if (!b.quiet) {
#ifdef TRILIBRARY
X      printf("NOT writing triangles.\n");
#else /* not TRILIBRARY */
X      printf("NOT writing an .ele file.\n");
#endif /* not TRILIBRARY */
X    }
X  } else {
#ifdef TRILIBRARY
X    writeelements(&m, &b, &out->trianglelist, &out->triangleattributelist);
#else /* not TRILIBRARY */
X    writeelements(&m, &b, b.outelefilename, argc, argv);
#endif /* not TRILIBRARY */
X  }
X  /* The -c switch (convex switch) causes a PSLG to be written */
X  /*   even if none was read.                                  */
X  if (b.poly || b.convex) {
X    /* If not using iteration numbers, don't overwrite the .poly file. */
X    if (b.nopolywritten || b.noiterationnum) {
X      if (!b.quiet) {
#ifdef TRILIBRARY
X        printf("NOT writing segments.\n");
#else /* not TRILIBRARY */
X        printf("NOT writing a .poly file.\n");
#endif /* not TRILIBRARY */
X      }
X    } else {
#ifdef TRILIBRARY
X      writepoly(&m, &b, &out->segmentlist, &out->segmentmarkerlist);
X      out->numberofholes = m.holes;
X      out->numberofregions = m.regions;
X      if (b.poly) {
X        out->holelist = in->holelist;
X        out->regionlist = in->regionlist;
X      } else {
X        out->holelist = (REAL *) NULL;
X        out->regionlist = (REAL *) NULL;
X      }
#else /* not TRILIBRARY */
X      writepoly(&m, &b, b.outpolyfilename, holearray, m.holes, regionarray,
X                m.regions, argc, argv);
#endif /* not TRILIBRARY */
X    }
X  }
#ifndef TRILIBRARY
#ifndef CDT_ONLY
X  if (m.regions > 0) {
X    trifree((VOID *) regionarray);
X  }
#endif /* not CDT_ONLY */
X  if (m.holes > 0) {
X    trifree((VOID *) holearray);
X  }
X  if (b.geomview) {
X    writeoff(&m, &b, b.offfilename, argc, argv);
X  }
#endif /* not TRILIBRARY */
X  if (b.edgesout) {
#ifdef TRILIBRARY
X    writeedges(&m, &b, &out->edgelist, &out->edgemarkerlist);
#else /* not TRILIBRARY */
X    writeedges(&m, &b, b.edgefilename, argc, argv);
#endif /* not TRILIBRARY */
X  }
X  if (b.voronoi) {
#ifdef TRILIBRARY
X    writevoronoi(&m, &b, &vorout->pointlist, &vorout->pointattributelist,
X                 &vorout->pointmarkerlist, &vorout->edgelist,
X                 &vorout->edgemarkerlist, &vorout->normlist);
#else /* not TRILIBRARY */
X    writevoronoi(&m, &b, b.vnodefilename, b.vedgefilename, argc, argv);
#endif /* not TRILIBRARY */
X  }
X  if (b.neighbors) {
#ifdef TRILIBRARY
X    writeneighbors(&m, &b, &out->neighborlist);
#else /* not TRILIBRARY */
X    writeneighbors(&m, &b, b.neighborfilename, argc, argv);
#endif /* not TRILIBRARY */
X  }
X
X  if (!b.quiet) {
#ifndef NO_TIMER
X    gettimeofday(&tv6, &tz);
X    printf("\nOutput milliseconds:  %ld\n",
X           1000l * (tv6.tv_sec - tv5.tv_sec) +
X           (tv6.tv_usec - tv5.tv_usec) / 1000l);
X    printf("Total running milliseconds:  %ld\n",
X           1000l * (tv6.tv_sec - tv0.tv_sec) +
X           (tv6.tv_usec - tv0.tv_usec) / 1000l);
#endif /* not NO_TIMER */
X
X    statistics(&m, &b);
X  }
X
#ifndef REDUCED
X  if (b.docheck) {
X    checkmesh(&m, &b);
X    checkdelaunay(&m, &b);
X  }
#endif /* not REDUCED */
X
X  triangledeinit(&m, &b);
#ifndef TRILIBRARY
X  return 0;
#endif /* not TRILIBRARY */
}
SHAR_EOF
  (set 20 05 07 28 15 11 32 'triangle.c'; eval "$shar_touch") &&
  chmod 0644 'triangle.c' ||
  $echo 'restore of' 'triangle.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'triangle.c:' 'MD5 check failed'
596a68fe946f2935cdffb14f1e2444c4  triangle.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'triangle.c'`"
    test 650942 -eq "$shar_count" ||
    $echo 'triangle.c:' 'original size' '650942,' 'current size' "$shar_count!"
  fi
fi
# ============= triangle.h ==============
if test -f 'triangle.h' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'triangle.h' '(file already exists)'
else
  $echo 'x -' extracting 'triangle.h' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'triangle.h' &&
/*****************************************************************************/
/*                                                                           */
/*  (triangle.h)                                                             */
/*                                                                           */
/*  Include file for programs that call Triangle.                            */
/*                                                                           */
/*  Accompanies Triangle Version 1.6                                         */
/*  July 28, 2005                                                            */
/*                                                                           */
/*  Copyright 1996, 2005                                                     */
/*  Jonathan Richard Shewchuk                                                */
/*  2360 Woolsey #H                                                          */
/*  Berkeley, California  94705-1927                                         */
/*  jrs@cs.berkeley.edu                                                      */
/*                                                                           */
/*****************************************************************************/
X
/*****************************************************************************/
/*                                                                           */
/*  How to call Triangle from another program                                */
/*                                                                           */
/*                                                                           */
/*  If you haven't read Triangle's instructions (run "triangle -h" to read   */
/*  them), you won't understand what follows.                                */
/*                                                                           */
/*  Triangle must be compiled into an object file (triangle.o) with the      */
/*  TRILIBRARY symbol defined (generally by using the -DTRILIBRARY compiler  */
/*  switch).  The makefile included with Triangle will do this for you if    */
/*  you run "make trilibrary".  The resulting object file can be called via  */
/*  the procedure triangulate().                                             */
/*                                                                           */
/*  If the size of the object file is important to you, you may wish to      */
/*  generate a reduced version of triangle.o.  The REDUCED symbol gets rid   */
/*  of all features that are primarily of research interest.  Specifically,  */
/*  the -DREDUCED switch eliminates Triangle's -i, -F, -s, and -C switches.  */
/*  The CDT_ONLY symbol gets rid of all meshing algorithms above and beyond  */
/*  constrained Delaunay triangulation.  Specifically, the -DCDT_ONLY switch */
/*  eliminates Triangle's -r, -q, -a, -u, -D, -Y, -S, and -s switches.       */
/*                                                                           */
/*  IMPORTANT:  These definitions (TRILIBRARY, REDUCED, CDT_ONLY) must be    */
/*  made in the makefile or in triangle.c itself.  Putting these definitions */
/*  in this file (triangle.h) will not create the desired effect.            */
/*                                                                           */
/*                                                                           */
/*  The calling convention for triangulate() follows.                        */
/*                                                                           */
/*      void triangulate(triswitches, in, out, vorout)                       */
/*      char *triswitches;                                                   */
/*      struct triangulateio *in;                                            */
/*      struct triangulateio *out;                                           */
/*      struct triangulateio *vorout;                                        */
/*                                                                           */
/*  `triswitches' is a string containing the command line switches you wish  */
/*  to invoke.  No initial dash is required.  Some suggestions:              */
/*                                                                           */
/*  - You'll probably find it convenient to use the `z' switch so that       */
/*    points (and other items) are numbered from zero.  This simplifies      */
/*    indexing, because the first item of any type always starts at index    */
/*    [0] of the corresponding array, whether that item's number is zero or  */
/*    one.                                                                   */
/*  - You'll probably want to use the `Q' (quiet) switch in your final code, */
/*    but you can take advantage of Triangle's printed output (including the */
/*    `V' switch) while debugging.                                           */
/*  - If you are not using the `q', `a', `u', `D', `j', or `s' switches,     */
/*    then the output points will be identical to the input points, except   */
/*    possibly for the boundary markers.  If you don't need the boundary     */
/*    markers, you should use the `N' (no nodes output) switch to save       */
/*    memory.  (If you do need boundary markers, but need to save memory, a  */
/*    good nasty trick is to set out->pointlist equal to in->pointlist       */
/*    before calling triangulate(), so that Triangle overwrites the input    */
/*    points with identical copies.)                                         */
/*  - The `I' (no iteration numbers) and `g' (.off file output) switches     */
/*    have no effect when Triangle is compiled with TRILIBRARY defined.      */
/*                                                                           */
/*  `in', `out', and `vorout' are descriptions of the input, the output,     */
/*  and the Voronoi output.  If the `v' (Voronoi output) switch is not used, */
/*  `vorout' may be NULL.  `in' and `out' may never be NULL.                 */
/*                                                                           */
/*  Certain fields of the input and output structures must be initialized,   */
/*  as described below.                                                      */
/*                                                                           */
/*****************************************************************************/
X
/*****************************************************************************/
/*                                                                           */
/*  The `triangulateio' structure.                                           */
/*                                                                           */
/*  Used to pass data into and out of the triangulate() procedure.           */
/*                                                                           */
/*                                                                           */
/*  Arrays are used to store points, triangles, markers, and so forth.  In   */
/*  all cases, the first item in any array is stored starting at index [0].  */
/*  However, that item is item number `1' unless the `z' switch is used, in  */
/*  which case it is item number `0'.  Hence, you may find it easier to      */
/*  index points (and triangles in the neighbor list) if you use the `z'     */
/*  switch.  Unless, of course, you're calling Triangle from a Fortran       */
/*  program.                                                                 */
/*                                                                           */
/*  Description of fields (except the `numberof' fields, which are obvious): */
/*                                                                           */
/*  `pointlist':  An array of point coordinates.  The first point's x        */
/*    coordinate is at index [0] and its y coordinate at index [1], followed */
/*    by the coordinates of the remaining points.  Each point occupies two   */
/*    REALs.                                                                 */
/*  `pointattributelist':  An array of point attributes.  Each point's       */
/*    attributes occupy `numberofpointattributes' REALs.                     */
/*  `pointmarkerlist':  An array of point markers; one int per point.        */
/*                                                                           */
/*  `trianglelist':  An array of triangle corners.  The first triangle's     */
/*    first corner is at index [0], followed by its other two corners in     */
/*    counterclockwise order, followed by any other nodes if the triangle    */
/*    represents a nonlinear element.  Each triangle occupies                */
/*    `numberofcorners' ints.                                                */
/*  `triangleattributelist':  An array of triangle attributes.  Each         */
/*    triangle's attributes occupy `numberoftriangleattributes' REALs.       */
/*  `trianglearealist':  An array of triangle area constraints; one REAL per */
/*    triangle.  Input only.                                                 */
/*  `neighborlist':  An array of triangle neighbors; three ints per          */
/*    triangle.  Output only.                                                */
/*                                                                           */
/*  `segmentlist':  An array of segment endpoints.  The first segment's      */
/*    endpoints are at indices [0] and [1], followed by the remaining        */
/*    segments.  Two ints per segment.                                       */
/*  `segmentmarkerlist':  An array of segment markers; one int per segment.  */
/*                                                                           */
/*  `holelist':  An array of holes.  The first hole's x and y coordinates    */
/*    are at indices [0] and [1], followed by the remaining holes.  Two      */
/*    REALs per hole.  Input only, although the pointer is copied to the     */
/*    output structure for your convenience.                                 */
/*                                                                           */
/*  `regionlist':  An array of regional attributes and area constraints.     */
/*    The first constraint's x and y coordinates are at indices [0] and [1], */
/*    followed by the regional attribute at index [2], followed by the       */
/*    maximum area at index [3], followed by the remaining area constraints. */
/*    Four REALs per area constraint.  Note that each regional attribute is  */
/*    used only if you select the `A' switch, and each area constraint is    */
/*    used only if you select the `a' switch (with no number following), but */
/*    omitting one of these switches does not change the memory layout.      */
/*    Input only, although the pointer is copied to the output structure for */
/*    your convenience.                                                      */
/*                                                                           */
/*  `edgelist':  An array of edge endpoints.  The first edge's endpoints are */
/*    at indices [0] and [1], followed by the remaining edges.  Two ints per */
/*    edge.  Output only.                                                    */
/*  `edgemarkerlist':  An array of edge markers; one int per edge.  Output   */
/*    only.                                                                  */
/*  `normlist':  An array of normal vectors, used for infinite rays in       */
/*    Voronoi diagrams.  The first normal vector's x and y magnitudes are    */
/*    at indices [0] and [1], followed by the remaining vectors.  For each   */
/*    finite edge in a Voronoi diagram, the normal vector written is the     */
/*    zero vector.  Two REALs per edge.  Output only.                        */
/*                                                                           */
/*                                                                           */
/*  Any input fields that Triangle will examine must be initialized.         */
/*  Furthermore, for each output array that Triangle will write to, you      */
/*  must either provide space by setting the appropriate pointer to point    */
/*  to the space you want the data written to, or you must initialize the    */
/*  pointer to NULL, which tells Triangle to allocate space for the results. */
/*  The latter option is preferable, because Triangle always knows exactly   */
/*  how much space to allocate.  The former option is provided mainly for    */
/*  people who need to call Triangle from Fortran code, though it also makes */
/*  possible some nasty space-saving tricks, like writing the output to the  */
/*  same arrays as the input.                                                */
/*                                                                           */
/*  Triangle will not free() any input or output arrays, including those it  */
/*  allocates itself; that's up to you.  You should free arrays allocated by */
/*  Triangle by calling the trifree() procedure defined below.  (By default, */
/*  trifree() just calls the standard free() library procedure, but          */
/*  applications that call triangulate() may replace trimalloc() and         */
/*  trifree() in triangle.c to use specialized memory allocators.)           */
/*                                                                           */
/*  Here's a guide to help you decide which fields you must initialize       */
/*  before you call triangulate().                                           */
/*                                                                           */
/*  `in':                                                                    */
/*                                                                           */
/*    - `pointlist' must always point to a list of points; `numberofpoints'  */
/*      and `numberofpointattributes' must be properly set.                  */
/*      `pointmarkerlist' must either be set to NULL (in which case all      */
/*      markers default to zero), or must point to a list of markers.  If    */
/*      `numberofpointattributes' is not zero, `pointattributelist' must     */
/*      point to a list of point attributes.                                 */
/*    - If the `r' switch is used, `trianglelist' must point to a list of    */
/*      triangles, and `numberoftriangles', `numberofcorners', and           */
/*      `numberoftriangleattributes' must be properly set.  If               */
/*      `numberoftriangleattributes' is not zero, `triangleattributelist'    */
/*      must point to a list of triangle attributes.  If the `a' switch is   */
/*      used (with no number following), `trianglearealist' must point to a  */
/*      list of triangle area constraints.  `neighborlist' may be ignored.   */
/*    - If the `p' switch is used, `segmentlist' must point to a list of     */
/*      segments, `numberofsegments' must be properly set, and               */
/*      `segmentmarkerlist' must either be set to NULL (in which case all    */
/*      markers default to zero), or must point to a list of markers.        */
/*    - If the `p' switch is used without the `r' switch, then               */
/*      `numberofholes' and `numberofregions' must be properly set.  If      */
/*      `numberofholes' is not zero, `holelist' must point to a list of      */
/*      holes.  If `numberofregions' is not zero, `regionlist' must point to */
/*      a list of region constraints.                                        */
/*    - If the `p' switch is used, `holelist', `numberofholes',              */
/*      `regionlist', and `numberofregions' is copied to `out'.  (You can    */
/*      nonetheless get away with not initializing them if the `r' switch is */
/*      used.)                                                               */
/*    - `edgelist', `edgemarkerlist', `normlist', and `numberofedges' may be */
/*      ignored.                                                             */
/*                                                                           */
/*  `out':                                                                   */
/*                                                                           */
/*    - `pointlist' must be initialized (NULL or pointing to memory) unless  */
/*      the `N' switch is used.  `pointmarkerlist' must be initialized       */
/*      unless the `N' or `B' switch is used.  If `N' is not used and        */
/*      `in->numberofpointattributes' is not zero, `pointattributelist' must */
/*      be initialized.                                                      */
/*    - `trianglelist' must be initialized unless the `E' switch is used.    */
/*      `neighborlist' must be initialized if the `n' switch is used.  If    */
/*      the `E' switch is not used and (`in->numberofelementattributes' is   */
/*      not zero or the `A' switch is used), `elementattributelist' must be  */
/*      initialized.  `trianglearealist' may be ignored.                     */
/*    - `segmentlist' must be initialized if the `p' or `c' switch is used,  */
/*      and the `P' switch is not used.  `segmentmarkerlist' must also be    */
/*      initialized under these circumstances unless the `B' switch is used. */
/*    - `edgelist' must be initialized if the `e' switch is used.            */
/*      `edgemarkerlist' must be initialized if the `e' switch is used and   */
/*      the `B' switch is not.                                               */
/*    - `holelist', `regionlist', `normlist', and all scalars may be ignored.*/
/*                                                                           */
/*  `vorout' (only needed if `v' switch is used):                            */
/*                                                                           */
/*    - `pointlist' must be initialized.  If `in->numberofpointattributes'   */
/*      is not zero, `pointattributelist' must be initialized.               */
/*      `pointmarkerlist' may be ignored.                                    */
/*    - `edgelist' and `normlist' must both be initialized.                  */
/*      `edgemarkerlist' may be ignored.                                     */
/*    - Everything else may be ignored.                                      */
/*                                                                           */
/*  After a call to triangulate(), the valid fields of `out' and `vorout'    */
/*  will depend, in an obvious way, on the choice of switches used.  Note    */
/*  that when the `p' switch is used, the pointers `holelist' and            */
/*  `regionlist' are copied from `in' to `out', but no new space is          */
/*  allocated; be careful that you don't free() the same array twice.  On    */
/*  the other hand, Triangle will never copy the `pointlist' pointer (or any */
/*  others); new space is allocated for `out->pointlist', or if the `N'      */
/*  switch is used, `out->pointlist' remains uninitialized.                  */
/*                                                                           */
/*  All of the meaningful `numberof' fields will be properly set; for        */
/*  instance, `numberofedges' will represent the number of edges in the      */
/*  triangulation whether or not the edges were written.  If segments are    */
/*  not used, `numberofsegments' will indicate the number of boundary edges. */
/*                                                                           */
/*****************************************************************************/
X
struct triangulateio {
X  REAL *pointlist;                                               /* In / out */
X  REAL *pointattributelist;                                      /* In / out */
X  int *pointmarkerlist;                                          /* In / out */
X  int numberofpoints;                                            /* In / out */
X  int numberofpointattributes;                                   /* In / out */
X
X  int *trianglelist;                                             /* In / out */
X  REAL *triangleattributelist;                                   /* In / out */
X  REAL *trianglearealist;                                         /* In only */
X  int *neighborlist;                                             /* Out only */
X  int numberoftriangles;                                         /* In / out */
X  int numberofcorners;                                           /* In / out */
X  int numberoftriangleattributes;                                /* In / out */
X
X  int *segmentlist;                                              /* In / out */
X  int *segmentmarkerlist;                                        /* In / out */
X  int numberofsegments;                                          /* In / out */
X
X  REAL *holelist;                        /* In / pointer to array copied out */
X  int numberofholes;                                      /* In / copied out */
X
X  REAL *regionlist;                      /* In / pointer to array copied out */
X  int numberofregions;                                    /* In / copied out */
X
X  int *edgelist;                                                 /* Out only */
X  int *edgemarkerlist;            /* Not used with Voronoi diagram; out only */
X  REAL *normlist;                /* Used only with Voronoi diagram; out only */
X  int numberofedges;                                             /* Out only */
};
X
#ifdef ANSI_DECLARATORS
void triangulate(char *, struct triangulateio *, struct triangulateio *,
X                 struct triangulateio *);
void trifree(VOID *memptr);
#else /* not ANSI_DECLARATORS */
void triangulate();
void trifree();
#endif /* not ANSI_DECLARATORS */
SHAR_EOF
  (set 20 05 07 28 11 33 41 'triangle.h'; eval "$shar_touch") &&
  chmod 0644 'triangle.h' ||
  $echo 'restore of' 'triangle.h' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'triangle.h:' 'MD5 check failed'
d5aa503560e3f4caeb93d6ee898722f5  triangle.h
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'triangle.h'`"
    test 21905 -eq "$shar_count" ||
    $echo 'triangle.h:' 'original size' '21905,' 'current size' "$shar_count!"
  fi
fi
# ============= tricall.c ==============
if test -f 'tricall.c' && test "$first_param" != -c; then
  $echo 'x -' SKIPPING 'tricall.c' '(file already exists)'
else
  $echo 'x -' extracting 'tricall.c' '(text)'
  sed 's/^X//' << 'SHAR_EOF' > 'tricall.c' &&
/*****************************************************************************/
/*                                                                           */
/*  (tricall.c)                                                              */
/*                                                                           */
/*  Example program that demonstrates how to call Triangle.                  */
/*                                                                           */
/*  Accompanies Triangle Version 1.6                                         */
/*  July 19, 1996                                                            */
/*                                                                           */
/*  This file is placed in the public domain (but the file that it calls     */
/*  is still copyrighted!) by                                                */
/*  Jonathan Richard Shewchuk                                                */
/*  2360 Woolsey #H                                                          */
/*  Berkeley, California  94705-1927                                         */
/*  jrs@cs.berkeley.edu                                                      */
/*                                                                           */
/*****************************************************************************/
X
/* If SINGLE is defined when triangle.o is compiled, it should also be       */
/*   defined here.  If not, it should not be defined here.                   */
X
/* #define SINGLE */
X
#ifdef SINGLE
#define REAL float
#else /* not SINGLE */
#define REAL double
#endif /* not SINGLE */
X
#include <stdio.h>
#include <stdlib.h>
#include "triangle.h"
X
/*****************************************************************************/
/*                                                                           */
/*  report()   Print the input or output.                                    */
/*                                                                           */
/*****************************************************************************/
X
void report(io, markers, reporttriangles, reportneighbors, reportsegments,
X            reportedges, reportnorms)
struct triangulateio *io;
int markers;
int reporttriangles;
int reportneighbors;
int reportsegments;
int reportedges;
int reportnorms;
{
X  int i, j;
X
X  for (i = 0; i < io->numberofpoints; i++) {
X    printf("Point %4d:", i);
X    for (j = 0; j < 2; j++) {
X      printf("  %.6g", io->pointlist[i * 2 + j]);
X    }
X    if (io->numberofpointattributes > 0) {
X      printf("   attributes");
X    }
X    for (j = 0; j < io->numberofpointattributes; j++) {
X      printf("  %.6g",
X             io->pointattributelist[i * io->numberofpointattributes + j]);
X    }
X    if (markers) {
X      printf("   marker %d\n", io->pointmarkerlist[i]);
X    } else {
X      printf("\n");
X    }
X  }
X  printf("\n");
X
X  if (reporttriangles || reportneighbors) {
X    for (i = 0; i < io->numberoftriangles; i++) {
X      if (reporttriangles) {
X        printf("Triangle %4d points:", i);
X        for (j = 0; j < io->numberofcorners; j++) {
X          printf("  %4d", io->trianglelist[i * io->numberofcorners + j]);
X        }
X        if (io->numberoftriangleattributes > 0) {
X          printf("   attributes");
X        }
X        for (j = 0; j < io->numberoftriangleattributes; j++) {
X          printf("  %.6g", io->triangleattributelist[i *
X                                         io->numberoftriangleattributes + j]);
X        }
X        printf("\n");
X      }
X      if (reportneighbors) {
X        printf("Triangle %4d neighbors:", i);
X        for (j = 0; j < 3; j++) {
X          printf("  %4d", io->neighborlist[i * 3 + j]);
X        }
X        printf("\n");
X      }
X    }
X    printf("\n");
X  }
X
X  if (reportsegments) {
X    for (i = 0; i < io->numberofsegments; i++) {
X      printf("Segment %4d points:", i);
X      for (j = 0; j < 2; j++) {
X        printf("  %4d", io->segmentlist[i * 2 + j]);
X      }
X      if (markers) {
X        printf("   marker %d\n", io->segmentmarkerlist[i]);
X      } else {
X        printf("\n");
X      }
X    }
X    printf("\n");
X  }
X
X  if (reportedges) {
X    for (i = 0; i < io->numberofedges; i++) {
X      printf("Edge %4d points:", i);
X      for (j = 0; j < 2; j++) {
X        printf("  %4d", io->edgelist[i * 2 + j]);
X      }
X      if (reportnorms && (io->edgelist[i * 2 + 1] == -1)) {
X        for (j = 0; j < 2; j++) {
X          printf("  %.6g", io->normlist[i * 2 + j]);
X        }
X      }
X      if (markers) {
X        printf("   marker %d\n", io->edgemarkerlist[i]);
X      } else {
X        printf("\n");
X      }
X    }
X    printf("\n");
X  }
}
X
/*****************************************************************************/
/*                                                                           */
/*  main()   Create and refine a mesh.                                       */
/*                                                                           */
/*****************************************************************************/
X
int main()
{
X  struct triangulateio in, mid, out, vorout;
X
X  /* Define input points. */
X
X  in.numberofpoints = 4;
X  in.numberofpointattributes = 1;
X  in.pointlist = (REAL *) malloc(in.numberofpoints * 2 * sizeof(REAL));
X  in.pointlist[0] = 0.0;
X  in.pointlist[1] = 0.0;
X  in.pointlist[2] = 1.0;
X  in.pointlist[3] = 0.0;
X  in.pointlist[4] = 1.0;
X  in.pointlist[5] = 10.0;
X  in.pointlist[6] = 0.0;
X  in.pointlist[7] = 10.0;
X  in.pointattributelist = (REAL *) malloc(in.numberofpoints *
X                                          in.numberofpointattributes *
X                                          sizeof(REAL));
X  in.pointattributelist[0] = 0.0;
X  in.pointattributelist[1] = 1.0;
X  in.pointattributelist[2] = 11.0;
X  in.pointattributelist[3] = 10.0;
X  in.pointmarkerlist = (int *) malloc(in.numberofpoints * sizeof(int));
X  in.pointmarkerlist[0] = 0;
X  in.pointmarkerlist[1] = 2;
X  in.pointmarkerlist[2] = 0;
X  in.pointmarkerlist[3] = 0;
X
X  in.numberofsegments = 0;
X  in.numberofholes = 0;
X  in.numberofregions = 1;
X  in.regionlist = (REAL *) malloc(in.numberofregions * 4 * sizeof(REAL));
X  in.regionlist[0] = 0.5;
X  in.regionlist[1] = 5.0;
X  in.regionlist[2] = 7.0;            /* Regional attribute (for whole mesh). */
X  in.regionlist[3] = 0.1;          /* Area constraint that will not be used. */
X
X  printf("Input point set:\n\n");
X  report(&in, 1, 0, 0, 0, 0, 0);
X
X  /* Make necessary initializations so that Triangle can return a */
X  /*   triangulation in `mid' and a voronoi diagram in `vorout'.  */
X
X  mid.pointlist = (REAL *) NULL;            /* Not needed if -N switch used. */
X  /* Not needed if -N switch used or number of point attributes is zero: */
X  mid.pointattributelist = (REAL *) NULL;
X  mid.pointmarkerlist = (int *) NULL; /* Not needed if -N or -B switch used. */
X  mid.trianglelist = (int *) NULL;          /* Not needed if -E switch used. */
X  /* Not needed if -E switch used or number of triangle attributes is zero: */
X  mid.triangleattributelist = (REAL *) NULL;
X  mid.neighborlist = (int *) NULL;         /* Needed only if -n switch used. */
X  /* Needed only if segments are output (-p or -c) and -P not used: */
X  mid.segmentlist = (int *) NULL;
X  /* Needed only if segments are output (-p or -c) and -P and -B not used: */
X  mid.segmentmarkerlist = (int *) NULL;
X  mid.edgelist = (int *) NULL;             /* Needed only if -e switch used. */
X  mid.edgemarkerlist = (int *) NULL;   /* Needed if -e used and -B not used. */
X
X  vorout.pointlist = (REAL *) NULL;        /* Needed only if -v switch used. */
X  /* Needed only if -v switch used and number of attributes is not zero: */
X  vorout.pointattributelist = (REAL *) NULL;
X  vorout.edgelist = (int *) NULL;          /* Needed only if -v switch used. */
X  vorout.normlist = (REAL *) NULL;         /* Needed only if -v switch used. */
X
X  /* Triangulate the points.  Switches are chosen to read and write a  */
X  /*   PSLG (p), preserve the convex hull (c), number everything from  */
X  /*   zero (z), assign a regional attribute to each element (A), and  */
X  /*   produce an edge list (e), a Voronoi diagram (v), and a triangle */
X  /*   neighbor list (n).                                              */
X
X  triangulate("pczAevn", &in, &mid, &vorout);
X
X  printf("Initial triangulation:\n\n");
X  report(&mid, 1, 1, 1, 1, 1, 0);
X  printf("Initial Voronoi diagram:\n\n");
X  report(&vorout, 0, 0, 0, 0, 1, 1);
X
X  /* Attach area constraints to the triangles in preparation for */
X  /*   refining the triangulation.                               */
X
X  /* Needed only if -r and -a switches used: */
X  mid.trianglearealist = (REAL *) malloc(mid.numberoftriangles * sizeof(REAL));
X  mid.trianglearealist[0] = 3.0;
X  mid.trianglearealist[1] = 1.0;
X
X  /* Make necessary initializations so that Triangle can return a */
X  /*   triangulation in `out'.                                    */
X
X  out.pointlist = (REAL *) NULL;            /* Not needed if -N switch used. */
X  /* Not needed if -N switch used or number of attributes is zero: */
X  out.pointattributelist = (REAL *) NULL;
X  out.trianglelist = (int *) NULL;          /* Not needed if -E switch used. */
X  /* Not needed if -E switch used or number of triangle attributes is zero: */
X  out.triangleattributelist = (REAL *) NULL;
X
X  /* Refine the triangulation according to the attached */
X  /*   triangle area constraints.                       */
X
X  triangulate("prazBP", &mid, &out, (struct triangulateio *) NULL);
X
X  printf("Refined triangulation:\n\n");
X  report(&out, 0, 1, 0, 0, 0, 0);
X
X  /* Free all allocated arrays, including those allocated by Triangle. */
X
X  free(in.pointlist);
X  free(in.pointattributelist);
X  free(in.pointmarkerlist);
X  free(in.regionlist);
X  free(mid.pointlist);
X  free(mid.pointattributelist);
X  free(mid.pointmarkerlist);
X  free(mid.trianglelist);
X  free(mid.triangleattributelist);
X  free(mid.trianglearealist);
X  free(mid.neighborlist);
X  free(mid.segmentlist);
X  free(mid.segmentmarkerlist);
X  free(mid.edgelist);
X  free(mid.edgemarkerlist);
X  free(vorout.pointlist);
X  free(vorout.pointattributelist);
X  free(vorout.edgelist);
X  free(vorout.normlist);
X  free(out.pointlist);
X  free(out.pointattributelist);
X  free(out.trianglelist);
X  free(out.triangleattributelist);
X
X  return 0;
}
SHAR_EOF
  (set 20 05 07 27 16 54 23 'tricall.c'; eval "$shar_touch") &&
  chmod 0644 'tricall.c' ||
  $echo 'restore of' 'tricall.c' 'failed'
  if ( md5sum --help 2>&1 | grep 'sage: md5sum \[' ) >/dev/null 2>&1 \
  && ( md5sum --version 2>&1 | grep -v 'textutils 1.12' ) >/dev/null; then
    md5sum -c << SHAR_EOF >/dev/null 2>&1 \
    || $echo 'tricall.c:' 'MD5 check failed'
f19cfcc5ad342df56fe1be00c7dbf009  tricall.c
SHAR_EOF
  else
    shar_count="`LC_ALL= LC_CTYPE= LANG= wc -c < 'tricall.c'`"
    test 10300 -eq "$shar_count" ||
    $echo 'tricall.c:' 'original size' '10300,' 'current size' "$shar_count!"
  fi
fi
rm -fr _sh09797
exit 0
